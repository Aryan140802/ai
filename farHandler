#!/usr/bin/env python3
"""
Process Database Handler
Handles process/FAR details related database queries
"""

import re
import pymysql
from typing import List, Optional
from langchain_community.utilities import SQLDatabase
from langchain.chains import create_sql_query_chain
from base_handler import BaseHandler

class ProcessHandler(BaseHandler):
    """Handler for process/FAR database queries"""
    
    def __init__(self, llm=None):
        super().__init__("Process Handler", llm)
        self.db_config = {
            "host": "localhost",
            "user": "root",
            "password": "root123", 
            "database": "EIS_n"
        }
        self.include_tables = ["FarDetailsAll"]
        self.connection = None
        self.chain = None
    
    def initialize(self) -> bool:
        """Initialize database connection and SQL chain"""
        try:
            # Create database connection for queries
            self.connection = pymysql.connect(**self.db_config)
            
            # Create LangChain SQL database and chain
            if self.llm:
                uri = f"mysql+pymysql://{self.db_config['user']}:{self.db_config['password']}@{self.db_config['host']}/{self.db_config['database']}"
                db_for_llm = SQLDatabase.from_uri(uri, include_tables=self.include_tables)
                self.chain = create_sql_query_chain(self.llm, db_for_llm)
            
            self.initialized = True
            self.log_info("Database connection established")
            return True
            
        except Exception as e:
            self.log_error(f"Failed to initialize database connection: {e}", e)
            return False
    
    def get_patterns(self) -> List[str]:
        """Return regex patterns for process-related queries"""
        return [
            r'\b(process|pid|far|details)\b.*\b(database|table|stored|history|log)\b',
            r'\b(which|what|show|list)\b.*\bprocess\b.*\b(memory|cpu|usage|database)\b',
            r'\bfar\s*details\b',
            r'\bprocess\b.*\b(sorted|maximum|minimum|highest|lowest)\b',
            r'\b(database|table|stored)\b.*\bprocess\b'
        ]
    
    def get_keywords(self) -> List[str]:
        """Return keywords for process-related queries"""
        return [
            "process", "pid", "far", "details", "fardetails", "stored", 
            "database", "table", "maximum", "minimum", "highest", "lowest", 
            "memory", "cpu", "usage"
        ]
    
    def can_handle(self, question: str) -> bool:
        """Check if this handler can process the question"""
        question_lower = question.lower()
        
        # Check patterns
        for pattern in self.get_patterns():
            if re.search(pattern, question_lower):
                return True
        
        # Check keywords with context
        words = question_lower.split()
        process_keywords = ["process", "pid", "far", "fardetails"]
        context_keywords = ["database", "table", "stored", "history", "maximum", "minimum"]
        
        has_process_keyword = any(word in process_keywords for word in words)
        has_context_keyword = any(word in context_keywords for word in words)
        
        return has_process_keyword and (has_context_keyword or "details" in words)
    
    def clean_sql(self, raw_sql: str) -> str:
        """Clean LLM-generated SQL"""
        match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
        if match:
            sql = match.group(1)
        else:
            sql = re.sub(r"```", "", raw_sql)
            sql = re.sub(r"^(.*?)(SELECT|INSERT|UPDATE|DELETE|WITH)", r"\2", sql, flags=re.IGNORECASE | re.DOTALL)
        return sql.strip().rstrip(";")
    
    def is_select_query(self, sql: str) -> bool:
        """Check if query is a read-only SELECT statement"""
        return sql.strip().lower().startswith('select')
    
    def format_result(self, result: List[tuple], columns: Optional[List[str]] = None) -> str:
        """Format database query results"""
        if not result:
            return "No process/FAR data found for your request."
        
        if len(result) == 1 and len(result[0]) == 1:
            return f"Result: {result[0][0]}"
        
        if columns and len(result) <= 10:
            # Format as table for small results
            output = []
            col_widths = [max(len(str(col)), max(len(str(row[i])) for row in result)) for i, col in enumerate(columns)]
            
            # Header
            header = " | ".join(col.ljust(width) for col, width in zip(columns, col_widths))
            separator = "-+-".join("-" * width for width in col_widths)
            output.append(header)
            output.append(separator)
            
            # Rows
            for row in result[:10]:
                formatted_row = " | ".join(str(val).ljust(width) for val, width in zip(row, col_widths))
                output.append(formatted_row)
            
            if len(result) > 10:
                output.append(f"... and {len(result) - 10} more rows")
            
            return "\n".join(output)
        
        # Simple list format
        rows = []
        for row in result[:20]:
            rows.append(" | ".join(str(val) for val in row))
        
        if len(result) > 20:
            rows.append(f"... and {len(result) - 20} more rows")
        
        return "\n".join(rows)
    
    def process_query(self, question: str) -> str:
        """Process process/FAR database query"""
        if not self.initialized:
            return "❌ Process database handler not initialized."
        
        try:
            # Generate SQL using AI
            raw_sql = self.chain.invoke({"question": question})
            sql = self.clean_sql(raw_sql)
            
            # Security check
            if not self.is_select_query(sql):
                return "🚫 Only SELECT queries are allowed for security."
            
            # Execute query
            with self.connection.cursor() as cursor:
                cursor.execute(sql)
                result = cursor.fetchall()
                columns = [desc[0] for desc in cursor.description] if cursor.description else None
            
            if not result:
                return "No process/FAR data found matching your query."
            
            # Format result
            formatted_result = self.format_result(result, columns)
            
            # Use AI to provide context and interpretation
            if self.llm:
                context = f"""A user asked about process/FAR information: "{question}"

Database query results from FarDetailsAll table:
{formatted_result}

Please provide a clear, natural language response that directly answers the user's question about process/FAR data. Make it conversational and helpful."""
                
                ai_interpretation = self.llm.invoke(context)
                return ai_interpretation
            else:
                return f"Process/FAR Query Results:\n{formatted_result}"
                
        except Exception as e:
            self.log_error(f"Database query error: {e}", e)
            return f"❌ Unable to retrieve process information: {e}"
    
    def cleanup(self):
        """Clean up database connection"""
        if self.connection and self.connection.open:
            self.connection.close()
            self.log_info("Database connection closed")
    
    def get_status(self) -> dict:
        """Get handler status"""
        status = super().get_status()
        status.update({
            "database": self.db_config["database"],
            "host": self.db_config["host"],
            "tables": self.include_tables,
            "connection_open": self.connection.open if self.connection else False
        })
        return status
