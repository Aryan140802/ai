import os
import re
import logging
import pymysql
import traceback
from typing import List, Optional, Dict, Any, Tuple
from datetime import datetime
import json

from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

# --- CONFIGURATION ---

DB_CONFIG = {
    "name": "FAR Details",
    "db_config": {
        "host": "localhost", 
        "user": "root", 
        "password": "root123", 
        "database": "EIS_n"
    },
    "include_tables": ["FarDetailsAll"],
}

logging.basicConfig(
    filename=os.path.expanduser("~/.database_query_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def clean_sql(raw_sql: str) -> str:
    """Clean and extract SQL from LLM response"""
    match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
    if match:
        sql = match.group(1)
    else:
        sql = re.sub(r"```", "", raw_sql)
        sql = re.sub(r"^(.*?)(SELECT|INSERT|UPDATE|DELETE|WITH)", r"\2", sql, flags=re.IGNORECASE | re.DOTALL)
    
    # Replace = with LIKE for text comparisons and add wildcards
    sql = enhance_sql_with_like(sql.strip().rstrip(";"))
    return sql

def enhance_sql_with_like(sql: str) -> str:
    """
    Enhance SQL queries to use LIKE instead of = for text searches
    and add wildcards for better matching
    """
    # Pattern to find WHERE clauses with string comparisons using =
    # This will match patterns like: column_name = 'value' or column_name = "value"
    pattern = r"(\w+)\s*=\s*(['\"])([^'\"]+)\2"
    
    def replace_with_like(match):
        column = match.group(1)
        quote = match.group(2)
        value = match.group(3)
        # Add wildcards around the value for partial matching
        return f"{column} LIKE {quote}%{value}%{quote}"
    
    # Replace = with LIKE for string comparisons
    enhanced_sql = re.sub(pattern, replace_with_like, sql)
    
    return enhanced_sql

def format_answer(result: List[tuple], columns: Optional[List[str]] = None) -> str:
    """Format query results for display"""
    if not result:
        return "No data found for your request."
    
    if len(result) == 1 and len(result[0]) == 1:
        return f"Result: {result[0][0]}"
    
    if columns and len(result) <= 10:
        output = []
        col_widths = [max(len(str(col)), max(len(str(row[i])) for row in result)) for i, col in enumerate(columns)]
        header = " | ".join(col.ljust(width) for col, width in zip(columns, col_widths))
        separator = "-+-".join("-" * width for width in col_widths)
        output.append(header)
        output.append(separator)
        
        for row in result[:10]:
            formatted_row = " | ".join(str(val).ljust(width) for val, width in zip(row, col_widths))
            output.append(formatted_row)
        
        if len(result) > 10:
            output.append(f"... and {len(result) - 10} more rows")
        return "\n".join(output)
    
    rows = []
    for row in result[:20]:
        rows.append(" | ".join(str(val) for val in row))
    
    if len(result) > 20:
        rows.append(f"... and {len(result) - 20} more rows")
    
    return "\n".join(rows)

def is_select_query(sql: str) -> bool:
    """Check if query is a SELECT statement"""
    return sql.strip().lower().startswith('select')

def clear_screen():
    """Clear terminal screen"""
    os.system("cls" if os.name == "nt" else "clear")

class DatabaseQueryAssistant:
    def __init__(self):
        self.llm = None
        self.db_handler = None
        self.initialized = False
        self.chat_history = []

    def initialize(self):
        """Initialize the database query assistant"""
        try:
            print("ğŸ”§ Initializing Database Query Assistant...")
            
            # Initialize LLM with enhanced prompt for LIKE queries
            self.llm = OllamaLLM(model="mistral:7b-instruct-q4_K_M", temperature=0.1)
            
            # Initialize database connection
            try:
                db_cfg = DB_CONFIG['db_config']
                uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"
                db_for_llm = SQLDatabase.from_uri(uri, include_tables=DB_CONFIG.get("include_tables"))
                
                # Create chain with enhanced prompt for LIKE operations
                chain = create_sql_query_chain(self.llm, db_for_llm)
                db_conn = pymysql.connect(**db_cfg)
                
                self.db_handler = {
                    'chain': chain,
                    'connection': db_conn,
                    'config': DB_CONFIG
                }
                print(f"âœ… {DB_CONFIG['name']} database connected")
            except Exception as e:
                print(f"âš ï¸  Failed to connect to {DB_CONFIG['name']}: {e}")
                logger.error(f"DB connection failed: {e}")
                return False
                
            self.initialized = True
            print("âœ… Database Query Assistant initialized successfully!")
            return True
        except Exception as e:
            print(f"âŒ Initialization failed: {e}")
            logger.error(f"Initialization failed: {e}", exc_info=True)
            return False

    def save_feedback(self, question, answer, feedback):
        """Save user feedback for query improvement"""
        data = {
            "question": question,
            "answer": answer,
            "feedback": feedback,
            "timestamp": datetime.now().isoformat()
        }
        try:
            with open("database_feedback_log.jsonl", "a") as f:
                f.write(json.dumps(data) + "\n")
        except Exception as e:
            logger.error(f"Failed to save feedback: {e}")

    def find_relevant_feedback(self, question):
        """Find relevant feedback for similar queries"""
        try:
            with open("database_feedback_log.jsonl", "r") as f:
                lines = f.readlines()
            for line in lines[::-1]:
                entry = json.loads(line)
                if entry["question"].strip().lower() in question.strip().lower():
                    return entry["feedback"]
        except Exception:
            pass
        return None

    def query_database(self, question: str) -> str:
        """Execute database query with LIKE enhancements"""
        if not self.db_handler:
            return "âŒ Database not available."
        
        try:
            # Enhanced prompt to encourage LIKE usage
            enhanced_question = f"""
            Generate a SQL query for: {question}
            
            Important guidelines:
            - Use LIKE operator with wildcards (%) for text searches instead of exact matches
            - Use partial matching for names, descriptions, and text fields
            - For example: WHERE column_name LIKE '%search_term%' instead of WHERE column_name = 'search_term'
            - Only generate SELECT queries
            """
            
            raw_sql = self.db_handler['chain'].invoke({"question": enhanced_question})
            sql = clean_sql(raw_sql)
            
            if not is_select_query(sql):
                return "ğŸš« Only SELECT queries are allowed for security."
            
            logger.info(f"Executing SQL: {sql}")
            
            with self.db_handler['connection'].cursor() as cursor:
                cursor.execute(sql)
                result = cursor.fetchall()
                columns = [desc[0] for desc in cursor.description] if cursor.description else None
            
            if not result:
                return "No data found matching your query."
            
            formatted_result = format_answer(result, columns)
            
            # Generate natural language response
            context = f"""
Based on the database query results, provide a clear and helpful response to the user's question.

Original question: {question}
SQL executed: {sql}
Results found: {len(result)} records

Query results:
{formatted_result}

Please provide a natural language summary that directly answers the user's question based on this data.
"""
            
            feedback = self.find_relevant_feedback(question)
            if feedback:
                context += f"\nNote: Previously, a user provided this feedback for a similar question: '{feedback}'"
            
            ai_interpretation = self.llm.invoke(context)
            self.chat_history.append({"user": question, "assistant": ai_interpretation, "sql": sql})
            
            return f"{ai_interpretation}\n\nğŸ“Š Query executed: {sql}"
            
        except Exception as e:
            logger.error(f"Database query error: {e}")
            return f"âŒ Unable to retrieve that information: {str(e)}"

    def process_question(self, question: str) -> Dict[str, Any]:
        """Process database question and return structured response"""
        if not self.initialized:
            return {
                "success": False,
                "error": "Assistant not initialized",
                "response": "âŒ Assistant not initialized. Please restart."
            }
        
        try:
            response = self.query_database(question)
            
            return {
                "success": True,
                "query": question,
                "response": response,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Processing error: {e}")
            return {
                "success": False,
                "error": str(e),
                "response": f"âŒ Error processing your request: {e}"
            }

    def show_help(self):
        """Display help information"""
        help_text = """
ğŸ“– DATABASE QUERY ASSISTANT HELP

ğŸ’¾ DATABASE QUERIES:
  Examples of what you can ask:
  - "Find all FAR details containing 'process'"
  - "Show records where name contains 'test'"
  - "List all entries with memory usage above 100"
  - "Find processes that have 'java' in their name"
  - "Show all records created today"
  - "Search for entries containing 'error' in description"

ğŸ” QUERY FEATURES:
  - Automatic LIKE operator usage for text searches
  - Partial matching with wildcards (%)
  - Case-insensitive searches
  - Only SELECT queries allowed for security

ğŸ’¡ COMMANDS:
  - 'help' - Show this help
  - 'clear' - Clear screen
  - 'status' - Show system status
  - 'exit' - Quit assistant

ğŸ“Š The assistant will show both the natural language response and the actual SQL query executed.
        """
        print(help_text)

    def show_status(self):
        """Display system status"""
        print("ğŸ” SYSTEM STATUS")
        print(f"ğŸ“… Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"ğŸ¤– AI Model: {'âœ… Initialized' if self.initialized else 'âŒ Not Initialized'}")
        print(f"ğŸ’¾ Database Connection: {'âœ… Connected' if self.db_handler and self.db_handler['connection'].open else 'âŒ Disconnected'}")
        if self.db_handler:
            print(f"   - Database: {self.db_handler['config']['name']}")
            print(f"   - Tables: {', '.join(self.db_handler['config']['include_tables'])}")
        print(f"ğŸ“Š Chat History: {len(self.chat_history)} queries")

    def start_interactive_session(self):
        """Start interactive query session"""
        if not self.initialize():
            return
            
        clear_screen()
        print("ğŸ—„ï¸  Database Query Assistant Ready")
        print("Ask me about your database data using natural language...")
        print("Type 'exit' to quit, 'help' for examples\n")
        
        while True:
            try:
                question = input("ğŸ” Query: ").strip()
                if not question:
                    continue
                
                question_lower = question.lower()
                if question_lower in ['exit', 'quit', 'q']:
                    print("ğŸ‘‹ Goodbye!")
                    break
                elif question_lower == 'help':
                    self.show_help()
                    continue
                elif question_lower == 'clear':
                    clear_screen()
                    continue
                elif question_lower == 'status':
                    self.show_status()
                    continue
                
                result = self.process_question(question)
                print(f"\nğŸ“ Response:\n{result['response']}\n")
                
                if result['success']:
                    feedback = input("Was this answer helpful? (yes/no/correction): ").strip()
                    if feedback.lower() not in ['yes', 'y', '']:
                        self.save_feedback(question, result['response'], feedback)
                        print("Thank you for the feedback!")
                        
            except KeyboardInterrupt:
                print("\nğŸ‘‹ Goodbye!")
                break
            except Exception as e:
                print(f"\nâŒ Error: {e}")
                logger.error(f"Session error: {e}", exc_info=True)
        
        # Close database connection
        if self.db_handler and self.db_handler['connection'].open:
            self.db_handler['connection'].close()
        print("Database connection closed.")

def main():
    """Main function"""
    assistant = DatabaseQueryAssistant()
    
    # Example usage
    print("=== Database Query Assistant Examples ===")
    if assistant.initialize():
        
        # Example queries
        examples = [
            "Find all records containing 'java'",
            "Show processes with memory usage above 50",
            "List all FAR details"
        ]
        
        for example in examples:
            print(f"\nExample: {example}")
            result = assistant.process_question(example)
            print(f"Success: {result['success']}")
            if result['success']:
                print(f"Response preview: {result['response'][:100]}...")
        
        print("\n" + "="*50)
        
    # Start interactive session
    assistant.start_interactive_session()

if __name__ == "__main__":
    main()
