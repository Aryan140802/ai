import os
import re
import logging
import pymysql
import traceback
from typing import List, Optional, Dict, Any
from datetime import datetime, date, timedelta
import json
import calendar
import sqlparse
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

# --- CONFIGURATION ---
DATABASE_CONFIG = {
    "host": "localhost",
    "user": "root", 
    "password": "root123",
    "database": "EIS_n",
    "charset": "utf8mb4"
}

REPORT_CONFIG = {
    "name": "System Reports Database Query",
    "table_name": "EISHome_compliance",  # Your actual table name
    "supported_queries": ["system info", "performance", "security", "versions", "analytics"]
}

# Configure logging
logging.basicConfig(
    filename=os.path.expanduser("~/.system_report_db_query_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def clean_query_response(raw_response: str) -> str:
    """Clean and extract meaningful response from LLM"""
    response = re.sub(r"```[\w]*\s*(.*?)\s*```", r"\1", raw_response, flags=re.DOTALL)
    return response.strip()

def format_sql_query(query: str) -> str:
    """Format SQL query for better readability"""
    try:
        return sqlparse.format(query, reindent=True, keyword_case='upper')
    except:
        return query

def format_db_results(results: List[Dict], query_type: str = "general", max_items: int = 20) -> str:
    """Format database query results for display with intelligent formatting"""
    if not results:
        return "No data found for your request."

    if len(results) == 1:
        # Single result - show all non-null fields
        result = results[0]
        output = []
        for key, value in result.items():
            if value is not None and str(value).strip():
                # Format field names nicely
                field_name = key.replace('_', ' ').title()
                output.append(f"{field_name}: {value}")
        return "\n".join(output)

    # Multiple results - intelligent formatting based on query type
    output = []
    
    if query_type == "performance":
        # Performance-focused display
        for i, result in enumerate(results[:max_items]):
            server_info = f"{i+1}. {result.get('ip_address', 'Unknown IP')}"
            if result.get('server_role'):
                server_info += f" ({result['server_role']})"
            
            perf_metrics = []
            if result.get('ram'):
                perf_metrics.append(f"RAM: {result['ram']}GB")
            if result.get('cpuCore'):
                perf_metrics.append(f"CPU: {result['cpuCore']} cores")
            if result.get('cpu') is not None:
                perf_metrics.append(f"CPU Usage: {result['cpu']}%")
            if result.get('memory') is not None:
                perf_metrics.append(f"Memory Usage: {result['memory']}%")
            
            if perf_metrics:
                server_info += f" | {' | '.join(perf_metrics)}"
            output.append(server_info)
    
    elif query_type == "security":
        # Security-focused display
        for i, result in enumerate(results[:max_items]):
            server_info = f"{i+1}. {result.get('ip_address', 'Unknown IP')}"
            if result.get('server_role'):
                server_info += f" ({result['server_role']})"
            
            security_info = []
            if result.get('firewall'):
                security_info.append(f"Firewall: {result['firewall']}")
            if result.get('dsAgent'):
                security_info.append(f"DS Agent: {result['dsAgent']}")
            if result.get('eisuserExpi'):
                security_info.append(f"EIS User Expires: {result['eisuserExpi']}")
            
            if security_info:
                server_info += f" | {' | '.join(security_info)}"
            output.append(server_info)
    
    elif query_type == "versions":
        # Version-focused display
        for i, result in enumerate(results[:max_items]):
            server_info = f"{i+1}. {result.get('ip_address', 'Unknown IP')}"
            if result.get('server_role'):
                server_info += f" ({result['server_role']})"
            
            version_info = []
            if result.get('osVersion'):
                version_info.append(f"OS: {result['osVersion']}")
            if result.get('kernelVersion'):
                version_info.append(f"Kernel: {result['kernelVersion']}")
            if result.get('aceVersion'):
                version_info.append(f"ACE: {result['aceVersion']}")
            
            if version_info:
                server_info += f" | {' | '.join(version_info)}"
            output.append(server_info)
    
    else:
        # General display - show key identifying fields
        for i, result in enumerate(results[:max_items]):
            server_info = f"{i+1}. {result.get('ip_address', 'Unknown IP')}"
            if result.get('server_role'):
                server_info += f" ({result['server_role']})"
            if result.get('osVersion'):
                server_info += f" - {result['osVersion']}"
            if result.get('upTime'):
                server_info += f" - Uptime: {result['upTime']}"
            output.append(server_info)

    if len(results) > max_items:
        output.append(f"\n... and {len(results) - max_items} more servers")
    
    return "\n".join(output)

def clear_screen():
    """Clear terminal screen"""
    os.system("cls" if os.name == "nt" else "clear")

class AdvancedDatabaseQueryAssistant:
    def __init__(self):
        self.llm = None
        self.db = None
        self.sql_chain = None
        self.connection = None
        self.initialized = False
        self.chat_history = []
        self.schema_info = {}
        
    def initialize(self):
        """Initialize the advanced database query assistant"""
        try:
            print("🔧 Initializing Advanced Database Query Assistant...")

            # Initialize database connection
            self.connect_to_database()
            
            # Initialize LLM
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.0)
            
            # Initialize LangChain SQL Database
            port_part = f":{DATABASE_CONFIG['port']}" if 'port' in DATABASE_CONFIG and DATABASE_CONFIG['port'] else ""
            db_uri = f"mysql+pymysql://{DATABASE_CONFIG['user']}:{DATABASE_CONFIG['password']}@{DATABASE_CONFIG['host']}{port_part}/{DATABASE_CONFIG['database']}"
            self.db = SQLDatabase.from_uri(db_uri)
            
            # Create SQL query chain
            self.sql_chain = create_sql_query_chain(self.llm, self.db)
            
            # Load schema information
            self.load_schema_info()

            self.initialized = True
            print("✅ Advanced Database Query Assistant initialized successfully!")
            return True
            
        except Exception as e:
            print(f"❌ Initialization failed: {e}")
            logger.error(f"Initialization failed: {e}", exc_info=True)
            return False

    def connect_to_database(self):
        """Establish PyMySQL database connection"""
        try:
            # Create connection config, only include port if specified
            connection_config = {
                "host": DATABASE_CONFIG['host'],
                "user": DATABASE_CONFIG['user'],
                "password": DATABASE_CONFIG['password'],
                "database": DATABASE_CONFIG['database'],
                "charset": DATABASE_CONFIG['charset'],
                "cursorclass": pymysql.cursors.DictCursor
            }
            
            # Only add port if it exists in config
            if 'port' in DATABASE_CONFIG and DATABASE_CONFIG['port']:
                connection_config['port'] = DATABASE_CONFIG['port']
            
            self.connection = pymysql.connect(**connection_config)
            print("✅ PyMySQL database connection established")
            return True
            
        except Exception as e:
            print(f"❌ Database connection failed: {e}")
            logger.error(f"Database connection failed: {e}")
            return False

    def load_schema_info(self):
        """Load comprehensive database schema information"""
        try:
            with self.connection.cursor() as cursor:
                # Get table structure
                cursor.execute(f"DESCRIBE {REPORT_CONFIG['table_name']}")
                columns = cursor.fetchall()
                
                # Get sample data for better context
                cursor.execute(f"SELECT * FROM {REPORT_CONFIG['table_name']} LIMIT 3")
                sample_data = cursor.fetchall()
                
                # Get table statistics
                cursor.execute(f"SELECT COUNT(*) as total_records FROM {REPORT_CONFIG['table_name']}")
                total_records = cursor.fetchone()['total_records']
                
                self.schema_info = {
                    'columns': columns,
                    'column_names': [col['Field'] for col in columns],
                    'column_types': {col['Field']: col['Type'] for col in columns},
                    'sample_data': sample_data,
                    'total_records': total_records,
                    'table_name': REPORT_CONFIG['table_name']
                }
                
                print(f"✅ Loaded schema for table: {REPORT_CONFIG['table_name']}")
                print(f"📊 Found {len(self.schema_info['columns'])} columns, {total_records} records")
                
                return True
                
        except Exception as e:
            print(f"❌ Failed to load schema: {e}")
            logger.error(f"Failed to load schema: {e}")
            return False

    def execute_sql_query(self, query: str) -> List[Dict]:
        """Execute SQL query and return results"""
        try:
            with self.connection.cursor() as cursor:
                cursor.execute(query)
                results = cursor.fetchall()
                return results
                
        except Exception as e:
            logger.error(f"Query execution error: {e}")
            raise e

    def analyze_question_intent(self, question: str) -> Dict:
        """Advanced question analysis to determine intent and extract metadata"""
        question_lower = question.lower()
        
        intent = {
            'type': 'general',
            'complexity': 'simple',
            'requires_aggregation': False,
            'time_based': False,
            'comparison': False,
            'keywords': []
        }
        
        # Detect query complexity
        complex_keywords = ['compare', 'analyze', 'trend', 'average', 'distribution', 'correlation']
        if any(keyword in question_lower for keyword in complex_keywords):
            intent['complexity'] = 'complex'
        
        # Detect aggregation needs
        agg_keywords = ['count', 'sum', 'average', 'max', 'min', 'total', 'group by', 'statistics']
        if any(keyword in question_lower for keyword in agg_keywords):
            intent['requires_aggregation'] = True
        
        # Detect time-based queries
        time_keywords = ['last', 'recent', 'today', 'yesterday', 'week', 'month', 'expired', 'expiring']
        if any(keyword in question_lower for keyword in time_keywords):
            intent['time_based'] = True
        
        # Detect comparison queries
        comp_keywords = ['compare', 'versus', 'vs', 'difference', 'between']
        if any(keyword in question_lower for keyword in comp_keywords):
            intent['comparison'] = True
        
        # Determine primary query type
        if any(word in question_lower for word in ['performance', 'cpu', 'memory', 'ram', 'cores', 'usage']):
            intent['type'] = 'performance'
        elif any(word in question_lower for word in ['security', 'firewall', 'agent', 'expiry', 'expire', 'expired']):
            intent['type'] = 'security'
        elif any(word in question_lower for word in ['version', 'os', 'kernel', 'ace', 'mq', 'update']):
            intent['type'] = 'versions'
        elif any(word in question_lower for word in ['server', 'role', 'infrastructure', 'system']):
            intent['type'] = 'infrastructure'
        elif any(word in question_lower for word in ['count', 'total', 'statistics', 'distribution']):
            intent['type'] = 'analytics'
        
        return intent

    def generate_sql_with_langchain(self, question: str) -> str:
        """Generate SQL query using LangChain SQL chain"""
        try:
            # Add context to the question for better SQL generation
            context_question = f"""
            Based on the system_reports table with the following columns:
            {', '.join(self.schema_info['column_names'])}
            
            User question: {question}
            
            Generate a SQL query to answer this question. The table contains server infrastructure data including IP addresses, server roles, system specifications, versions, and security information.
            """
            
            sql_query = self.sql_chain.invoke({"question": context_question})
            
            # Clean up the generated SQL
            sql_query = sql_query.strip()
            if sql_query.startswith('```sql'):
                sql_query = sql_query[6:]
            if sql_query.endswith('```'):
                sql_query = sql_query[:-3]
            sql_query = sql_query.strip()
            
            logger.info(f"Generated SQL via LangChain: {sql_query}")
            return sql_query
            
        except Exception as e:
            logger.error(f"LangChain SQL generation error: {e}")
            raise e

    def validate_and_enhance_sql(self, sql_query: str, intent: Dict) -> str:
        """Validate and enhance generated SQL query"""
        try:
            # Parse SQL to validate syntax
            parsed = sqlparse.parse(sql_query)[0]
            
            # Add safety limits if not present
            sql_lower = sql_query.lower()
            if 'limit' not in sql_lower and 'count(' not in sql_lower:
                sql_query += " LIMIT 50"  # Default safety limit
            
            # Enhance query based on intent
            if intent['type'] == 'performance' and 'order by' not in sql_lower:
                if 'ram' in sql_lower or 'cpu' in sql_lower:
                    sql_query = sql_query.replace(' LIMIT', ' ORDER BY ram DESC, cpuCore DESC LIMIT')
            
            return sql_query
            
        except Exception as e:
            logger.warning(f"SQL validation warning: {e}")
            return sql_query  # Return original if validation fails

    def process_natural_language_query(self, question: str) -> str:
        """Process natural language query using advanced NL2SQL"""
        try:
            # Analyze question intent
            intent = self.analyze_question_intent(question)
            
            # Generate SQL using LangChain
            sql_query = self.generate_sql_with_langchain(question)
            
            # Validate and enhance SQL
            enhanced_sql = self.validate_and_enhance_sql(sql_query, intent)
            
            # Format SQL for logging
            formatted_sql = format_sql_query(enhanced_sql)
            logger.info(f"Final SQL Query:\n{formatted_sql}")
            
            # Execute query
            results = self.execute_sql_query(enhanced_sql)
            
            # Format results based on intent
            formatted_results = format_db_results(results, intent['type'])
            
            # Add query information to response
            response = f"📊 Query Results:\n{formatted_results}\n\n"
            response += f"🔍 SQL Query Used:\n{formatted_sql}"
            
            return response
            
        except Exception as e:
            logger.error(f"Natural language query processing error: {e}")
            return f"❌ Error processing query: {str(e)}"

    def get_intelligent_insights(self, question: str, results: List[Dict]) -> str:
        """Generate intelligent insights using LLM based on query results"""
        try:
            if not results:
                return "No data available for analysis."
            
            # Prepare context for LLM
            context = {
                'question': question,
                'result_count': len(results),
                'sample_results': results[:3],  # First 3 results for context
                'schema': self.schema_info['column_names']
            }
            
            prompt = f"""
            As a system administrator AI assistant, analyze the following database query results and provide intelligent insights.

            Original Question: {question}
            Number of Results: {len(results)}
            
            Sample Data:
            {json.dumps(results[:3], indent=2, default=str)}
            
            Provide insights including:
            1. Key findings from the data
            2. Any patterns or anomalies noticed
            3. Recommendations for system administration
            4. Potential issues or areas of concern
            5. Summary statistics if relevant
            
            Keep the response practical and actionable for system administrators.
            """
            
            insights = self.llm.invoke(prompt)
            return clean_query_response(insights)
            
        except Exception as e:
            logger.error(f"Insights generation error: {e}")
            return "Unable to generate insights at this time."

    def process_question(self, question: str) -> Dict[str, Any]:
        """Main question processing method"""
        if not self.initialized:
            return {
                "success": False,
                "error": "Assistant not initialized",
                "response": "❌ Assistant not initialized. Please restart."
            }

        try:
            start_time = datetime.now()
            
            # Process the natural language query
            response = self.process_natural_language_query(question)
            
            # For complex queries, add AI insights
            intent = self.analyze_question_intent(question)
            if intent['complexity'] == 'complex':
                try:
                    # Execute a simple version of the query to get results for insights
                    sql_query = self.generate_sql_with_langchain(question)
                    results = self.execute_sql_query(sql_query)
                    insights = self.get_intelligent_insights(question, results)
                    response += f"\n\n🧠 AI Insights:\n{insights}"
                except:
                    pass  # Continue without insights if this fails
            
            processing_time = (datetime.now() - start_time).total_seconds()
            
            self.chat_history.append({
                "user": question, 
                "assistant": response,
                "timestamp": datetime.now().isoformat(),
                "processing_time": processing_time
            })

            return {
                "success": True,
                "query": question,
                "response": response,
                "timestamp": datetime.now().isoformat(),
                "processing_time": processing_time,
                "intent": intent
            }

        except Exception as e:
            logger.error(f"Processing error: {e}")
            return {
                "success": False,
                "error": str(e),
                "response": f"❌ Error processing your request: {e}"
            }

    def get_database_analytics(self) -> Dict:
        """Get comprehensive database analytics"""
        try:
            analytics = {}
            
            with self.connection.cursor() as cursor:
                # Basic counts
                cursor.execute(f"SELECT COUNT(*) as total FROM {REPORT_CONFIG['table_name']}")
                analytics['total_servers'] = cursor.fetchone()['total']
                
                # Server roles distribution
                cursor.execute(f"""
                    SELECT server_role, COUNT(*) as count 
                    FROM {REPORT_CONFIG['table_name']} 
                    WHERE server_role IS NOT NULL 
                    GROUP BY server_role 
                    ORDER BY count DESC
                """)
                analytics['server_roles'] = cursor.fetchall()
                
                # OS distribution
                cursor.execute(f"""
                    SELECT osVersion, COUNT(*) as count 
                    FROM {REPORT_CONFIG['table_name']} 
                    WHERE osVersion IS NOT NULL 
                    GROUP BY osVersion 
                    ORDER BY count DESC 
                    LIMIT 10
                """)
                analytics['os_distribution'] = cursor.fetchall()
                
                # System specifications analytics
                cursor.execute(f"""
                    SELECT 
                        AVG(ram) as avg_ram,
                        MIN(ram) as min_ram,
                        MAX(ram) as max_ram,
                        AVG(cpuCore) as avg_cpu,
                        MIN(cpuCore) as min_cpu,
                        MAX(cpuCore) as max_cpu
                    FROM {REPORT_CONFIG['table_name']}
                    WHERE ram > 0 AND cpuCore > 0
                """)
                analytics['system_specs'] = cursor.fetchone()
                
                # Security status
                cursor.execute(f"""
                    SELECT 
                        SUM(CASE WHEN firewall LIKE '%enabled%' OR firewall LIKE '%active%' THEN 1 ELSE 0 END) as firewall_enabled,
                        SUM(CASE WHEN dsAgent LIKE '%running%' OR dsAgent LIKE '%active%' THEN 1 ELSE 0 END) as ds_agent_active,
                        COUNT(*) as total_checked
                    FROM {REPORT_CONFIG['table_name']}
                    WHERE firewall IS NOT NULL OR dsAgent IS NOT NULL
                """)
                analytics['security_status'] = cursor.fetchone()
                
                return analytics
                
        except Exception as e:
            logger.error(f"Error getting database analytics: {e}")
            return {}

    def show_help(self):
        """Display comprehensive help information"""
        analytics = self.get_database_analytics()
        
        help_text = f"""
📖 ADVANCED DATABASE SYSTEM REPORT QUERY ASSISTANT HELP

📊 DATABASE STATUS:
  - Total Servers: {analytics.get('total_servers', 'Unknown')}
  - Connected via: LangChain + PyMySQL
  - AI Model: Ollama (myllm:latest)

💾 NATURAL LANGUAGE QUERY EXAMPLES:

  📈 Performance Analytics:
  - "Show me the top 10 servers with highest RAM"
  - "List servers with more than 8 CPU cores and 16GB RAM"
  - "Compare CPU and memory usage across different server roles"
  - "Find servers with performance issues"

  🔒 Security Queries:
  - "Which servers have firewall disabled?"
  - "Show expired user accounts across all servers"
  - "List servers without security agents running"
  - "Find servers with security vulnerabilities"

  🔧 Infrastructure Management:
  - "Group servers by their roles and show counts"
  - "Show distribution of operating systems"
  - "List all database servers with their specifications"
  - "Find servers that need OS updates"

  📊 Advanced Analytics:
  - "Calculate average RAM per server role"
  - "Show servers with kernel versions older than X"
  - "Analyze uptime patterns across infrastructure"
  - "Generate server inventory report"

  🔍 Specific Searches:
  - "Find server with IP address 192.168.1.100"
  - "Show all CentOS servers in production"
  - "List web servers with high memory usage"

🚀 ADVANCED FEATURES:
  - Natural Language to SQL conversion
  - Intelligent query optimization
  - Context-aware result formatting
  - AI-powered insights and recommendations
  - Complex multi-table analysis support
  - Real-time database statistics

💡 SYSTEM COMMANDS:
  - 'help' - Show this help
  - 'clear' - Clear screen
  - 'status' - Show system status
  - 'analytics' - Show database analytics
  - 'schema' - Show table structure
  - 'history' - Show recent queries
  - 'exit' - Quit assistant

🎯 QUERY TIPS:
  - Use natural language - the AI will convert to SQL
  - Be specific about what you want to analyze
  - Ask for comparisons, trends, and insights
  - Complex queries are supported and encouraged
        """
        print(help_text)

    def show_status(self):
        """Display detailed system status"""
        print("🔍 ADVANCED SYSTEM STATUS")
        print(f"📅 Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"🤖 AI Model: {'✅ Connected (Ollama)' if self.llm else '❌ Not Connected'}")
        print(f"🗄️  Database: {'✅ Connected (PyMySQL)' if self.connection else '❌ Not Connected'}")
        print(f"🔗 LangChain SQL: {'✅ Initialized' if self.sql_chain else '❌ Not Initialized'}")
        print(f"📝 Chat History: {len(self.chat_history)} queries")
        
        if self.schema_info:
            print(f"📊 Table: {self.schema_info['table_name']}")
            print(f"📋 Columns: {len(self.schema_info['columns'])}")
            print(f"📈 Records: {self.schema_info['total_records']}")

    def show_database_analytics(self):
        """Display comprehensive database analytics"""
        print("📊 DATABASE ANALYTICS DASHBOARD")
        analytics = self.get_database_analytics()
        
        if analytics:
            print(f"\n🖥️  Infrastructure Overview:")
            print(f"  Total Servers: {analytics.get('total_servers', 0)}")
            
            if analytics.get('server_roles'):
                print(f"\n🏷️ Server Roles Distribution:")
                for role_info in analytics['server_roles'][:8]:
                    print(f"  - {role_info['server_role']}: {role_info['count']} servers")
            
            if analytics.get('os_distribution'):
                print(f"\n💿 Operating Systems:")
                for os_info in analytics['os_distribution'][:6]:
                    print(f"  - {os_info['osVersion']}: {os_info['count']} servers")
            
            if analytics.get('system_specs'):
                specs = analytics['system_specs']
                print(f"\n⚡ System Specifications:")
                print(f"  - Average RAM: {specs.get('avg_ram', 0):.1f} GB (Range: {specs.get('min_ram', 0)}-{specs.get('max_ram', 0)} GB)")
                print(f"  - Average CPU Cores: {specs.get('avg_cpu', 0):.1f} (Range: {specs.get('min_cpu', 0)}-{specs.get('max_cpu', 0)})")
            
            if analytics.get('security_status'):
                sec = analytics['security_status']
                print(f"\n🔒 Security Status:")
                if sec.get('total_checked', 0) > 0:
                    fw_pct = (sec.get('firewall_enabled', 0) / sec['total_checked']) * 100
                    agent_pct = (sec.get('ds_agent_active', 0) / sec['total_checked']) * 100
                    print(f"  - Firewall Enabled: {sec.get('firewall_enabled', 0)} servers ({fw_pct:.1f}%)")
                    print(f"  - Security Agents Active: {sec.get('ds_agent_active', 0)} servers ({agent_pct:.1f}%)")
        else:
            print("❌ Could not retrieve database analytics")

    def show_schema(self):
        """Display table schema information"""
        print(f"📋 TABLE SCHEMA: {REPORT_CONFIG['table_name']}")
        print("-" * 80)
        
        if self.schema_info.get('columns'):
            print(f"{'Field':<20} {'Type':<20} {'Null':<8} {'Key':<8} {'Default':<15}")
            print("-" * 80)
            for col in self.schema_info['columns']:
                print(f"{col['Field']:<20} {col['Type']:<20} {col['Null']:<8} {col.get('Key', ''):<8} {str(col.get('Default', '')):<15}")
        
        print(f"\nTotal Columns: {len(self.schema_info.get('columns', []))}")
        print(f"Total Records: {self.schema_info.get('total_records', 'Unknown')}")

    def show_recent_history(self):
        """Show recent query history"""
        print("📝 RECENT QUERY HISTORY")
        print("-" * 60)
        
        recent_queries = self.chat_history[-10:]  # Last 10 queries
        for i, entry in enumerate(recent_queries, 1):
            timestamp = entry.get('timestamp', 'Unknown time')
            processing_time = entry.get('processing_time', 0)
            print(f"{i}. {timestamp}")
            print(f"   Q: {entry['user'][:80]}{'...' if len(entry['user']) > 80 else ''}")
            print(f"   Processing Time: {processing_time:.2f}s")
            print()

    def start_interactive_session(self):
        """Start enhanced interactive query session"""
        if not self.initialize():
            return

        clear_screen()
        print("🚀 Advanced Database System Report Query Assistant Ready")
        analytics = self.get_database_analytics()
        print(f"Connected to database with {analytics.get('total_servers', 0)} servers")
        print("Ask complex questions in natural language - AI will handle the SQL!")
        print("Type 'exit' to quit, 'help' for examples\n")

        while True:
            try:
                question = input("🤖 AI Query: ").strip()
                if not question:
                    continue

                question_lower = question.lower()
                if question_lower in ['exit', 'quit', 'q']:
                    print("👋 Goodbye!")
                    break
                elif question_lower == 'help':
                    self.show_help()
                    continue
                elif question_lower == 'clear':
                    clear_screen()
                    continue
                elif question_lower == 'status':
                    self.show_status()
                    continue
                elif question_lower == 'analytics':
                    self.show_database_analytics()
                    continue
                elif question_lower == 'schema':
                    self.show_schema()
                    continue
                elif question_lower == 'history':
                    self.show_recent_history()
                    continue

                print("🔄 Processing your query...")
                result = self.process_question(question)
                print(f"\n{result['response']}\n")
                
                if result['success']:
                    print(f"⏱️  Processing time: {result.get('processing_time', 0):.2f}s")

            except KeyboardInterrupt:
                print("\n👋 Goodbye!")
                break
            except Exception as e:
                print(f"\n❌ Error: {e}")
                logger.error(f"Session error: {e}", exc_info=True)

    def __del__(self):
        """Clean up database connection"""
        if self.connection:
            self.connection.close()

def main():
    """Main function with enhanced startup"""
    print("=== Advanced Database System Report Query Assistant ===")
    print("🚀 Powered by LangChain + Ollama + PyMySQL")
    print("🤖 Natural Language to SQL AI Assistant")
    print(f"📊 Database: {DATABASE_CONFIG['database']}")
    print(f"🏢 Table: {REPORT_CONFIG['table_name']}")
    print()
    
    # Create assistant instance
    assistant = AdvancedDatabaseQueryAssistant()
    
    # Start interactive session
    assistant.start_interactive_session()

if __name__ == "__main__":
    main()import os
import re
import logging
import pymysql
import traceback
from typing import List, Optional, Dict, Any
from datetime import datetime, date, timedelta
import json
import calendar
import sqlparse
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

# --- CONFIGURATION ---
DATABASE_CONFIG = {
    "host": "localhost",
    "user": "root", 
    "password": "root123",
    "database": "EIS_n",
    "charset": "utf8mb4"
}

REPORT_CONFIG = {
    "name": "System Reports Database Query",
    "table_name": "EISHome_compliance",  # Your actual table name
    "supported_queries": ["system info", "performance", "security", "versions", "analytics"]
}

# Configure logging
logging.basicConfig(
    filename=os.path.expanduser("~/.system_report_db_query_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def clean_query_response(raw_response: str) -> str:
    """Clean and extract meaningful response from LLM"""
    response = re.sub(r"```[\w]*\s*(.*?)\s*```", r"\1", raw_response, flags=re.DOTALL)
    return response.strip()

def format_sql_query(query: str) -> str:
    """Format SQL query for better readability"""
    try:
        return sqlparse.format(query, reindent=True, keyword_case='upper')
    except:
        return query

def format_db_results(results: List[Dict], query_type: str = "general", max_items: int = 20) -> str:
    """Format database query results for display with intelligent formatting"""
    if not results:
        return "No data found for your request."

    if len(results) == 1:
        # Single result - show all non-null fields
        result = results[0]
        output = []
        for key, value in result.items():
            if value is not None and str(value).strip():
                # Format field names nicely
                field_name = key.replace('_', ' ').title()
                output.append(f"{field_name}: {value}")
        return "\n".join(output)

    # Multiple results - intelligent formatting based on query type
    output = []
    
    if query_type == "performance":
        # Performance-focused display
        for i, result in enumerate(results[:max_items]):
            server_info = f"{i+1}. {result.get('ip_address', 'Unknown IP')}"
            if result.get('server_role'):
                server_info += f" ({result['server_role']})"
            
            perf_metrics = []
            if result.get('ram'):
                perf_metrics.append(f"RAM: {result['ram']}GB")
            if result.get('cpuCore'):
                perf_metrics.append(f"CPU: {result['cpuCore']} cores")
            if result.get('cpu') is not None:
                perf_metrics.append(f"CPU Usage: {result['cpu']}%")
            if result.get('memory') is not None:
                perf_metrics.append(f"Memory Usage: {result['memory']}%")
            
            if perf_metrics:
                server_info += f" | {' | '.join(perf_metrics)}"
            output.append(server_info)
    
    elif query_type == "security":
        # Security-focused display
        for i, result in enumerate(results[:max_items]):
            server_info = f"{i+1}. {result.get('ip_address', 'Unknown IP')}"
            if result.get('server_role'):
                server_info += f" ({result['server_role']})"
            
            security_info = []
            if result.get('firewall'):
                security_info.append(f"Firewall: {result['firewall']}")
            if result.get('dsAgent'):
                security_info.append(f"DS Agent: {result['dsAgent']}")
            if result.get('eisuserExpi'):
                security_info.append(f"EIS User Expires: {result['eisuserExpi']}")
            
            if security_info:
                server_info += f" | {' | '.join(security_info)}"
            output.append(server_info)
    
    elif query_type == "versions":
        # Version-focused display
        for i, result in enumerate(results[:max_items]):
            server_info = f"{i+1}. {result.get('ip_address', 'Unknown IP')}"
            if result.get('server_role'):
                server_info += f" ({result['server_role']})"
            
            version_info = []
            if result.get('osVersion'):
                version_info.append(f"OS: {result['osVersion']}")
            if result.get('kernelVersion'):
                version_info.append(f"Kernel: {result['kernelVersion']}")
            if result.get('aceVersion'):
                version_info.append(f"ACE: {result['aceVersion']}")
            
            if version_info:
                server_info += f" | {' | '.join(version_info)}"
            output.append(server_info)
    
    else:
        # General display - show key identifying fields
        for i, result in enumerate(results[:max_items]):
            server_info = f"{i+1}. {result.get('ip_address', 'Unknown IP')}"
            if result.get('server_role'):
                server_info += f" ({result['server_role']})"
            if result.get('osVersion'):
                server_info += f" - {result['osVersion']}"
            if result.get('upTime'):
                server_info += f" - Uptime: {result['upTime']}"
            output.append(server_info)

    if len(results) > max_items:
        output.append(f"\n... and {len(results) - max_items} more servers")
    
    return "\n".join(output)

def clear_screen():
    """Clear terminal screen"""
    os.system("cls" if os.name == "nt" else "clear")

class AdvancedDatabaseQueryAssistant:
    def __init__(self):
        self.llm = None
        self.db = None
        self.sql_chain = None
        self.connection = None
        self.initialized = False
        self.chat_history = []
        self.schema_info = {}
        
    def initialize(self):
        """Initialize the advanced database query assistant"""
        try:
            print("🔧 Initializing Advanced Database Query Assistant...")

            # Initialize database connection
            self.connect_to_database()
            
            # Initialize LLM
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.0)
            
            # Initialize LangChain SQL Database
            port_part = f":{DATABASE_CONFIG['port']}" if 'port' in DATABASE_CONFIG and DATABASE_CONFIG['port'] else ""
            db_uri = f"mysql+pymysql://{DATABASE_CONFIG['user']}:{DATABASE_CONFIG['password']}@{DATABASE_CONFIG['host']}{port_part}/{DATABASE_CONFIG['database']}"
            self.db = SQLDatabase.from_uri(db_uri)
            
            # Create SQL query chain
            self.sql_chain = create_sql_query_chain(self.llm, self.db)
            
            # Load schema information
            self.load_schema_info()

            self.initialized = True
            print("✅ Advanced Database Query Assistant initialized successfully!")
            return True
            
        except Exception as e:
            print(f"❌ Initialization failed: {e}")
            logger.error(f"Initialization failed: {e}", exc_info=True)
            return False

    def connect_to_database(self):
        """Establish PyMySQL database connection"""
        try:
            # Create connection config, only include port if specified
            connection_config = {
                "host": DATABASE_CONFIG['host'],
                "user": DATABASE_CONFIG['user'],
                "password": DATABASE_CONFIG['password'],
                "database": DATABASE_CONFIG['database'],
                "charset": DATABASE_CONFIG['charset'],
                "cursorclass": pymysql.cursors.DictCursor
            }
            
            # Only add port if it exists in config
            if 'port' in DATABASE_CONFIG and DATABASE_CONFIG['port']:
                connection_config['port'] = DATABASE_CONFIG['port']
            
            self.connection = pymysql.connect(**connection_config)
            print("✅ PyMySQL database connection established")
            return True
            
        except Exception as e:
            print(f"❌ Database connection failed: {e}")
            logger.error(f"Database connection failed: {e}")
            return False

    def load_schema_info(self):
        """Load comprehensive database schema information"""
        try:
            with self.connection.cursor() as cursor:
                # Get table structure
                cursor.execute(f"DESCRIBE {REPORT_CONFIG['table_name']}")
                columns = cursor.fetchall()
                
                # Get sample data for better context
                cursor.execute(f"SELECT * FROM {REPORT_CONFIG['table_name']} LIMIT 3")
                sample_data = cursor.fetchall()
                
                # Get table statistics
                cursor.execute(f"SELECT COUNT(*) as total_records FROM {REPORT_CONFIG['table_name']}")
                total_records = cursor.fetchone()['total_records']
                
                self.schema_info = {
                    'columns': columns,
                    'column_names': [col['Field'] for col in columns],
                    'column_types': {col['Field']: col['Type'] for col in columns},
                    'sample_data': sample_data,
                    'total_records': total_records,
                    'table_name': REPORT_CONFIG['table_name']
                }
                
                print(f"✅ Loaded schema for table: {REPORT_CONFIG['table_name']}")
                print(f"📊 Found {len(self.schema_info['columns'])} columns, {total_records} records")
                
                return True
                
        except Exception as e:
            print(f"❌ Failed to load schema: {e}")
            logger.error(f"Failed to load schema: {e}")
            return False

    def execute_sql_query(self, query: str) -> List[Dict]:
        """Execute SQL query and return results"""
        try:
            with self.connection.cursor() as cursor:
                cursor.execute(query)
                results = cursor.fetchall()
                return results
                
        except Exception as e:
            logger.error(f"Query execution error: {e}")
            raise e

    def analyze_question_intent(self, question: str) -> Dict:
        """Advanced question analysis to determine intent and extract metadata"""
        question_lower = question.lower()
        
        intent = {
            'type': 'general',
            'complexity': 'simple',
            'requires_aggregation': False,
            'time_based': False,
            'comparison': False,
            'keywords': []
        }
        
        # Detect query complexity
        complex_keywords = ['compare', 'analyze', 'trend', 'average', 'distribution', 'correlation']
        if any(keyword in question_lower for keyword in complex_keywords):
            intent['complexity'] = 'complex'
        
        # Detect aggregation needs
        agg_keywords = ['count', 'sum', 'average', 'max', 'min', 'total', 'group by', 'statistics']
        if any(keyword in question_lower for keyword in agg_keywords):
            intent['requires_aggregation'] = True
        
        # Detect time-based queries
        time_keywords = ['last', 'recent', 'today', 'yesterday', 'week', 'month', 'expired', 'expiring']
        if any(keyword in question_lower for keyword in time_keywords):
            intent['time_based'] = True
        
        # Detect comparison queries
        comp_keywords = ['compare', 'versus', 'vs', 'difference', 'between']
        if any(keyword in question_lower for keyword in comp_keywords):
            intent['comparison'] = True
        
        # Determine primary query type
        if any(word in question_lower for word in ['performance', 'cpu', 'memory', 'ram', 'cores', 'usage']):
            intent['type'] = 'performance'
        elif any(word in question_lower for word in ['security', 'firewall', 'agent', 'expiry', 'expire', 'expired']):
            intent['type'] = 'security'
        elif any(word in question_lower for word in ['version', 'os', 'kernel', 'ace', 'mq', 'update']):
            intent['type'] = 'versions'
        elif any(word in question_lower for word in ['server', 'role', 'infrastructure', 'system']):
            intent['type'] = 'infrastructure'
        elif any(word in question_lower for word in ['count', 'total', 'statistics', 'distribution']):
            intent['type'] = 'analytics'
        
        return intent

    def generate_sql_with_langchain(self, question: str) -> str:
        """Generate SQL query using LangChain SQL chain"""
        try:
            # Add context to the question for better SQL generation
            context_question = f"""
            Based on the system_reports table with the following columns:
            {', '.join(self.schema_info['column_names'])}
            
            User question: {question}
            
            Generate a SQL query to answer this question. The table contains server infrastructure data including IP addresses, server roles, system specifications, versions, and security information.
            """
            
            sql_query = self.sql_chain.invoke({"question": context_question})
            
            # Clean up the generated SQL
            sql_query = sql_query.strip()
            if sql_query.startswith('```sql'):
                sql_query = sql_query[6:]
            if sql_query.endswith('```'):
                sql_query = sql_query[:-3]
            sql_query = sql_query.strip()
            
            logger.info(f"Generated SQL via LangChain: {sql_query}")
            return sql_query
            
        except Exception as e:
            logger.error(f"LangChain SQL generation error: {e}")
            raise e

    def validate_and_enhance_sql(self, sql_query: str, intent: Dict) -> str:
        """Validate and enhance generated SQL query"""
        try:
            # Parse SQL to validate syntax
            parsed = sqlparse.parse(sql_query)[0]
            
            # Add safety limits if not present
            sql_lower = sql_query.lower()
            if 'limit' not in sql_lower and 'count(' not in sql_lower:
                sql_query += " LIMIT 50"  # Default safety limit
            
            # Enhance query based on intent
            if intent['type'] == 'performance' and 'order by' not in sql_lower:
                if 'ram' in sql_lower or 'cpu' in sql_lower:
                    sql_query = sql_query.replace(' LIMIT', ' ORDER BY ram DESC, cpuCore DESC LIMIT')
            
            return sql_query
            
        except Exception as e:
            logger.warning(f"SQL validation warning: {e}")
            return sql_query  # Return original if validation fails

    def process_natural_language_query(self, question: str) -> str:
        """Process natural language query using advanced NL2SQL"""
        try:
            # Analyze question intent
            intent = self.analyze_question_intent(question)
            
            # Generate SQL using LangChain
            sql_query = self.generate_sql_with_langchain(question)
            
            # Validate and enhance SQL
            enhanced_sql = self.validate_and_enhance_sql(sql_query, intent)
            
            # Format SQL for logging
            formatted_sql = format_sql_query(enhanced_sql)
            logger.info(f"Final SQL Query:\n{formatted_sql}")
            
            # Execute query
            results = self.execute_sql_query(enhanced_sql)
            
            # Format results based on intent
            formatted_results = format_db_results(results, intent['type'])
            
            # Add query information to response
            response = f"📊 Query Results:\n{formatted_results}\n\n"
            response += f"🔍 SQL Query Used:\n{formatted_sql}"
            
            return response
            
        except Exception as e:
            logger.error(f"Natural language query processing error: {e}")
            return f"❌ Error processing query: {str(e)}"

    def get_intelligent_insights(self, question: str, results: List[Dict]) -> str:
        """Generate intelligent insights using LLM based on query results"""
        try:
            if not results:
                return "No data available for analysis."
            
            # Prepare context for LLM
            context = {
                'question': question,
                'result_count': len(results),
                'sample_results': results[:3],  # First 3 results for context
                'schema': self.schema_info['column_names']
            }
            
            prompt = f"""
            As a system administrator AI assistant, analyze the following database query results and provide intelligent insights.

            Original Question: {question}
            Number of Results: {len(results)}
            
            Sample Data:
            {json.dumps(results[:3], indent=2, default=str)}
            
            Provide insights including:
            1. Key findings from the data
            2. Any patterns or anomalies noticed
            3. Recommendations for system administration
            4. Potential issues or areas of concern
            5. Summary statistics if relevant
            
            Keep the response practical and actionable for system administrators.
            """
            
            insights = self.llm.invoke(prompt)
            return clean_query_response(insights)
            
        except Exception as e:
            logger.error(f"Insights generation error: {e}")
            return "Unable to generate insights at this time."

    def process_question(self, question: str) -> Dict[str, Any]:
        """Main question processing method"""
        if not self.initialized:
            return {
                "success": False,
                "error": "Assistant not initialized",
                "response": "❌ Assistant not initialized. Please restart."
            }

        try:
            start_time = datetime.now()
            
            # Process the natural language query
            response = self.process_natural_language_query(question)
            
            # For complex queries, add AI insights
            intent = self.analyze_question_intent(question)
            if intent['complexity'] == 'complex':
                try:
                    # Execute a simple version of the query to get results for insights
                    sql_query = self.generate_sql_with_langchain(question)
                    results = self.execute_sql_query(sql_query)
                    insights = self.get_intelligent_insights(question, results)
                    response += f"\n\n🧠 AI Insights:\n{insights}"
                except:
                    pass  # Continue without insights if this fails
            
            processing_time = (datetime.now() - start_time).total_seconds()
            
            self.chat_history.append({
                "user": question, 
                "assistant": response,
                "timestamp": datetime.now().isoformat(),
                "processing_time": processing_time
            })

            return {
                "success": True,
                "query": question,
                "response": response,
                "timestamp": datetime.now().isoformat(),
                "processing_time": processing_time,
                "intent": intent
            }

        except Exception as e:
            logger.error(f"Processing error: {e}")
            return {
                "success": False,
                "error": str(e),
                "response": f"❌ Error processing your request: {e}"
            }

    def get_database_analytics(self) -> Dict:
        """Get comprehensive database analytics"""
        try:
            analytics = {}
            
            with self.connection.cursor() as cursor:
                # Basic counts
                cursor.execute(f"SELECT COUNT(*) as total FROM {REPORT_CONFIG['table_name']}")
                analytics['total_servers'] = cursor.fetchone()['total']
                
                # Server roles distribution
                cursor.execute(f"""
                    SELECT server_role, COUNT(*) as count 
                    FROM {REPORT_CONFIG['table_name']} 
                    WHERE server_role IS NOT NULL 
                    GROUP BY server_role 
                    ORDER BY count DESC
                """)
                analytics['server_roles'] = cursor.fetchall()
                
                # OS distribution
                cursor.execute(f"""
                    SELECT osVersion, COUNT(*) as count 
                    FROM {REPORT_CONFIG['table_name']} 
                    WHERE osVersion IS NOT NULL 
                    GROUP BY osVersion 
                    ORDER BY count DESC 
                    LIMIT 10
                """)
                analytics['os_distribution'] = cursor.fetchall()
                
                # System specifications analytics
                cursor.execute(f"""
                    SELECT 
                        AVG(ram) as avg_ram,
                        MIN(ram) as min_ram,
                        MAX(ram) as max_ram,
                        AVG(cpuCore) as avg_cpu,
                        MIN(cpuCore) as min_cpu,
                        MAX(cpuCore) as max_cpu
                    FROM {REPORT_CONFIG['table_name']}
                    WHERE ram > 0 AND cpuCore > 0
                """)
                analytics['system_specs'] = cursor.fetchone()
                
                # Security status
                cursor.execute(f"""
                    SELECT 
                        SUM(CASE WHEN firewall LIKE '%enabled%' OR firewall LIKE '%active%' THEN 1 ELSE 0 END) as firewall_enabled,
                        SUM(CASE WHEN dsAgent LIKE '%running%' OR dsAgent LIKE '%active%' THEN 1 ELSE 0 END) as ds_agent_active,
                        COUNT(*) as total_checked
                    FROM {REPORT_CONFIG['table_name']}
                    WHERE firewall IS NOT NULL OR dsAgent IS NOT NULL
                """)
                analytics['security_status'] = cursor.fetchone()
                
                return analytics
                
        except Exception as e:
            logger.error(f"Error getting database analytics: {e}")
            return {}

    def show_help(self):
        """Display comprehensive help information"""
        analytics = self.get_database_analytics()
        
        help_text = f"""
📖 ADVANCED DATABASE SYSTEM REPORT QUERY ASSISTANT HELP

📊 DATABASE STATUS:
  - Total Servers: {analytics.get('total_servers', 'Unknown')}
  - Connected via: LangChain + PyMySQL
  - AI Model: Ollama (myllm:latest)

💾 NATURAL LANGUAGE QUERY EXAMPLES:

  📈 Performance Analytics:
  - "Show me the top 10 servers with highest RAM"
  - "List servers with more than 8 CPU cores and 16GB RAM"
  - "Compare CPU and memory usage across different server roles"
  - "Find servers with performance issues"

  🔒 Security Queries:
  - "Which servers have firewall disabled?"
  - "Show expired user accounts across all servers"
  - "List servers without security agents running"
  - "Find servers with security vulnerabilities"

  🔧 Infrastructure Management:
  - "Group servers by their roles and show counts"
  - "Show distribution of operating systems"
  - "List all database servers with their specifications"
  - "Find servers that need OS updates"

  📊 Advanced Analytics:
  - "Calculate average RAM per server role"
  - "Show servers with kernel versions older than X"
  - "Analyze uptime patterns across infrastructure"
  - "Generate server inventory report"

  🔍 Specific Searches:
  - "Find server with IP address 192.168.1.100"
  - "Show all CentOS servers in production"
  - "List web servers with high memory usage"

🚀 ADVANCED FEATURES:
  - Natural Language to SQL conversion
  - Intelligent query optimization
  - Context-aware result formatting
  - AI-powered insights and recommendations
  - Complex multi-table analysis support
  - Real-time database statistics

💡 SYSTEM COMMANDS:
  - 'help' - Show this help
  - 'clear' - Clear screen
  - 'status' - Show system status
  - 'analytics' - Show database analytics
  - 'schema' - Show table structure
  - 'history' - Show recent queries
  - 'exit' - Quit assistant

🎯 QUERY TIPS:
  - Use natural language - the AI will convert to SQL
  - Be specific about what you want to analyze
  - Ask for comparisons, trends, and insights
  - Complex queries are supported and encouraged
        """
        print(help_text)

    def show_status(self):
        """Display detailed system status"""
        print("🔍 ADVANCED SYSTEM STATUS")
        print(f"📅 Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"🤖 AI Model: {'✅ Connected (Ollama)' if self.llm else '❌ Not Connected'}")
        print(f"🗄️  Database: {'✅ Connected (PyMySQL)' if self.connection else '❌ Not Connected'}")
        print(f"🔗 LangChain SQL: {'✅ Initialized' if self.sql_chain else '❌ Not Initialized'}")
        print(f"📝 Chat History: {len(self.chat_history)} queries")
        
        if self.schema_info:
            print(f"📊 Table: {self.schema_info['table_name']}")
            print(f"📋 Columns: {len(self.schema_info['columns'])}")
            print(f"📈 Records: {self.schema_info['total_records']}")

    def show_database_analytics(self):
        """Display comprehensive database analytics"""
        print("📊 DATABASE ANALYTICS DASHBOARD")
        analytics = self.get_database_analytics()
        
        if analytics:
            print(f"\n🖥️  Infrastructure Overview:")
            print(f"  Total Servers: {analytics.get('total_servers', 0)}")
            
            if analytics.get('server_roles'):
                print(f"\n🏷️ Server Roles Distribution:")
                for role_info in analytics['server_roles'][:8]:
                    print(f"  - {role_info['server_role']}: {role_info['count']} servers")
            
            if analytics.get('os_distribution'):
                print(f"\n💿 Operating Systems:")
                for os_info in analytics['os_distribution'][:6]:
                    print(f"  - {os_info['osVersion']}: {os_info['count']} servers")
            
            if analytics.get('system_specs'):
                specs = analytics['system_specs']
                print(f"\n⚡ System Specifications:")
                print(f"  - Average RAM: {specs.get('avg_ram', 0):.1f} GB (Range: {specs.get('min_ram', 0)}-{specs.get('max_ram', 0)} GB)")
                print(f"  - Average CPU Cores: {specs.get('avg_cpu', 0):.1f} (Range: {specs.get('min_cpu', 0)}-{specs.get('max_cpu', 0)})")
            
            if analytics.get('security_status'):
                sec = analytics['security_status']
                print(f"\n🔒 Security Status:")
                if sec.get('total_checked', 0) > 0:
                    fw_pct = (sec.get('firewall_enabled', 0) / sec['total_checked']) * 100
                    agent_pct = (sec.get('ds_agent_active', 0) / sec['total_checked']) * 100
                    print(f"  - Firewall Enabled: {sec.get('firewall_enabled', 0)} servers ({fw_pct:.1f}%)")
                    print(f"  - Security Agents Active: {sec.get('ds_agent_active', 0)} servers ({agent_pct:.1f}%)")
        else:
            print("❌ Could not retrieve database analytics")

    def show_schema(self):
        """Display table schema information"""
        print(f"📋 TABLE SCHEMA: {REPORT_CONFIG['table_name']}")
        print("-" * 80)
        
        if self.schema_info.get('columns'):
            print(f"{'Field':<20} {'Type':<20} {'Null':<8} {'Key':<8} {'Default':<15}")
            print("-" * 80)
            for col in self.schema_info['columns']:
                print(f"{col['Field']:<20} {col['Type']:<20} {col['Null']:<8} {col.get('Key', ''):<8} {str(col.get('Default', '')):<15}")
        
        print(f"\nTotal Columns: {len(self.schema_info.get('columns', []))}")
        print(f"Total Records: {self.schema_info.get('total_records', 'Unknown')}")

    def show_recent_history(self):
        """Show recent query history"""
        print("📝 RECENT QUERY HISTORY")
        print("-" * 60)
        
        recent_queries = self.chat_history[-10:]  # Last 10 queries
        for i, entry in enumerate(recent_queries, 1):
            timestamp = entry.get('timestamp', 'Unknown time')
            processing_time = entry.get('processing_time', 0)
            print(f"{i}. {timestamp}")
            print(f"   Q: {entry['user'][:80]}{'...' if len(entry['user']) > 80 else ''}")
            print(f"   Processing Time: {processing_time:.2f}s")
            print()

    def start_interactive_session(self):
        """Start enhanced interactive query session"""
        if not self.initialize():
            return

        clear_screen()
        print("🚀 Advanced Database System Report Query Assistant Ready")
        analytics = self.get_database_analytics()
        print(f"Connected to database with {analytics.get('total_servers', 0)} servers")
        print("Ask complex questions in natural language - AI will handle the SQL!")
        print("Type 'exit' to quit, 'help' for examples\n")

        while True:
            try:
                question = input("🤖 AI Query: ").strip()
                if not question:
                    continue

                question_lower = question.lower()
                if question_lower in ['exit', 'quit', 'q']:
                    print("👋 Goodbye!")
                    break
                elif question_lower == 'help':
                    self.show_help()
                    continue
                elif question_lower == 'clear':
                    clear_screen()
                    continue
                elif question_lower == 'status':
                    self.show_status()
                    continue
                elif question_lower == 'analytics':
                    self.show_database_analytics()
                    continue
                elif question_lower == 'schema':
                    self.show_schema()
                    continue
                elif question_lower == 'history':
                    self.show_recent_history()
                    continue

                print("🔄 Processing your query...")
                result = self.process_question(question)
                print(f"\n{result['response']}\n")
                
                if result['success']:
                    print(f"⏱️  Processing time: {result.get('processing_time', 0):.2f}s")

            except KeyboardInterrupt:
                print("\n👋 Goodbye!")
                break
            except Exception as e:
                print(f"\n❌ Error: {e}")
                logger.error(f"Session error: {e}", exc_info=True)

    def __del__(self):
        """Clean up database connection"""
        if self.connection:
            self.connection.close()

def main():
    """Main function with enhanced startup"""
    print("=== Advanced Database System Report Query Assistant ===")
    print("🚀 Powered by LangChain + Ollama + PyMySQL")
    print("🤖 Natural Language to SQL AI Assistant")
    print(f"📊 Database: {DATABASE_CONFIG['database']}")
    print(f"🏢 Table: {REPORT_CONFIG['table_name']}")
    print()
    
    # Create assistant instance
    assistant = AdvancedDatabaseQueryAssistant()
    
    # Start interactive session
    assistant.start_interactive_session()

if __name__ == "__main__":
    main()
