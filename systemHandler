import os
import re
import logging
import pymysql
import traceback
from typing import List, Optional, Dict, Any, Tuple
from datetime import datetime, date, timedelta
import json
import calendar
import sqlparse
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

today_date = date.today()

# --- SYSTEM COMPLIANCE CONFIGURATION ---
COMPLIANCE_DB_CONFIG = {
    "name": "System Compliance",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["EISHome_compliance"],
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

def is_simple_identifier(query: str) -> Tuple[bool, Optional[str]]:
    """
    Check if query is just a simple identifier (IP, ID, hostname) without natural language
    Returns (is_simple, sql_query)
    """
    if not query or not isinstance(query, str):
        return False, None

    query = query.strip()

    # Remove common prefixes that don't add meaning
    clean_query = re.sub(r'^(show\s+|get\s+|find\s+)?', '', query, flags=re.IGNORECASE).strip()

    # IP Address pattern (IPv4)
    ip_pattern = r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$'
    ip_match = re.match(ip_pattern, clean_query)
    if ip_match:
        ip = ip_match.group(1)
        return True, f"SELECT * FROM EISHome_compliance WHERE ip_address = '{ip}'"

    # Server ID (just numbers)
    id_pattern = r'^(\d+)$'
    id_match = re.match(id_pattern, clean_query)
    if id_match:
        server_id = id_match.group(1)
        return True, f"SELECT * FROM EISHome_compliance WHERE id = {server_id}"

    # Hostname pattern (letters, numbers, dots, hyphens - no spaces or natural language)
    hostname_pattern = r'^([a-zA-Z0-9\.\-_]+)$'
    hostname_match = re.match(hostname_pattern, clean_query)
    if hostname_match and '.' in clean_query and len(clean_query) > 3:
        hostname = hostname_match.group(1)
        return True, f"SELECT * FROM EISHome_compliance WHERE ip_address LIKE '%{hostname}%' OR server_role LIKE '%{hostname}%'"

    # Single word server role queries (no articles, conjunctions, or question words)
    single_word_pattern = r'^([a-zA-Z]+)$'
    single_word_match = re.match(single_word_pattern, clean_query)
    if single_word_match:
        word = single_word_match.group(1).lower()
        # Exclude question words, articles, and common natural language words
        natural_language_words = {
            'what', 'where', 'when', 'who', 'why', 'how', 'which', 'are', 'is', 'do', 'does', 'can', 'will', 'would',
            'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from',
            'all', 'some', 'any', 'many', 'much', 'few', 'little', 'more', 'most', 'less', 'least',
            'same', 'different', 'similar', 'like', 'unlike', 'than', 'as', 'if', 'unless', 'since', 'because'
        }

        if word not in natural_language_words:
            return True, f"SELECT * FROM EISHome_compliance WHERE server_role LIKE '%{word}%'"

    return False, None

def is_natural_language_question(query: str) -> bool:
    """
    Determine if the query is a natural language question that needs AI processing
    """
    if not query or not isinstance(query, str):
        return False

    query_lower = query.lower().strip()

    # Question patterns
    question_starters = [
        r'^(what|where|when|who|why|how|which)\b',
        r'^(are|is|do|does|can|will|would|should|could)\b',
        r'^(show\s+me|tell\s+me|list\s+all|give\s+me)\b',
        r'^(find\s+all|get\s+all|display\s+all)\b'
    ]

    # Analytical phrases
    analytical_phrases = [
        'same', 'different', 'compare', 'analysis', 'summary', 'overview',
        'all have', 'do all', 'are all', 'which ones', 'how many',
        'percentage', 'compliance', 'status', 'breakdown', 'distribution',
        'cpu usage', 'memory usage', 'disk usage', 'performance', 'utilization'
    ]

    # Complex query indicators
    complex_indicators = [
        'and', 'or', 'but', 'with', 'without', 'that have', 'that are',
        'more than', 'less than', 'greater than', 'higher than', 'lower than',
        'between', 'during', 'since', 'before', 'after'
    ]

    # Check for question patterns
    for pattern in question_starters:
        if re.match(pattern, query_lower):
            return True

    # Check for analytical phrases
    if any(phrase in query_lower for phrase in analytical_phrases):
        return True

    # Check for complex indicators
    if any(indicator in query_lower for indicator in complex_indicators):
        return True

    # If query has multiple words and contains common question/analysis words
    words = query_lower.split()
    if len(words) > 3:  # More than 3 words suggests natural language
        return True

    return False

def generate_fast_sql_patterns():
    """Generate fast SQL patterns for common simple queries"""
    patterns = {
        # Count queries
        r'^count\s*$': "SELECT COUNT(*) as total_servers FROM EISHome_compliance",
        r'^count\s+servers?\s*$': "SELECT COUNT(*) as total_servers FROM EISHome_compliance",
        r'^total\s*$': "SELECT COUNT(*) as total_servers FROM EISHome_compliance",
        r'^total\s+servers?\s*$': "SELECT COUNT(*) as total_servers FROM EISHome_compliance",

        # List all queries
        r'^all\s*$': "SELECT * FROM EISHome_compliance",
        r'^all\s+servers?\s*$': "SELECT * FROM EISHome_compliance",
        r'^servers?\s*$': "SELECT * FROM EISHome_compliance",
        r'^list\s*$': "SELECT * FROM EISHome_compliance",

        # Status queries (single word + status)
        r'^firewall\s*$': "SELECT * FROM EISHome_compliance WHERE firewall IS NOT NULL",
        r'^dsagent\s*$': "SELECT * FROM EISHome_compliance WHERE dsAgent IS NOT NULL",
        r'^splunk\s*$': "SELECT * FROM EISHome_compliance WHERE splunk IS NOT NULL",

        # OS queries
        r'^centos\s*$': "SELECT * FROM EISHome_compliance WHERE osVersion LIKE '%CentOS%'",
        r'^linux\s*$': "SELECT * FROM EISHome_compliance WHERE osVersion LIKE '%Linux%'",
        r'^windows\s*$': "SELECT * FROM EISHome_compliance WHERE osVersion LIKE '%Windows%'",

        # Role-based queries (single words)
        r'^web\s*$': "SELECT * FROM EISHome_compliance WHERE server_role LIKE '%web%'",
        r'^database\s*$': "SELECT * FROM EISHome_compliance WHERE server_role LIKE '%database%'",
        r'^db\s*$': "SELECT * FROM EISHome_compliance WHERE server_role LIKE '%db%'",
        r'^app\s*$': "SELECT * FROM EISHome_compliance WHERE server_role LIKE '%app%'",
        r'^application\s*$': "SELECT * FROM EISHome_compliance WHERE server_role LIKE '%application%'",

        # Performance queries
        r'^cpu\s*$': "SELECT id, ip_address, server_role, cpu FROM EISHome_compliance WHERE cpu IS NOT NULL ORDER BY cpu DESC",
        r'^memory\s*$': "SELECT id, ip_address, server_role, memory FROM EISHome_compliance WHERE memory IS NOT NULL ORDER BY memory DESC",
        r'^ram\s*$': "SELECT id, ip_address, server_role, ram FROM EISHome_compliance WHERE ram IS NOT NULL ORDER BY ram DESC"
    }
    return patterns

def try_fast_query(query: str) -> Optional[str]:
    """Try to match simple queries to fast SQL patterns"""
    if not query or not isinstance(query, str):
        return None

    query_clean = query.lower().strip()
    patterns = generate_fast_sql_patterns()

    for pattern, sql in patterns.items():
        if re.match(pattern, query_clean):
            return sql

    return None

def get_sql_generation_prompt():
    """Generate comprehensive SQL prompt for complex queries"""
    return f"""You are an expert SQL generator for EISHome_compliance table.

TABLE SCHEMA:
- id (BIGINT): Server ID (Primary Key, auto_increment)
- ip_address (VARCHAR(20)): Server IP address
- last_update (VARCHAR(50)): Last database update time
- upTime (VARCHAR(50)): Server uptime
- server_role (VARCHAR(50)): Server role (PR or DR)
- ram (INT): RAM of server in GB
- cpuCore (INT): Number of CPU cores
- osVersion (VARCHAR(100)): Operating system version
- kernelUdate (VARCHAR(100)): Kernel update info
- aceVersion (VARCHAR(20)): IBM ACE version
- mqVersion (VARCHAR(30)): IBM MQ version
- firewall (VARCHAR(50)): Firewall status (active/inactive)
- rpmCount (INT): RPM package count
- dsAgent (VARCHAR(50)): Deep Security Agent status
- splunk (VARCHAR(50)): Splunk agent status
- ragent (VARCHAR(50)): R agent status
- eisuserExpi (VARCHAR(30)): EIS user expiry date
- rootExpi (VARCHAR(30)): Root user expiry date
- socvaExpi (VARCHAR(30)): SOCVA expiry date
- addmitamExpi (VARCHAR(50)): ADDMITAM expiry date
- systemTime (VARCHAR(50)): System time
- fileSystem (VARCHAR(20)): File system info
- kernelVersion (VARCHAR(100)): Kernel version
- cpu (INT): CPU usage percentage (can be NULL)
- mem_cp_update (VARCHAR(50)): Memory/CPU update info (can be NULL)
- memory (INT): Memory usage percentage (can be NULL)

IMPORTANT FIELD MAPPINGS:
- For CPU usage queries: Use 'cpu' field (percentage)
- For Memory usage queries: Use 'memory' field (percentage) 
- For RAM capacity queries: Use 'ram' field (GB)
- For CPU cores: Use 'cpuCore' field
- For kernel info: Use 'kernelVersion' field (NOT 'kernelUdate')

RULES:
1. Generate ONLY valid SELECT statements
2. Use exact table name: EISHome_compliance
3. For text searches use LIKE with %wildcards%
4. For numbers use =, >, <, >=, <= operators
5. Return ONLY the SQL query, no explanations
6. Use proper WHERE clauses for filtering
7. For "all servers" use SELECT * FROM EISHome_compliance
8. For performance metrics, handle NULL values appropriately
9. For CPU/memory usage comparisons, use numeric operators
10. Always include relevant fields in SELECT for performance queries

EXAMPLES:
- "What is CPU usage of server 10.1.1.1?" → SELECT id, ip_address, server_role, cpu FROM EISHome_compliance WHERE ip_address = '10.1.1.1'
- "Servers with high CPU usage" → SELECT * FROM EISHome_compliance WHERE cpu > 80
- "Memory usage of all servers" → SELECT id, ip_address, server_role, memory FROM EISHome_compliance WHERE memory IS NOT NULL ORDER BY memory DESC

QUESTION: {{question}}

SQL:"""

def clean_and_fix_sql(raw_sql: str) -> str:
    """Clean and fix SQL generated by AI with proper error handling"""
    # Ensure we have a string to work with
    if not raw_sql or not isinstance(raw_sql, str):
        return "ERROR: Invalid SQL input"

    print(f"DEBUG - Raw SQL: {repr(raw_sql)}")

    # Handle refusal responses
    if any(phrase in raw_sql.lower() for phrase in ["i cannot", "i can't", "sorry", "unable"]):
        return "ERROR: AI refused to generate SQL"

    # Extract SQL from various formats
    sql = raw_sql.strip()

    # Remove code block markers
    sql = re.sub(r'```(?:sql)?\s*(.*?)\s*```', r'\1', sql, flags=re.DOTALL | re.IGNORECASE)

    # Remove common prefixes
    sql = re.sub(r'^(sql:|query:|here is|here\'s)?\s*:?\s*', '', sql, flags=re.IGNORECASE)

    # Extract the SELECT statement
    select_match = re.search(r'(SELECT\s+.*?)(?:;|\n\s*$|$)', sql, re.IGNORECASE | re.DOTALL)
    if select_match:
        sql = select_match.group(1).strip()

    # Ensure we still have a valid string after processing
    if not sql or not isinstance(sql, str):
        return "ERROR: SQL processing failed"

    # Fix common issues
    sql = re.sub(r'\s+', ' ', sql)  # Normalize whitespace
    sql = re.sub(r'from\s+eishome_compliance', 'FROM EISHome_compliance', sql, flags=re.IGNORECASE)

    # Fix text field searches - only if sql is a valid string
    text_fields = ['ip_address', 'server_role', 'osVersion', 'aceVersion', 'mqVersion',
                   'firewall', 'dsAgent', 'splunk', 'kernelVersion', 'last_update', 
                   'upTime', 'kernelUdate', 'ragent', 'eisuserExpi', 'rootExpi', 
                   'socvaExpi', 'addmitamExpi', 'systemTime', 'fileSystem', 'mem_cp_update']

    for field in text_fields:
        try:
            # Check if it's not an IP address exact match or numeric comparison
            if field != 'ip_address' or not re.search(r'\b(?:\d{1,3}\.){3}\d{1,3}\b', sql):
                pattern = f"({field})\\s*=\\s*'([^']*)'"
                replacement = f"\\1 LIKE '%\\2%'"
                sql = re.sub(pattern, replacement, sql, flags=re.IGNORECASE)
        except Exception as e:
            print(f"DEBUG - Error fixing field {field}: {e}")
            continue

    # Ensure proper semicolon
    if not sql.endswith(';'):
        sql += ';'

    print(f"DEBUG - Cleaned SQL: {sql}")
    return sql

def validate_sql(sql: str) -> Tuple[str, bool]:
    """Validate and ensure SQL is safe"""
    if not sql or not isinstance(sql, str):
        return sql, False

    if not sql.upper().strip().startswith('SELECT'):
        return sql, False

    # Check for dangerous operations
    dangerous_ops = ['INSERT', 'UPDATE', 'DELETE', 'DROP', 'ALTER', 'CREATE', 'TRUNCATE']
    sql_upper = sql.upper()
    if any(op in sql_upper for op in dangerous_ops):
        return sql, False

    # Basic syntax validation
    try:
        parsed = sqlparse.parse(sql)
        if not parsed:
            return sql, False
    except:
        return sql, False

    return sql, True

def analyze_results_with_ai(question: str, results: List[Dict], llm) -> str:
    """Use AI to analyze results and provide natural language insights"""
    if not results:
        return "No matching servers found for your query."

    # Prepare summary data
    total_count = len(results)

    # Get unique values for key analysis fields - updated field list
    analysis_fields = ['server_role', 'osVersion', 'kernelVersion', 'firewall', 'dsAgent', 
                      'aceVersion', 'mqVersion', 'splunk', 'cpu', 'memory', 'ram', 'cpuCore']
    field_analysis = {}

    for field in analysis_fields:
        if field in results[0]:
            values = [str(r.get(field, 'NULL')) for r in results if r.get(field) is not None]
            if values:  # Only analyze if we have non-null values
                unique_values = list(set(values))
                field_analysis[field] = {
                    'unique_count': len(unique_values),
                    'values': unique_values[:10],  # Limit for prompt size
                    'total_records': len(values)
                }

                # Add statistics for numeric fields
                if field in ['cpu', 'memory', 'ram', 'cpuCore', 'rpmCount']:
                    try:
                        numeric_values = [float(v) for v in values if v != 'NULL' and v.replace('.','').isdigit()]
                        if numeric_values:
                            field_analysis[field]['min'] = min(numeric_values)
                            field_analysis[field]['max'] = max(numeric_values)
                            field_analysis[field]['avg'] = sum(numeric_values) / len(numeric_values)
                    except:
                        pass

    # Create focused analysis prompt
    prompt = f"""Analyze this system compliance data to answer the user's question.

USER QUESTION: "{question}"

DATA SUMMARY:
- Total servers: {total_count}
- Field Analysis: {json.dumps(field_analysis, indent=2)}

Please provide a direct, clear answer to the user's question. Focus on:
1. Direct yes/no answer if applicable
2. Specific differences or issues found
3. Key statistics or patterns
4. Actionable insights
5. For performance queries (CPU, memory), highlight high/low values and averages

Keep response concise and specific to the question asked."""

    try:
        analysis = llm.invoke(prompt)
        return analysis.strip()
    except Exception as e:
        return f"Analysis completed but couldn't generate detailed insights: {str(e)}"

def format_simple_results(results: List[Dict], query: str) -> str:
    """Format results for simple queries (non-analytical)"""
    if not results:
        return f"No servers found matching '{query}'"

    if len(results) == 1:
        # Single server - show detailed info
        server = results[0]
        output = f"🖥️ Server Details:\n"

        # Updated key fields mapping
        key_fields = {
            'id': '🆔 ID',
            'ip_address': '🌐 IP Address',
            'server_role': '🏷️ Role',
            'osVersion': '💿 OS Version',
            'kernelVersion': '🔧 Kernel Version',
            'ram': '🧠 RAM',
            'cpuCore': '⚡ CPU Cores',
            'cpu': '🖥️ CPU Usage',
            'memory': '💾 Memory Usage',
            'firewall': '🔥 Firewall',
            'dsAgent': '🛡️ Deep Security',
            'splunk': '📊 Splunk',
            'aceVersion': '🔧 ACE Version',
            'mqVersion': '📦 MQ Version',
            'upTime': '⏰ Uptime',
            'last_update': '🔄 Last Update'
        }

        for field, label in key_fields.items():
            if field in server and server[field] is not None:
                value = server[field]
                if field == 'ram':
                    value = f"{value} GB"
                elif field in ['cpu', 'memory'] and isinstance(value, (int, float)):
                    value = f"{value}%"
                elif field == 'cpuCore':
                    value = f"{value} cores"
                output += f"{label}: {value}\n"

        return output.strip()

    elif len(results) <= 10:
        # Small result set - show table
        return format_table(results)

    else:
        # Large result set - show summary + sample
        output = f"Found {len(results)} servers:\n\n"

        # Add role summary if available
        if 'server_role' in results[0]:
            roles = {}
            for server in results:
                role = server.get('server_role', 'Unknown')
                roles[role] = roles.get(role, 0) + 1

            output += "🏷️ Server Roles:\n"
            for role, count in sorted(roles.items()):
                output += f"  • {role}: {count} servers\n"
            output += "\n"

        # Add performance summary if CPU or memory data is available
        cpu_values = [s.get('cpu') for s in results if s.get('cpu') is not None]
        memory_values = [s.get('memory') for s in results if s.get('memory') is not None]
        
        if cpu_values:
            avg_cpu = sum(cpu_values) / len(cpu_values)
            output += f"📊 CPU Usage: Avg {avg_cpu:.1f}%, Min {min(cpu_values)}%, Max {max(cpu_values)}%\n"
        
        if memory_values:
            avg_memory = sum(memory_values) / len(memory_values)
            output += f"💾 Memory Usage: Avg {avg_memory:.1f}%, Min {min(memory_values)}%, Max {max(memory_values)}%\n"
        
        if cpu_values or memory_values:
            output += "\n"

        # Show sample
        output += f"📋 Sample (first 5 servers):\n"
        output += format_table(results[:5])
        output += f"\n... and {len(results) - 5} more servers"

        return output

def format_table(results: List[Dict]) -> str:
    """Format results as a clean table"""
    if not results:
        return "No data to display"

    # Select important columns - updated priority
    priority_cols = ['id', 'ip_address', 'server_role', 'osVersion', 'ram', 'cpuCore', 
                    'cpu', 'memory', 'firewall', 'dsAgent', 'kernelVersion']
    available_cols = [col for col in priority_cols if col in results[0]]

    if not available_cols:
        available_cols = list(results[0].keys())[:8]  # First 8 columns

    # Calculate column widths
    col_widths = {}
    for col in available_cols:
        max_width = len(str(col))
        for row in results:
            value = str(row.get(col, 'NULL'))
            max_width = max(max_width, len(value))
        col_widths[col] = min(max_width, 25)  # Max 25 chars

    # Build table
    output = []

    # Header
    header = " | ".join(col.ljust(col_widths[col]) for col in available_cols)
    separator = "-+-".join("-" * col_widths[col] for col in available_cols)
    output.append(header)
    output.append(separator)

    # Rows
    for row in results:
        formatted_row = " | ".join(
            str(row.get(col, 'NULL')).ljust(col_widths[col])[:col_widths[col]]
            for col in available_cols
        )
        output.append(formatted_row)

    return "\n".join(output)

class SystemComplianceAssistant:
    def __init__(self):
        self.llm = None
        self.db_connection = None
        self.db_chain = None
        self.initialized = False

    def initialize(self):
        """Initialize database connection and AI components"""
        try:
            db_config = COMPLIANCE_DB_CONFIG['db_config']

            # Direct database connection
            self.db_connection = pymysql.connect(
                host=db_config['host'],
                user=db_config['user'],
                password=db_config['password'],
                database=db_config['database'],
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor,
                autocommit=True
            )

            # AI components (only initialize when needed)
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.2)

            # Database chain for complex queries
            uri = f"mysql+pymysql://{db_config['user']}:{db_config['password']}@{db_config['host']}/{db_config['database']}"
            db_for_chain = SQLDatabase.from_uri(uri, include_tables=["EISHome_compliance"])
            self.db_chain = create_sql_query_chain(self.llm, db_for_chain)

            self.initialized = True
            return True

        except Exception as e:
            print(f"❌ Initialization failed: {e}")
            return False

    def execute_query(self, sql: str) -> List[Dict]:
        """Execute SQL query safely"""
        try:
            with self.db_connection.cursor() as cursor:
                cursor.execute(sql)
                return cursor.fetchall()
        except Exception as e:
            print(f"❌ Query execution failed: {e}")
            raise

    def process_query(self, query: str) -> str:
        """Main query processing logic"""
        if not self.initialized:
            if not self.initialize():
                return "❌ System not available"

        start_time = datetime.now()

        # Ensure query is valid
        if not query or not isinstance(query, str):
            return "❌ Invalid query provided"

        query = query.strip()

        print(f"🔍 Processing: '{query}'")

        try:
            # Step 1: Check for simple identifiers (IP, ID, hostname)
            is_simple, direct_sql = is_simple_identifier(query)
            if is_simple:
                print(f"⚡ Fast path - Direct SQL: {direct_sql}")
                results = self.execute_query(direct_sql)
                elapsed = (datetime.now() - start_time).total_seconds()
                print(f"✅ Completed in {elapsed:.2f}s")
                return format_simple_results(results, query)

            # Step 2: Check for simple pattern matches
            fast_sql = try_fast_query(query)
            if fast_sql and not is_natural_language_question(query):
                print(f"⚡ Fast pattern match: {fast_sql}")
                results = self.execute_query(fast_sql)
                elapsed = (datetime.now() - start_time).total_seconds()
                print(f"✅ Completed in {elapsed:.2f}s")
                return format_simple_results(results, query)

            # Step 3: Natural language processing with AI
            if is_natural_language_question(query):
                print("🧠 Using AI for natural language query")

                # Generate SQL with AI
                prompt = get_sql_generation_prompt().format(question=query)

                try:
                    raw_sql = self.db_chain.invoke({"question": query})
                except Exception as e:
                    print(f"❌ AI SQL generation failed: {e}")
                    return f"❌ Could not generate SQL for: '{query}'"

                # Clean and validate SQL
                sql = clean_and_fix_sql(raw_sql)

                if sql.startswith("ERROR:"):
                    return sql

                sql, is_valid = validate_sql(sql)

                if not is_valid:
                    return f"❌ Could not generate valid SQL for: '{query}'"

                print(f"🔧 Generated SQL: {sql}")

                # Execute query
                results = self.execute_query(sql)

                # Analyze results with AI
                analysis = analyze_results_with_ai(query, results, self.llm)

                elapsed = (datetime.now() - start_time).total_seconds()
                print(f"✅ AI analysis completed in {elapsed:.2f}s")

                # Combine analysis with data
                if results and len(results) <= 10:
                    return f"{analysis}\n\n📊 Supporting Data:\n{format_table(results)}"
                elif results and len(results) > 10:
                    return f"{analysis}\n\n📊 Sample Data:\n{format_table(results[:5])}\n... ({len(results)} total servers)"
                else:
                    return analysis

            # Step 4: Fallback - treat as simple query
            print("🔄 Fallback to simple processing")
            # Try to find any matches in server roles or IP addresses
            fallback_sql = f"""
            SELECT * FROM EISHome_compliance
            WHERE ip_address LIKE '%{query}%'
               OR server_role LIKE '%{query}%'
               OR CAST(id AS CHAR) LIKE '%{query}%'
               OR osVersion LIKE '%{query}%'
            """
            results = self.execute_query(fallback_sql)
            elapsed = (datetime.now() - start_time).total_seconds()
            print(f"✅ Fallback completed in {elapsed:.2f}s")

            if results:
                return format_simple_results(results, query)
            else:
                return f"No servers found matching '{query}'. Try being more specific (e.g., IP address, server role, or ask a complete question like 'What is CPU usage of server X?')."

        except Exception as e:
            elapsed = (datetime.now() - start_time).total_seconds()
            error_msg = f"❌ Error after {elapsed:.2f}s: {str(e)}"
            print(error_msg)
            traceback.print_exc()  # Add full traceback for debugging
            return error_msg

    def cleanup(self):
        """Clean up resources"""
        try:
            if self.db_connection:
                self.db_connection.close()
        except:
            pass

# Setup logging
logging.basicConfig(level=logging.ERROR)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    """Check for dangerous patterns"""
    if not text or not isinstance(text, str):
        return False
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def ComplianceMain(query):
    """Main entry point"""
    if not query or not isinstance(query, str):
        return "❌ Invalid query provided"

    if is_dangerous(query):
        return "❌ Query blocked for security reasons"

    assistant = SystemComplianceAssistant()
    try:
        return assistant.process_query(query)
    finally:
        assistant.cleanup()

# Interactive mode
if __name__ == "__main__":
    print("🚀 Smart System Compliance Assistant - Updated with Full Schema")
    print("=" * 60)
    print("💡 Usage Examples:")
    print("  Simple Queries:")
    print("    '10.188.24.100' - Get server by IP")
    print("    '123' - Get server by ID") 
    print("    'web' - Get web servers")
    print("    'cpu' - Show CPU usage for all servers")
    print("    'memory' - Show memory usage for all servers")
    print("    'count' - Count total servers")
    print("")
    print("  Complex Questions:")
    print("    'What is CPU usage of server 10.1.1.1?'")
    print("    'Which servers have high memory usage?'")
    print("    'Do all servers have same kernel version?'")
    print("    'Show servers with firewall disabled'")
    print("    'What are the ACE versions across servers?'")
    print("    'Which servers need user password expiry updates?'")
    print("")
    print("  Available Fields:")
    print("    Performance: cpu (%), memory (%), ram (GB), cpuCore")
    print("    System: osVersion, kernelVersion, upTime, systemTime")
    print("    Software: aceVersion, mqVersion, firewall, dsAgent, splunk")
    print("    Security: eisuserExpi, rootExpi, socvaExpi, addmitamExpi")
    print("    Info: server_role, ip_address, last_update")
    print("\nType 'exit' to quit.\n")

    while True:
        try:
            user_query = input("🔍 Query: ").strip()

            if not user_query:
                continue

            if user_query.lower() in ['exit', 'quit', 'q']:
                print("👋 Goodbye!")
                break

            result = ComplianceMain(user_query)
            print(f"\n{result}\n")
            print("-" * 60)

        except KeyboardInterrupt:
            print("\n👋 Goodbye!")
            break
        except Exception as e:
            print(f"\n❌ Error: {e}\n")
            traceback.print_exc()
