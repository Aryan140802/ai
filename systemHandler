import os
import re
import logging
import pymysql
import traceback
from typing import List, Optional, Dict, Any, Tuple
from datetime import datetime, date, timedelta
import json
import calendar
import sqlparse
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

today_date = date.today()

# --- SYSTEM COMPLIANCE CONFIGURATION ---
COMPLIANCE_DB_CONFIG = {
    "name": "System Compliance",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["EISHome_compliance"],
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

# Fast query patterns - these don't need AI
FAST_QUERY_PATTERNS = {
    # Simple server lookups
    r"server\s+(\d+)": "SELECT * FROM EISHome_compliance WHERE id = {0}",
    r"server\s+with\s+id\s+(\d+)": "SELECT * FROM EISHome_compliance WHERE id = {0}",
    r"ip\s+([0-9.]+)": "SELECT * FROM EISHome_compliance WHERE ip_address = '{0}'",
    r"server\s+([0-9.]+)": "SELECT * FROM EISHome_compliance WHERE ip_address = '{0}'",
    
    # Count queries
    r"^(?:how\s+many|count|total)\s+servers?$": "SELECT COUNT(*) as total_servers FROM EISHome_compliance",
    r"^(?:how\s+many|count|total)\s+(.+?)\s+servers?$": "SELECT COUNT(*) as total FROM EISHome_compliance WHERE server_role LIKE '%{0}%'",
    
    # Simple status queries
    r"^(?:show\s+)?all\s+servers?$": "SELECT * FROM EISHome_compliance",
    r"^(?:list\s+)?all\s+servers?$": "SELECT * FROM EISHome_compliance",
    r"^(?:show\s+|list\s+)?(.+?)\s+servers?$": "SELECT * FROM EISHome_compliance WHERE server_role LIKE '%{0}%'",
    
    # Security status
    r"firewall\s+(?:disabled|inactive|off)": "SELECT * FROM EISHome_compliance WHERE firewall NOT LIKE '%active%' AND firewall NOT LIKE '%enabled%'",
    r"firewall\s+(?:enabled|active|on)": "SELECT * FROM EISHome_compliance WHERE firewall LIKE '%active%' OR firewall LIKE '%enabled%'",
    
    # Performance queries
    r"high\s+cpu": "SELECT * FROM EISHome_compliance WHERE cpu > 80",
    r"high\s+memory": "SELECT * FROM EISHome_compliance WHERE memory > 90",
    r"low\s+(?:ram|memory)": "SELECT * FROM EISHome_compliance WHERE ram < 8",
}

# Queries that need natural language analysis
ANALYTICAL_KEYWORDS = [
    "same", "different", "compare", "analyze", "summary", "overview",
    "do all", "are all", "which ones", "what percentage", "how many have",
    "group by", "breakdown", "distribution", "average", "median",
    "compliance status", "security summary", "performance summary"
]

def is_analytical_query(question: str) -> bool:
    """Check if query needs natural language analysis"""
    question_lower = question.lower()
    return any(keyword in question_lower for keyword in ANALYTICAL_KEYWORDS)

def try_fast_query(question: str) -> Optional[str]:
    """Try to match question to fast SQL patterns"""
    question_clean = re.sub(r'[^\w\s.]', '', question.lower()).strip()
    
    for pattern, sql_template in FAST_QUERY_PATTERNS.items():
        match = re.search(pattern, question_clean, re.IGNORECASE)
        if match:
            try:
                if match.groups():
                    return sql_template.format(*match.groups())
                else:
                    return sql_template
            except:
                continue
    return None

def get_comprehensive_date_context():
    """Generate comprehensive date context for LLM understanding"""
    current_date = date.today()
    current_year = current_date.year
    current_month = current_date.month

    month_names = {
        'january': 1, 'jan': 1, 'february': 2, 'feb': 2, 'march': 3, 'mar': 3,
        'april': 4, 'apr': 4, 'may': 5, 'june': 6, 'jun': 6,
        'july': 7, 'jul': 7, 'august': 8, 'aug': 8, 'september': 9, 'sep': 9,
        'october': 10, 'oct': 10, 'november': 11, 'nov': 11, 'december': 12, 'dec': 12
    }

    month_numbers = {v: k.title() for k, v in month_names.items() if len(k) > 3}

    return {
        'current_date': current_date.strftime('%Y-%m-%d'),
        'current_year': current_year,
        'current_month': current_month,
        'current_month_name': month_numbers[current_month],
        'next_year': current_year + 1,
        'prev_year': current_year - 1,
        'month_names': month_names,
        'month_numbers': month_numbers,
        'years_range': list(range(current_year - 5, current_year + 10))
    }

def analyze_results_with_ai(question: str, results: List[Dict], llm) -> str:
    """Use AI to analyze results and provide natural language insights"""
    if not results:
        return "No data found to analyze."
    
    # Prepare data summary for AI
    total_count = len(results)
    sample_data = results[:5] if len(results) > 5 else results
    
    # Extract key fields for analysis
    analysis_data = {
        'total_servers': total_count,
        'sample_records': sample_data,
        'unique_values': {}
    }
    
    # Get unique values for key fields
    key_fields = ['server_role', 'osVersion', 'kernelVersion', 'firewall', 'dsAgent', 'aceVersion']
    for field in key_fields:
        if field in results[0]:
            unique_vals = list(set(str(r.get(field, 'NULL')) for r in results))
            analysis_data['unique_values'][field] = unique_vals[:10]  # Limit to 10 unique values
    
    analysis_prompt = f"""
You are analyzing system compliance data. The user asked: "{question}"

Data Summary:
- Total servers found: {total_count}
- Unique values in key fields: {json.dumps(analysis_data['unique_values'], indent=2)}
- Sample records: {json.dumps(sample_data, indent=2)}

Please provide a natural language analysis that directly answers the user's question. Be specific about:
1. Direct answer (Yes/No if applicable)
2. Key findings
3. Specific details about differences or compliance issues
4. Actionable insights

Keep the response concise but informative. Focus on answering the specific question asked.
"""

    try:
        response = llm.invoke(analysis_prompt)
        return response.strip()
    except Exception as e:
        return f"Analysis completed but couldn't generate insights: {str(e)}"

def clean_and_fix_sql(raw_sql: str) -> str:
    """Enhanced SQL cleaning with better error handling"""
    print(f"DEBUG - Raw SQL input: {repr(raw_sql)}")
    raw_sql = sqlparse.format(raw_sql, strip_comments=True).strip()
    
    # Handle common LLM response patterns
    if "i cannot" in raw_sql.lower() or "i can't" in raw_sql.lower():
        print("DEBUG - LLM refused to generate SQL")
        return "ERROR: LLM refused to generate SQL"

    # Extract from code blocks
    code_block_match = re.search(r"```(?:sql)?\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
    if code_block_match:
        sql = code_block_match.group(1).strip()
    else:
        sql = raw_sql.strip()

    # Remove common prefixes/suffixes
    sql = re.sub(r'^(here is|here\'s|sql query|query|the query is)?\s*:?\s*', '', sql, flags=re.IGNORECASE)
    sql = re.sub(r'\s*;?\s*$', '', sql)

    # Find SELECT statement
    select_match = re.search(r'(SELECT\s+.*?)(?:\n\s*$|$)', sql, re.IGNORECASE | re.DOTALL)
    if select_match:
        sql = select_match.group(1).strip()

    # Fix text field searches
    text_fields = ['ip_address', 'server_role', 'osVersion', 'aceVersion', 'mqVersion',
                   'firewall', 'dsAgent', 'splunk', 'ragent', 'kernelVersion', 'fileSystem']

    for field in text_fields:
        if field != 'ip_address' or not re.search(r'\b(?:\d{1,3}\.){3}\d{1,3}\b', sql):
            sql = re.sub(f"({field})\\s*=\\s*'([^']*)'", f"\\1 LIKE '%\\2%'", sql, flags=re.IGNORECASE)

    sql = sql.strip()
    print(f"DEBUG - Final cleaned SQL: {sql}")
    return sql

def validate_and_fix_sql(sql: str) -> tuple[str, bool]:
    """Validate SQL and attempt to fix common issues"""
    if not sql.upper().strip().startswith('SELECT'):
        return sql, False

    dangerous_ops = ['insert', 'update', 'delete', 'drop', 'alter', 'create', 'truncate']
    if any(op in sql.lower() for op in dangerous_ops):
        return sql, False

    fixed_sql = sql
    if 'from eishome_compliance' in fixed_sql.lower():
        fixed_sql = re.sub(r'from\s+eishome_compliance', 'FROM EISHome_compliance', fixed_sql, flags=re.IGNORECASE)

    if not fixed_sql.endswith(';'):
        fixed_sql += ';'
    
    return fixed_sql, True

def format_query_results_natural(result: List[Dict], question: str) -> str:
    """Enhanced result formatting for system compliance data"""
    if not result:
        return "I couldn't find any system compliance records matching your criteria."

    # Handle single value results (like COUNT)
    if len(result) == 1 and len(result[0]) == 1:
        value = list(result[0].values())[0]
        if "count" in question.lower():
            return f"There are {value} servers matching your criteria."
        else:
            return f"The result is: {value}"

    # Handle single record
    if len(result) == 1:
        record = result[0]
        response = f"I found 1 server:\n\n"

        key_fields = ['id', 'ip_address', 'server_role', 'osVersion', 'upTime', 'ram', 'cpuCore',
                     'firewall', 'dsAgent', 'splunk', 'cpu', 'memory', 'kernelVersion']

        icons = {
            'id': 'ğŸ†”', 'ip_address': 'ğŸŒ', 'server_role': 'ğŸ·ï¸', 'osVersion': 'ğŸ’¿',
            'upTime': 'â±ï¸', 'ram': 'ğŸ§ ', 'cpuCore': 'âš¡', 'firewall': 'ğŸ”¥',
            'dsAgent': 'ğŸ›¡ï¸', 'splunk': 'ğŸ“Š', 'cpu': 'ğŸ–¥ï¸', 'memory': 'ğŸ’¾',
            'kernelVersion': 'ğŸ”§'
        }

        for field in key_fields:
            if field in record and record[field] is not None:
                icon = icons.get(field, 'â€¢')
                field_name = field.replace('_', ' ').title()
                value = record[field]

                if field == 'ram':
                    value = f"{value} GB"
                elif field == 'cpu' and isinstance(value, int):
                    value = f"{value}%"
                elif field == 'memory' and isinstance(value, int):
                    value = f"{value}%"

                response += f"{icon} {field_name}: {value}\n"

        return response.strip()

    # Handle multiple records - show summary
    response = f"I found {len(result)} servers matching your criteria:\n\n"

    # Add summary statistics
    if 'server_role' in result[0]:
        role_counts = {}
        for record in result:
            role = record.get('server_role', 'Unknown')
            role_counts[role] = role_counts.get(role, 0) + 1

        if len(role_counts) > 1:
            response += "ğŸ·ï¸ Server Role Summary:\n"
            for role, count in sorted(role_counts.items()):
                response += f"   â€¢ {role}: {count} servers\n"
            response += "\n"

    # Show limited detailed results
    if len(result) <= 10:
        response += "ğŸ“‹ Detailed Results:\n"
        response += format_query_results_tabular(result)
    else:
        response += f"ğŸ“‹ First 5 Results (of {len(result)} total):\n"
        response += format_query_results_tabular(result[:5])
        response += f"\n... and {len(result) - 5} more servers."

    return response

def format_query_results_tabular(result: List[Dict]) -> str:
    """Format results in a clean table"""
    if not result:
        return "No records found."

    important_cols = ['id', 'ip_address', 'server_role', 'osVersion', 'ram', 'cpuCore', 'firewall', 'dsAgent']
    available_cols = [col for col in important_cols if col in result[0]]

    if not available_cols:
        available_cols = list(result[0].keys())[:8]

    output = []

    # Calculate column widths
    col_widths = {}
    for col in available_cols:
        max_width = len(col)
        for row in result:
            if row.get(col):
                max_width = max(max_width, len(str(row[col])))
        col_widths[col] = min(max_width, 30)

    # Header
    header = " | ".join(col.ljust(col_widths[col]) for col in available_cols)
    separator = "-+-".join("-" * col_widths[col] for col in available_cols)
    output.append(header)
    output.append(separator)

    # Rows
    for row in result:
        formatted_row = " | ".join(
            str(row.get(col, 'NULL'))[:col_widths[col]-3] + "..."
            if len(str(row.get(col, 'NULL'))) > col_widths[col]
            else str(row.get(col, 'NULL')).ljust(col_widths[col])
            for col in available_cols
        )
        output.append(formatted_row)

    return "\n".join(output)

def get_sql_generation_prompt():
    """Generate SQL prompt for complex queries"""
    date_ctx = get_comprehensive_date_context()
    
    return f"""You are an expert SQL query generator for a System Compliance database.

**CURRENT DATE CONTEXT:**
- Today's date: {date_ctx['current_date']}
- Current year: {date_ctx['current_year']}

**DATABASE SCHEMA:**
Table: EISHome_compliance
- id (BIGINT), ip_address (VARCHAR), server_role (VARCHAR), osVersion (VARCHAR)
- ram (INT), cpuCore (INT), cpu (INT), memory (INT)
- firewall (VARCHAR), dsAgent (VARCHAR), splunk (VARCHAR)
- kernelVersion (VARCHAR), aceVersion (VARCHAR), mqVersion (VARCHAR)
- eisuserExpi (VARCHAR), rootExpi (VARCHAR), last_update (VARCHAR)

**RULES:**
1. ONLY generate SELECT statements
2. Use exact table name: EISHome_compliance
3. For text searches use LIKE with %wildcards%
4. Return ONLY the SQL query - no explanations

QUESTION: {{question}}
"""

# Setup logging
logging.basicConfig(
    filename=os.path.expanduser("~/.system_compliance_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    """Check if text contains dangerous patterns"""
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

class SystemComplianceAssistant:
    def __init__(self):
        self.llm = None
        self.db_handler = None
        self.initialized = False
        self.chat_history = []

    def initialize(self):
        """Initialize the System Compliance Assistant"""
        try:
            # Initialize LLM with better parameters
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.0)

            # Set up database connection
            db_cfg = COMPLIANCE_DB_CONFIG['db_config']
            uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"

            # Connect to database for LLM chain
            db_for_llm = SQLDatabase.from_uri(
                uri,
                include_tables=COMPLIANCE_DB_CONFIG.get("include_tables"),
                engine_args={
                    "pool_pre_ping": True,
                    "pool_recycle": 3600,
                    "connect_args": {
                        "connect_timeout": 30,
                        "read_timeout": 30,
                        "charset": "utf8mb4"
                    }
                }
            )

            # Create query chain
            chain = create_sql_query_chain(self.llm, db_for_llm)

            # Create direct connection for executing queries
            db_conn = pymysql.connect(
                host=db_cfg['host'],
                user=db_cfg['user'],
                password=db_cfg['password'],
                database=db_cfg['database'],
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor,
                autocommit=True,
                connect_timeout=30,
                read_timeout=30
            )

            self.db_handler = {
                'chain': chain,
                'connection': db_conn,
                'config': COMPLIANCE_DB_CONFIG
            }

            self.initialized = True
            return True

        except Exception as e:
            logger.error(f"Initialization failed: {e}\n{traceback.format_exc()}")
            return False

    def execute_sql_query(self, sql: str) -> List[Dict]:
        """Execute SQL query and return results"""
        try:
            with self.db_handler['connection'].cursor() as cursor:
                cursor.execute(sql)
                result = cursor.fetchall()
                return result
        except Exception as e:
            logger.error(f"SQL execution error: {e}\nSQL: {sql}")
            raise

    def query_system_compliance(self, question: str) -> str:
        """Enhanced query processing with fast path and AI analysis"""
        if not self.db_handler:
            return "âŒ System Compliance database not available."

        start_time = datetime.now()
        print(f"DEBUG - Processing question: {question}")

        try:
            # Step 1: Try fast query patterns first
            fast_sql = try_fast_query(question)
            if fast_sql:
                print(f"DEBUG - Using fast query: {fast_sql}")
                try:
                    result = self.execute_sql_query(fast_sql)
                    processing_time = (datetime.now() - start_time).total_seconds()
                    print(f"DEBUG - Fast query completed in {processing_time:.2f}s")
                    
                    # For analytical queries, add AI analysis
                    if is_analytical_query(question) and result:
                        print("DEBUG - Adding AI analysis for fast query")
                        ai_analysis = analyze_results_with_ai(question, result, self.llm)
                        return f"{ai_analysis}\n\nğŸ“Š Data Details:\n{format_query_results_natural(result, question)}"
                    else:
                        return format_query_results_natural(result, question)
                        
                except Exception as e:
                    print(f"DEBUG - Fast query failed: {e}")
                    # Fall back to AI generation

            # Step 2: Check if this needs analytical processing
            needs_analysis = is_analytical_query(question)
            print(f"DEBUG - Needs analysis: {needs_analysis}")

            # Step 3: Generate SQL using AI
            print("DEBUG - Generating SQL with AI")
            context_info = f"""
IMPORTANT INSTRUCTIONS:
- For server searches, use ip_address, server_role, or id fields
- For performance queries, use ram, cpuCore, cpu, memory fields  
- For security compliance, use firewall, dsAgent, splunk fields
- Use LIKE for text searches and exact matches for numbers/IPs

QUESTION: {question}
"""

            raw_sql = self.db_handler['chain'].invoke({"question": context_info})
            sql = clean_and_fix_sql(raw_sql)
            sql, is_valid = validate_and_fix_sql(sql)

            if not is_valid:
                return f"âŒ Invalid SQL query generated: {sql}"

            print(f"DEBUG - Generated SQL: {sql}")

            # Step 4: Execute query
            result = self.execute_sql_query(sql)
            processing_time = (datetime.now() - start_time).total_seconds()
            print(f"DEBUG - Query completed in {processing_time:.2f}s, found {len(result)} records")

            if not result:
                return "I couldn't find any system compliance records matching your criteria."

            # Step 5: Add AI analysis if needed
            if needs_analysis and len(result) > 1:
                print("DEBUG - Adding AI analysis")
                ai_analysis = analyze_results_with_ai(question, result, self.llm)
                return f"{ai_analysis}\n\nğŸ“Š Supporting Data:\n{format_query_results_natural(result, question)}"
            else:
                return format_query_results_natural(result, question)

        except Exception as e:
            processing_time = (datetime.now() - start_time).total_seconds()
            error_msg = f"âŒ Error processing request in {processing_time:.2f}s: {str(e)}"
            logger.error(f"Query processing error: {e}\n{traceback.format_exc()}")
            return error_msg

    def process_question(self, question: str) -> str:
        """Process questions with enhanced error handling"""
        if not self.initialized and not self.initialize():
            return "âŒ System Compliance Assistant initialization failed. Please check database connection."

        if is_dangerous(question):
            return "âŒ Question blocked for security reasons."

        response = self.query_system_compliance(question)
        return response

    def start_interactive_session(self, query):
        """Process single query with comprehensive error handling"""
        if not self.initialize():
            return "âŒ Failed to initialize System Compliance Assistant. Check database connection."

        try:
            if query.lower() in ['exit', 'quit', 'q']:
                return "ğŸ‘‹ Session ended."

            response = self.process_question(query)
            return response

        except KeyboardInterrupt:
            return "ğŸ‘‹ Session interrupted."
        except Exception as e:
            error_msg = f"âŒ Session error: {str(e)}"
            logger.error(f"Session error: {e}\n{traceback.format_exc()}")
            return error_msg
        finally:
            # Clean up database connection
            try:
                if (self.db_handler and
                    self.db_handler.get('connection') and
                    hasattr(self.db_handler['connection'], 'open') and
                    self.db_handler['connection'].open):
                    self.db_handler['connection'].close()
            except Exception as cleanup_error:
                print(f"DEBUG - Cleanup error: {cleanup_error}")
                pass

def ComplianceMain(query):
    """Main function to process System Compliance queries with enhanced performance"""
    print("ğŸš€ Starting System Compliance Assistant...")
    assistant = SystemComplianceAssistant()
    result = assistant.start_interactive_session(query)
    print("âœ… Query processing complete.")
    return result

# Interactive usage
if __name__ == "__main__":
    print("ğŸš€ System Compliance Assistant - Optimized Version")
    print("=" * 60)
    print("Ask questions about your system compliance database in natural language.")
    print("âœ¨ Fast queries (simple lookups) execute instantly")
    print("ğŸ§  Complex analytical queries use AI for insights")
    print("\nExamples:")
    print("  Fast: 'server 123', 'show all servers', 'count servers'")
    print("  Analytical: 'do all servers have same kernel?', 'compliance summary'")
    print("\nType 'exit' to quit.\n")

    while True:
        try:
            user_query = input("ğŸ” Enter your query: ").strip()

            if not user_query:
                continue

            if user_query.lower() in ['exit', 'quit', 'q']:
                print("ğŸ‘‹ Goodbye!")
                break

            print(f"\nâš¡ Processing: {user_query}")
            result = ComplianceMain(user_query)
            print(f"\nğŸ“Š Results:\n{result}\n")
            print("-" * 60)

        except KeyboardInterrupt:
            print("\nğŸ‘‹ Goodbye!")
            break
        except Exception as e:
            print(f"\nâŒ Error: {str(e)}")
            print("Please try rephrasing your question.\n")
