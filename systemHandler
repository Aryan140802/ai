import os
import re
import logging
import pymysql
import traceback
from typing import List, Optional, Dict, Any, Tuple
from datetime import datetime, date, timedelta
import json
import calendar
import sqlparse
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

today_date = date.today()

# --- SYSTEM COMPLIANCE CONFIGURATION ---
COMPLIANCE_DB_CONFIG = {
    "name": "System Compliance",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["EISHome_compliance"],
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

def is_simple_identifier(query: str) -> Tuple[bool, Optional[str]]:
    """
    Check if query is just a simple identifier (IP, ID, hostname) without natural language
    Returns (is_simple, sql_query)
    """
    query = query.strip()
    
    # Remove common prefixes that don't add meaning
    clean_query = re.sub(r'^(show\s+|get\s+|find\s+)?', query, flags=re.IGNORECASE).strip()
    
    # IP Address pattern (IPv4)
    ip_pattern = r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$'
    ip_match = re.match(ip_pattern, clean_query)
    if ip_match:
        ip = ip_match.group(1)
        return True, f"SELECT * FROM EISHome_compliance WHERE ip_address = '{ip}'"
    
    # Server ID (just numbers)
    id_pattern = r'^(\d+)$'
    id_match = re.match(id_pattern, clean_query)
    if id_match:
        server_id = id_match.group(1)
        return True, f"SELECT * FROM EISHome_compliance WHERE id = {server_id}"
    
    # Hostname pattern (letters, numbers, dots, hyphens - no spaces or natural language)
    hostname_pattern = r'^([a-zA-Z0-9\.\-_]+)$'
    hostname_match = re.match(hostname_pattern, clean_query)
    if hostname_match and '.' in clean_query and len(clean_query) > 3:
        hostname = hostname_match.group(1)
        return True, f"SELECT * FROM EISHome_compliance WHERE ip_address LIKE '%{hostname}%' OR server_role LIKE '%{hostname}%'"
    
    # Single word server role queries (no articles, conjunctions, or question words)
    single_word_pattern = r'^([a-zA-Z]+)$'
    single_word_match = re.match(single_word_pattern, clean_query)
    if single_word_match:
        word = single_word_match.group(1).lower()
        # Exclude question words, articles, and common natural language words
        natural_language_words = {
            'what', 'where', 'when', 'who', 'why', 'how', 'which', 'are', 'is', 'do', 'does', 'can', 'will', 'would',
            'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from',
            'all', 'some', 'any', 'many', 'much', 'few', 'little', 'more', 'most', 'less', 'least',
            'same', 'different', 'similar', 'like', 'unlike', 'than', 'as', 'if', 'unless', 'since', 'because'
        }
        
        if word not in natural_language_words:
            return True, f"SELECT * FROM EISHome_compliance WHERE server_role LIKE '%{word}%'"
    
    return False, None

def is_natural_language_question(query: str) -> bool:
    """
    Determine if the query is a natural language question that needs AI processing
    """
    query_lower = query.lower().strip()
    
    # Question patterns
    question_starters = [
        r'^(what|where|when|who|why|how|which)\b',
        r'^(are|is|do|does|can|will|would|should|could)\b',
        r'^(show\s+me|tell\s+me|list\s+all|give\s+me)\b',
        r'^(find\s+all|get\s+all|display\s+all)\b'
    ]
    
    # Analytical phrases
    analytical_phrases = [
        'same', 'different', 'compare', 'analysis', 'summary', 'overview',
        'all have', 'do all', 'are all', 'which ones', 'how many',
        'percentage', 'compliance', 'status', 'breakdown', 'distribution'
    ]
    
    # Complex query indicators
    complex_indicators = [
        'and', 'or', 'but', 'with', 'without', 'that have', 'that are',
        'more than', 'less than', 'greater than', 'higher than', 'lower than',
        'between', 'during', 'since', 'before', 'after'
    ]
    
    # Check for question patterns
    for pattern in question_starters:
        if re.match(pattern, query_lower):
            return True
    
    # Check for analytical phrases
    if any(phrase in query_lower for phrase in analytical_phrases):
        return True
    
    # Check for complex indicators
    if any(indicator in query_lower for indicator in complex_indicators):
        return True
    
    # If query has multiple words and contains common question/analysis words
    words = query_lower.split()
    if len(words) > 2:  # More than 2 words suggests natural language
        return True
    
    return False

def generate_fast_sql_patterns():
    """Generate fast SQL patterns for common simple queries"""
    patterns = {
        # Count queries
        r'^count\s*$': "SELECT COUNT(*) as total_servers FROM EISHome_compliance",
        r'^count\s+servers?\s*$': "SELECT COUNT(*) as total_servers FROM EISHome_compliance",
        r'^total\s*$': "SELECT COUNT(*) as total_servers FROM EISHome_compliance",
        r'^total\s+servers?\s*$': "SELECT COUNT(*) as total_servers FROM EISHome_compliance",
        
        # List all queries
        r'^all\s*$': "SELECT * FROM EISHome_compliance",
        r'^all\s+servers?\s*$': "SELECT * FROM EISHome_compliance",
        r'^servers?\s*$': "SELECT * FROM EISHome_compliance",
        r'^list\s*$': "SELECT * FROM EISHome_compliance",
        
        # Status queries (single word + status)
        r'^firewall\s*$': "SELECT * FROM EISHome_compliance WHERE firewall IS NOT NULL",
        r'^dsagent\s*$': "SELECT * FROM EISHome_compliance WHERE dsAgent IS NOT NULL",
        r'^splunk\s*$': "SELECT * FROM EISHome_compliance WHERE splunk IS NOT NULL",
        
        # OS queries
        r'^centos\s*$': "SELECT * FROM EISHome_compliance WHERE osVersion LIKE '%CentOS%'",
        r'^linux\s*$': "SELECT * FROM EISHome_compliance WHERE osVersion LIKE '%Linux%'",
        r'^windows\s*$': "SELECT * FROM EISHome_compliance WHERE osVersion LIKE '%Windows%'",
        
        # Role-based queries (single words)
        r'^web\s*$': "SELECT * FROM EISHome_compliance WHERE server_role LIKE '%web%'",
        r'^database\s*$': "SELECT * FROM EISHome_compliance WHERE server_role LIKE '%database%'",
        r'^db\s*$': "SELECT * FROM EISHome_compliance WHERE server_role LIKE '%db%'",
        r'^app\s*$': "SELECT * FROM EISHome_compliance WHERE server_role LIKE '%app%'",
        r'^application\s*$': "SELECT * FROM EISHome_compliance WHERE server_role LIKE '%application%'"
    }
    return patterns

def try_fast_query(query: str) -> Optional[str]:
    """Try to match simple queries to fast SQL patterns"""
    query_clean = query.lower().strip()
    patterns = generate_fast_sql_patterns()
    
    for pattern, sql in patterns.items():
        if re.match(pattern, query_clean):
            return sql
    
    return None

def get_sql_generation_prompt():
    """Generate comprehensive SQL prompt for complex queries"""
    return f"""You are an expert SQL generator for EISHome_compliance table.

TABLE SCHEMA:
- id (BIGINT): Server ID
- ip_address (VARCHAR): Server IP 
- server_role (VARCHAR): Role (web, database, app, etc)
- osVersion (VARCHAR): OS version
- kernelVersion (VARCHAR): Kernel version
- ram (INT): RAM in GB
- cpuCore (INT): CPU cores
- cpu (INT): CPU usage %
- memory (INT): Memory usage %
- firewall (VARCHAR): Firewall status
- dsAgent (VARCHAR): Deep Security Agent
- splunk (VARCHAR): Splunk agent
- aceVersion (VARCHAR): ACE version
- mqVersion (VARCHAR): MQ version
- eisuserExpi, rootExpi, socvaExpi, addmitamExpi (VARCHAR): User expiry dates

RULES:
1. Generate ONLY valid SELECT statements
2. Use exact table name: EISHome_compliance  
3. For text searches use LIKE with %wildcards%
4. For numbers use =, >, <, >=, <= operators
5. Return ONLY the SQL query, no explanations
6. Use proper WHERE clauses for filtering
7. For "all servers" use SELECT * FROM EISHome_compliance
8. For version comparisons, be specific about the field name

QUESTION: {{question}}

SQL:"""

def clean_and_fix_sql(raw_sql: str) -> str:
    """Clean and fix SQL generated by AI"""
    print(f"DEBUG - Raw SQL: {repr(raw_sql)}")
    
    # Handle refusal responses
    if any(phrase in raw_sql.lower() for phrase in ["i cannot", "i can't", "sorry", "unable"]):
        return "ERROR: AI refused to generate SQL"
    
    # Extract SQL from various formats
    sql = raw_sql.strip()
    
    # Remove code block markers
    sql = re.sub(r'```(?:sql)?\s*(.*?)\s*```', r'\1', sql, flags=re.DOTALL | re.IGNORECASE)
    
    # Remove common prefixes
    sql = re.sub(r'^(sql:|query:|here is|here\'s)?\s*:?\s*', '', sql, flags=re.IGNORECASE)
    
    # Extract the SELECT statement
    select_match = re.search(r'(SELECT\s+.*?)(?:;|\n\s*$|$)', sql, re.IGNORECASE | re.DOTALL)
    if select_match:
        sql = select_match.group(1).strip()
    
    # Fix common issues
    sql = re.sub(r'\s+', ' ', sql)  # Normalize whitespace
    sql = re.sub(r'from\s+eishome_compliance', 'FROM EISHome_compliance', sql, flags=re.IGNORECASE)
    
    # Ensure proper semicolon
    if not sql.endswith(';'):
        sql += ';'
    
    print(f"DEBUG - Cleaned SQL: {sql}")
    return sql

def validate_sql(sql: str) -> Tuple[str, bool]:
    """Validate and ensure SQL is safe"""
    if not sql.upper().strip().startswith('SELECT'):
        return sql, False
    
    # Check for dangerous operations
    dangerous_ops = ['INSERT', 'UPDATE', 'DELETE', 'DROP', 'ALTER', 'CREATE', 'TRUNCATE']
    sql_upper = sql.upper()
    if any(op in sql_upper for op in dangerous_ops):
        return sql, False
    
    # Basic syntax validation
    try:
        parsed = sqlparse.parse(sql)
        if not parsed:
            return sql, False
    except:
        return sql, False
    
    return sql, True

def analyze_results_with_ai(question: str, results: List[Dict], llm) -> str:
    """Use AI to analyze results and provide natural language insights"""
    if not results:
        return "No matching servers found for your query."
    
    # Prepare summary data
    total_count = len(results)
    
    # Get unique values for key analysis fields
    analysis_fields = ['server_role', 'osVersion', 'kernelVersion', 'firewall', 'dsAgent', 'aceVersion', 'mqVersion']
    field_analysis = {}
    
    for field in analysis_fields:
        if field in results[0]:
            values = [str(r.get(field, 'NULL')) for r in results if r.get(field) is not None]
            unique_values = list(set(values))
            field_analysis[field] = {
                'unique_count': len(unique_values),
                'values': unique_values[:10],  # Limit for prompt size
                'total_records': len(values)
            }
    
    # Create focused analysis prompt
    prompt = f"""Analyze this system compliance data to answer the user's question.

USER QUESTION: "{question}"

DATA SUMMARY:
- Total servers: {total_count}
- Field Analysis: {json.dumps(field_analysis, indent=2)}

Please provide a direct, clear answer to the user's question. Focus on:
1. Direct yes/no answer if applicable
2. Specific differences or issues found
3. Key statistics or patterns
4. Actionable insights

Keep response concise and specific to the question asked."""

    try:
        analysis = llm.invoke(prompt)
        return analysis.strip()
    except Exception as e:
        return f"Analysis completed but couldn't generate detailed insights: {str(e)}"

def format_simple_results(results: List[Dict], query: str) -> str:
    """Format results for simple queries (non-analytical)"""
    if not results:
        return f"No servers found matching '{query}'"
    
    if len(results) == 1:
        # Single server - show detailed info
        server = results[0]
        output = f"ğŸ–¥ï¸ Server Details:\n"
        
        key_fields = {
            'id': 'ğŸ†” ID',
            'ip_address': 'ğŸŒ IP Address', 
            'server_role': 'ğŸ·ï¸ Role',
            'osVersion': 'ğŸ’¿ OS Version',
            'kernelVersion': 'ğŸ”§ Kernel',
            'ram': 'ğŸ§  RAM',
            'cpuCore': 'âš¡ CPU Cores',
            'cpu': 'ğŸ–¥ï¸ CPU Usage',
            'memory': 'ğŸ’¾ Memory Usage',
            'firewall': 'ğŸ”¥ Firewall',
            'dsAgent': 'ğŸ›¡ï¸ Deep Security',
            'splunk': 'ğŸ“Š Splunk'
        }
        
        for field, label in key_fields.items():
            if field in server and server[field] is not None:
                value = server[field]
                if field == 'ram':
                    value = f"{value} GB"
                elif field in ['cpu', 'memory'] and isinstance(value, (int, float)):
                    value = f"{value}%"
                output += f"{label}: {value}\n"
        
        return output.strip()
    
    elif len(results) <= 10:
        # Small result set - show table
        return format_table(results)
    
    else:
        # Large result set - show summary + sample
        output = f"Found {len(results)} servers:\n\n"
        
        # Add role summary if available
        if 'server_role' in results[0]:
            roles = {}
            for server in results:
                role = server.get('server_role', 'Unknown')
                roles[role] = roles.get(role, 0) + 1
            
            output += "ğŸ·ï¸ Server Roles:\n"
            for role, count in sorted(roles.items()):
                output += f"  â€¢ {role}: {count} servers\n"
            output += "\n"
        
        # Show sample
        output += f"ğŸ“‹ Sample (first 5 servers):\n"
        output += format_table(results[:5])
        output += f"\n... and {len(results) - 5} more servers"
        
        return output

def format_table(results: List[Dict]) -> str:
    """Format results as a clean table"""
    if not results:
        return "No data to display"
    
    # Select important columns
    priority_cols = ['id', 'ip_address', 'server_role', 'osVersion', 'ram', 'cpuCore', 'firewall', 'dsAgent']
    available_cols = [col for col in priority_cols if col in results[0]]
    
    if not available_cols:
        available_cols = list(results[0].keys())[:6]  # First 6 columns
    
    # Calculate column widths
    col_widths = {}
    for col in available_cols:
        max_width = len(str(col))
        for row in results:
            value = str(row.get(col, 'NULL'))
            max_width = max(max_width, len(value))
        col_widths[col] = min(max_width, 25)  # Max 25 chars
    
    # Build table
    output = []
    
    # Header
    header = " | ".join(col.ljust(col_widths[col]) for col in available_cols)
    separator = "-+-".join("-" * col_widths[col] for col in available_cols)
    output.append(header)
    output.append(separator)
    
    # Rows
    for row in results:
        formatted_row = " | ".join(
            str(row.get(col, 'NULL')).ljust(col_widths[col])[:col_widths[col]]
            for col in available_cols
        )
        output.append(formatted_row)
    
    return "\n".join(output)

class SystemComplianceAssistant:
    def __init__(self):
        self.llm = None
        self.db_connection = None
        self.db_chain = None
        self.initialized = False

    def initialize(self):
        """Initialize database connection and AI components"""
        try:
            db_config = COMPLIANCE_DB_CONFIG['db_config']
            
            # Direct database connection
            self.db_connection = pymysql.connect(
                host=db_config['host'],
                user=db_config['user'],
                password=db_config['password'],
                database=db_config['database'],
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor,
                autocommit=True
            )
            
            # AI components (only initialize when needed)
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.0)
            
            # Database chain for complex queries
            uri = f"mysql+pymysql://{db_config['user']}:{db_config['password']}@{db_config['host']}/{db_config['database']}"
            db_for_chain = SQLDatabase.from_uri(uri, include_tables=["EISHome_compliance"])
            self.db_chain = create_sql_query_chain(self.llm, db_for_chain)
            
            self.initialized = True
            return True
            
        except Exception as e:
            print(f"âŒ Initialization failed: {e}")
            return False

    def execute_query(self, sql: str) -> List[Dict]:
        """Execute SQL query safely"""
        try:
            with self.db_connection.cursor() as cursor:
                cursor.execute(sql)
                return cursor.fetchall()
        except Exception as e:
            print(f"âŒ Query execution failed: {e}")
            raise

    def process_query(self, query: str) -> str:
        """Main query processing logic"""
        if not self.initialized:
            if not self.initialize():
                return "âŒ System not available"
        
        start_time = datetime.now()
        query = query.strip()
        
        print(f"ğŸ” Processing: '{query}'")
        
        try:
            # Step 1: Check for simple identifiers (IP, ID, hostname)
            is_simple, direct_sql = is_simple_identifier(query)
            if is_simple:
                print(f"âš¡ Fast path - Direct SQL: {direct_sql}")
                results = self.execute_query(direct_sql)
                elapsed = (datetime.now() - start_time).total_seconds()
                print(f"âœ… Completed in {elapsed:.2f}s")
                return format_simple_results(results, query)
            
            # Step 2: Check for simple pattern matches
            fast_sql = try_fast_query(query)
            if fast_sql and not is_natural_language_question(query):
                print(f"âš¡ Fast pattern match: {fast_sql}")
                results = self.execute_query(fast_sql)
                elapsed = (datetime.now() - start_time).total_seconds()
                print(f"âœ… Completed in {elapsed:.2f}s")
                return format_simple_results(results, query)
            
            # Step 3: Natural language processing with AI
            if is_natural_language_question(query):
                print("ğŸ§  Using AI for natural language query")
                
                # Generate SQL with AI
                prompt = get_sql_generation_prompt().format(question=query)
                raw_sql = self.db_chain.invoke({"question": query})
                
                # Clean and validate SQL
                sql = clean_and_fix_sql(raw_sql)
                sql, is_valid = validate_sql(sql)
                
                if not is_valid:
                    return f"âŒ Could not generate valid SQL for: '{query}'"
                
                print(f"ğŸ”§ Generated SQL: {sql}")
                
                # Execute query
                results = self.execute_query(sql)
                
                # Analyze results with AI
                analysis = analyze_results_with_ai(query, results, self.llm)
                
                elapsed = (datetime.now() - start_time).total_seconds()
                print(f"âœ… AI analysis completed in {elapsed:.2f}s")
                
                # Combine analysis with data
                if results and len(results) <= 10:
                    return f"{analysis}\n\nğŸ“Š Supporting Data:\n{format_table(results)}"
                elif results and len(results) > 10:
                    return f"{analysis}\n\nğŸ“Š Sample Data:\n{format_table(results[:5])}\n... ({len(results)} total servers)"
                else:
                    return analysis
            
            # Step 4: Fallback - treat as simple query
            print("ğŸ”„ Fallback to simple processing")
            # Try to find any matches in server roles or IP addresses
            fallback_sql = f"""
            SELECT * FROM EISHome_compliance 
            WHERE ip_address LIKE '%{query}%' 
               OR server_role LIKE '%{query}%' 
               OR CAST(id AS CHAR) LIKE '%{query}%'
            """
            results = self.execute_query(fallback_sql)
            elapsed = (datetime.now() - start_time).total_seconds()
            print(f"âœ… Fallback completed in {elapsed:.2f}s")
            
            if results:
                return format_simple_results(results, query)
            else:
                return f"No servers found matching '{query}'. Try being more specific (e.g., IP address, server role, or ask a complete question)."
        
        except Exception as e:
            elapsed = (datetime.now() - start_time).total_seconds()
            error_msg = f"âŒ Error after {elapsed:.2f}s: {str(e)}"
            print(error_msg)
            return error_msg

    def cleanup(self):
        """Clean up resources"""
        try:
            if self.db_connection:
                self.db_connection.close()
        except:
            pass

# Setup logging
logging.basicConfig(level=logging.ERROR)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    """Check for dangerous patterns"""
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def ComplianceMain(query):
    """Main entry point"""
    if is_dangerous(query):
        return "âŒ Query blocked for security reasons"
    
    assistant = SystemComplianceAssistant()
    try:
        return assistant.process_query(query)
    finally:
        assistant.cleanup()

# Interactive mode
if __name__ == "__main__":
    print("ğŸš€ Smart System Compliance Assistant")
    print("=" * 50)
    print("ğŸ’¡ Usage:")
    print("  Simple: '10.188.24.100', '123', 'web', 'count'")
    print("  Complex: 'Do all servers have same kernel version?'")
    print("           'Which servers have firewall disabled?'")
    print("\nType 'exit' to quit.\n")

    while True:
        try:
            user_query = input("ğŸ” Query: ").strip()
            
            if not user_query:
                continue
                
            if user_query.lower() in ['exit', 'quit', 'q']:
                print("ğŸ‘‹ Goodbye!")
                break
            
            result = ComplianceMain(user_query)
            print(f"\n{result}\n")
            print("-" * 50)
            
        except KeyboardInterrupt:
            print("\nğŸ‘‹ Goodbye!")
            break
        except Exception as e:
            print(f"\nâŒ Error: {e}\n")
