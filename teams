import os
import re
import logging
import pymysql
import traceback
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, timedelta
import hashlib
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

# --- TEAM DETAILS CONFIGURATION ---
TEAM_DB_CONFIG = {
    "name": "Team Details",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["UserMaster"],
}

# Context-aware configuration
CONTEXT_CONFIG = {
    "max_history_items": 10,
    "context_expiry_minutes": 30,
    "similarity_threshold": 0.7,
    "cache_size": 100,
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

# Sensitive fields
SENSITIVE_FIELDS = ["Pwd", "SecQ", "SecA"]

# Setup logging
logging.basicConfig(
    filename=os.path.expanduser("~/.team_details_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class QueryCache:
    """Simple query cache"""
    def __init__(self, max_size: int = 100):
        self.cache = {}
        self.access_times = {}
        self.max_size = max_size
    
    def _generate_key(self, query: str) -> str:
        return hashlib.md5(query.lower().strip().encode()).hexdigest()
    
    def get(self, query: str) -> Optional[str]:
        key = self._generate_key(query)
        if key in self.cache:
            if datetime.now() - self.access_times[key] < timedelta(minutes=5):
                self.access_times[key] = datetime.now()
                return self.cache[key]
            else:
                del self.cache[key]
                del self.access_times[key]
        return None
    
    def set(self, query: str, result: str):
        key = self._generate_key(query)
        if len(self.cache) >= self.max_size:
            oldest_key = min(self.access_times.keys(), key=lambda k: self.access_times[k])
            del self.cache[oldest_key]
            del self.access_times[oldest_key]
        self.cache[key] = result
        self.access_times[key] = datetime.now()

def is_dangerous(text: str) -> bool:
    """Check for dangerous patterns"""
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def clean_sql(raw_sql: str) -> str:
    """Clean generated SQL"""
    # Extract SQL from code block if present
    match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
    if match:
        sql = match.group(1).strip()
    else:
        sql = raw_sql
    
    # Remove sensitive fields
    for field in SENSITIVE_FIELDS:
        sql = re.sub(rf'\b{field}\b\s*,?\s*', '', sql, flags=re.IGNORECASE)
    
    # Add limit if missing
    if not re.search(r"\bLIMIT\b", sql, re.IGNORECASE):
        sql += " LIMIT 50"
    
    return sql.strip().rstrip(";")

def is_select_query(sql: str) -> bool:
    """Check if query is safe SELECT"""
    sql = sql.strip().lower()
    return sql.startswith('select') and not any(
        kw in sql for kw in ['insert', 'update', 'delete', 'drop', 'alter', 'create', 'truncate']
    )

def is_simple_query(query: str) -> bool:
    """Check if query is simple (name or UID)"""
    query = query.strip()
    # 7-digit UID
    if re.match(r'^\d{7}$', query):
        return True
    # Name (letters and spaces)
    if re.match(r'^[A-Za-z\s]+$', query):
        return True
    return False

def generate_simple_query(query: str) -> str:
    """Generate SQL for simple queries"""
    query = query.strip()
    # UID query
    if re.match(r'^\d{7}$', query):
        return f"SELECT Uid, EmpName, Team, Position, TcsEmail, Contact FROM UserMaster WHERE Uid = {query} LIMIT 1"
    # Name query
    return f"SELECT Uid, EmpName, Team, Position FROM UserMaster WHERE EmpName LIKE '%{query}%' LIMIT 10"

def format_output(response_type: str, question: str, sql: str, result: List[Dict], explanation: str = "") -> str:
    """Format output with headers"""
    output = []
    output.append(f"🔹 {response_type.upper()} QUERY")
    output.append(f"Question: {question}")
    output.append(f"SQL Used: {sql}")
    
    if response_type == "AI":
        output.append(f"\n🤖 AI EXPLANATION")
        output.append(explanation)
    
    output.append(f"\n📊 RESULTS")
    
    if not result:
        output.append("No matching records found.")
    else:
        for i, record in enumerate(result, 1):
            output.append(f"\nRecord {i}:")
            for key, value in record.items():
                output.append(f"  {key}: {value}")
    
    return "\n".join(output)

class EnhancedTeamDetailsAssistant:
    def __init__(self):
        self.llm = None
        self.db_handler = None
        self.initialized = False
        self.cache = QueryCache(max_size=CONTEXT_CONFIG['cache_size'])

    def initialize(self) -> bool:
        """Initialize database and LLM connections"""
        try:
            # Initialize LLM
            self.llm = OllamaLLM(
                model="myllm:latest",
                temperature=0.1,
                request_timeout=30.0
            )

            # Database connection
            db_cfg = TEAM_DB_CONFIG['db_config']
            uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"

            db_for_llm = SQLDatabase.from_uri(
                uri,
                include_tables=TEAM_DB_CONFIG.get("include_tables"),
                engine_args={
                    "pool_pre_ping": True,
                    "pool_recycle": 1800,
                    "pool_size": 5,
                    "max_overflow": 10,
                    "connect_args": {
                        "connect_timeout": 10,
                        "charset": "utf8mb4"
                    }
                }
            )

            chain = create_sql_query_chain(self.llm, db_for_llm)

            # Direct DB connection
            db_conn = pymysql.connect(
                host=db_cfg['host'],
                user=db_cfg['user'],
                password=db_cfg['password'],
                database=db_cfg['database'],
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor,
                autocommit=True,
                connect_timeout=10
            )

            self.db_handler = {
                'chain': chain,
                'connection': db_conn,
                'config': TEAM_DB_CONFIG
            }

            self.initialized = True
            return True

        except Exception as e:
            logger.error(f"Initialization failed: {e}\n{traceback.format_exc()}")
            return False

    def execute_query(self, sql: str) -> Tuple[str, List[Dict]]:
        """Execute SQL query"""
        try:
            with self.db_handler['connection'].cursor() as cursor:
                cursor.execute(sql)
                return "Success", cursor.fetchall()
        except pymysql.Error as db_error:
            logger.error(f"Database error: {db_error}\nSQL: {sql}")
            return f"Database Error: {str(db_error)}", []

    def process_question(self, question: str) -> str:
        """Process question and return formatted response"""
        if not self.initialized and not self.initialize():
            return "❌ System initialization failed"

        if is_dangerous(question):
            return "❌ Blocked for security reasons"

        # Check cache
        cached = self.cache.get(question)
        if cached:
            return cached

        # SIMPLE QUERY PROCESSING
        if is_simple_query(question):
            logger.info(f"Processing SIMPLE query: {question}")
            sql = generate_simple_query(question)
            status, result = self.execute_query(sql)
            
            if status != "Success":
                return f"❌ Error: {status}"
            
            response = format_output(
                response_type="Simple",
                question=question,
                sql=sql,
                result=result
            )
            self.cache.set(question, response)
            return response

        # COMPLEX QUERY PROCESSING
        logger.info(f"Processing COMPLEX query: {question}")
        
        # Generate SQL with AI
        try:
            raw_sql = self.db_handler['chain'].invoke({"question": question})
            sql = clean_sql(raw_sql)
            
            if not is_select_query(sql):
                return "❌ Only SELECT queries are allowed"
            
            # Execute query
            status, result = self.execute_query(sql)
            if status != "Success":
                return f"❌ Error: {status}"
            
            # Generate AI explanation
            explanation = (
                "The AI analyzed your natural language question and converted it to SQL. "
                "The query searches the employee database based on your criteria. "
                "Results are limited to 50 records for performance."
            )
            
            response = format_output(
                response_type="AI",
                question=question,
                sql=sql,
                result=result,
                explanation=explanation
            )
            self.cache.set(question, response)
            return response

        except Exception as e:
            logger.error(f"Processing error: {e}\n{traceback.format_exc()}")
            return f"❌ Processing error: {str(e)}"

def Teammain(query: str) -> str:
    """Main entry point"""
    assistant = EnhancedTeamDetailsAssistant()
    return assistant.process_question(query)

# Example usage
if __name__ == "__main__":
    test_queries = [
        "1234567",  # Simple UID
        "John Doe",  # Simple name
        "What team is employee 1234567 in?",  # Complex
        "List all managers in the Marketing department",  # Complex
    ]

    for query in test_queries:
        print(f"\n{'='*60}")
        print(f"Processing query: '{query}'")
        print(f"Simple query? {is_simple_query(query)}")
        print('-'*60)
        result = Teammain(query)
        print(result)
        print('='*60)
