import os
import re
import logging
import pymysql
import traceback
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, timedelta
import hashlib
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain
from langchain.prompts import PromptTemplate

# Configuration
CONFIG = {
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["UserMaster"],
    "cache_ttl_minutes": 5,
    "cache_size": 100,
    "max_results": 50,
    "blocked_patterns": [
        r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b",
        r"\buserdel\b", r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b",
        r"\bcurl\b", r":\s*(){:|:&};:", r"\bsudo\b", r"\bsu\b"
    ],
    "sensitive_fields": ["Pwd", "SecQ", "SecA"]
}

# Setup logging
logging.basicConfig(
    filename=os.path.expanduser("~/.team_details_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class QueryCache:
    def __init__(self, max_size: int = 100):
        self.cache = {}
        self.access_times = {}
        self.max_size = max_size
    
    def _generate_key(self, query: str) -> str:
        return hashlib.md5(query.lower().strip().encode()).hexdigest()
    
    def get(self, query: str) -> Optional[Tuple[str, List[Dict]]]:
        key = self._generate_key(query)
        if key in self.cache:
            if datetime.now() - self.access_times[key] < timedelta(minutes=CONFIG['cache_ttl_minutes']):
                self.access_times[key] = datetime.now()
                return self.cache[key]
            del self.cache[key]
            del self.access_times[key]
        return None
    
    def set(self, query: str, result: Tuple[str, List[Dict]]):
        key = self._generate_key(query)
        if len(self.cache) >= self.max_size:
            oldest_key = min(self.access_times.keys(), key=lambda k: self.access_times[k])
            del self.cache[oldest_key]
            del self.access_times[oldest_key]
        self.cache[key] = result
        self.access_times[key] = datetime.now()

def is_dangerous(text: str) -> bool:
    return any(re.search(pattern, text.lower()) for pattern in CONFIG['blocked_patterns'])

def clean_sql(raw_sql: str) -> str:
    """Extract and clean SQL from LLM output"""
    # Extract SQL from code block
    match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
    sql = match.group(1).strip() if match else raw_sql
    
    # Remove sensitive fields
    for field in CONFIG['sensitive_fields']:
        sql = re.sub(rf'\b{field}\b\s*,?\s*', '', sql, flags=re.IGNORECASE)
    
    # Add limit if missing
    if not re.search(r"\bLIMIT\b", sql, re.IGNORECASE):
        sql = re.sub(r";?\s*$", f" LIMIT {CONFIG['max_results']}", sql)
    
    return sql.strip().rstrip(";")

def is_simple_query(query: str) -> bool:
    """Check if query is simple (name or UID)"""
    query = query.strip()
    return (re.match(r'^\d{7}$', query) or  # 7-digit UID
           re.match(r'^[A-Za-z\s]+$', query))  # Name only

def generate_simple_query(query: str) -> str:
    """Generate SQL for simple queries"""
    query = query.strip()
    if re.match(r'^\d{7}$', query):  # UID query
        return f"SELECT Uid, EmpName, Team, Position, TcsEmail, Contact FROM UserMaster WHERE Uid = {query} LIMIT 1"
    return f"SELECT Uid, EmpName, Team, Position FROM UserMaster WHERE EmpName LIKE '%{query}%' LIMIT 10"

class EnhancedTeamDetailsAssistant:
    def __init__(self):
        self.llm = None
        self.db_chain = None
        self.db_conn = None
        self.cache = QueryCache(max_size=CONFIG['cache_size'])
        self.initialized = False

    def initialize(self) -> bool:
        """Initialize database and LLM connections"""
        try:
            # Initialize LLM with optimized settings
            self.llm = OllamaLLM(
                model="myllm:latest",
                temperature=0.1,
                request_timeout=15.0
            )

            # SQL generation chain
            db = SQLDatabase.from_uri(
                f"mysql+pymysql://{CONFIG['db_config']['user']}:{CONFIG['db_config']['password']}@"
                f"{CONFIG['db_config']['host']}/{CONFIG['db_config']['database']}",
                include_tables=CONFIG['include_tables'],
                engine_args={
                    "pool_pre_ping": True,
                    "pool_recycle": 1800,
                    "pool_size": 5,
                    "max_overflow": 10,
                    "connect_args": {"connect_timeout": 5}
                }
            )
            self.db_chain = create_sql_query_chain(self.llm, db)

            # Direct DB connection for faster execution
            self.db_conn = pymysql.connect(
                **CONFIG['db_config'],
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor,
                autocommit=True,
                connect_timeout=5
            )

            # Result explanation prompt
            self.explanation_prompt = PromptTemplate(
                input_variables=["question", "results"],
                template="""
                Given this database query results, provide a concise natural language answer:
                
                Question: {question}
                Results: {results}
                
                Answer concisely in 1-2 sentences. If no results, say "No matching records found."
                """
            )

            self.initialized = True
            return True

        except Exception as e:
            logger.error(f"Initialization failed: {e}\n{traceback.format_exc()}")
            return False

    def execute_query(self, sql: str) -> Tuple[str, List[Dict]]:
        """Execute SQL query quickly"""
        try:
            with self.db_conn.cursor() as cursor:
                cursor.execute(sql)
                return "Success", cursor.fetchall()
        except pymysql.Error as e:
            logger.error(f"Database error: {e}\nSQL: {sql}")
            return f"Database Error: {str(e)}", []

    def explain_results(self, question: str, results: List[Dict]) -> str:
        """Use AI to explain results in natural language"""
        try:
            # Format results for LLM
            results_str = "\n".join(
                f"{i}. {str(r)}" for i, r in enumerate(results[:5], 1)
            ) if results else "No results"
            
            # Get explanation from LLM
            explanation = self.llm.invoke(
                self.explanation_prompt.format(
                    question=question,
                    results=results_str
                )
            )
            return explanation.strip()
        except Exception as e:
            logger.error(f"Explanation error: {e}")
            return "Here are the results (could not generate explanation)"

    def process_query(self, question: str) -> Tuple[str, str, List[Dict]]:
        """Process query and return (response, sql, results)"""
        if not self.initialized and not self.initialize():
            return "❌ System initialization failed", "", []

        if is_dangerous(question):
            return "❌ Blocked for security reasons", "", []

        # Check cache
        cached = self.cache.get(question)
        if cached:
            return cached[0], cached[1], cached[2]

        # SIMPLE QUERY PROCESSING (fast path)
        if is_simple_query(question):
            sql = generate_simple_query(question)
            status, results = self.execute_query(sql)
            
            if status != "Success":
                return f"❌ {status}", sql, []
            
            response = self.explain_results(question, results)
            self.cache.set(question, (response, sql, results))
            return response, sql, results

        # COMPLEX QUERY PROCESSING (AI path)
        try:
            # Step 1: Generate SQL with AI
            raw_sql = self.db_chain.invoke({"question": question})
            sql = clean_sql(raw_sql)
            
            if not sql.strip().upper().startswith("SELECT"):
                return "❌ Only SELECT queries are allowed", sql, []

            # Step 2: Execute query
            status, results = self.execute_query(sql)
            if status != "Success":
                return f"❌ {status}", sql, []

            # Step 3: Generate natural language response
            response = self.explain_results(question, results)
            self.cache.set(question, (response, sql, results))
            return response, sql, results

        except Exception as e:
            logger.error(f"Processing error: {e}\n{traceback.format_exc()}")
            return f"❌ Processing error: {str(e)}", "", []

def format_response(question: str, response: str, sql: str, results: List[Dict]) -> str:
    """Format final output with all details"""
    output = []
    output.append(f"🔹 {'SIMPLE' if is_simple_query(question) else 'AI'} QUERY")
    output.append(f"Question: {question}")
    output.append(f"SQL Used: {sql}")
    
    if not is_simple_query(question):
        output.append("\n🤖 AI EXPLANATION")
        output.append(response)
    
    output.append("\n📊 RESULTS")
    
    if not results:
        output.append("No matching records found.")
    else:
        output.append(f"Found {len(results)} records:")
        for i, record in enumerate(results[:5], 1):
            output.append(f"\nRecord {i}:")
            for key, value in record.items():
                output.append(f"  {key}: {value}")
        if len(results) > 5:
            output.append(f"\n... and {len(results)-5} more records")
    
    return "\n".join(output)

def Teammain(query: str) -> str:
    """Main entry point - returns formatted response"""
    assistant = EnhancedTeamDetailsAssistant()
    response, sql, results = assistant.process_query(query)
    return format_response(query, response, sql, results)

# Example usage
if __name__ == "__main__":
    test_queries = [
        "1234567",  # Simple UID
        "John Doe",  # Simple name
        "List employees in IIB team",  # Complex
        "Who are the managers in Marketing department?",  # Complex
        "Show me people with both Java and Python skills",  # Complex
    ]

    print("🚀 Team Details Assistant - Enhanced Version")
    for query in test_queries:
        print(f"\n{'='*80}")
        print(f"Processing: '{query}'")
        print('-'*80)
        result = Teammain(query)
        print(result)
        print('='*80)
