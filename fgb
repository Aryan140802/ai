import os
import re
import logging
import pymysql
import traceback
from typing import List, Optional

from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

# --- CONFIGURATION ---

DB_CONFIGS = {
    "process": {
        "name": "FAR Details",
        "db_config": {
            "host": "localhost", "user": "root", "password": "root123", "database": "EIS_n"
        },
        "include_tables": ["FarDetailsAll"],
    },
    "system": {
        "name": "System Metrics",
        "db_config": {
            "host": "localhost", "user": "ray", "password": "", "database": "system_monitor_db"
        },
        "include_tables": None,
    },
    "team": {
        "name": "Team Info",
        "db_config": {
            "host": "localhost", "user": "root", "password": "root123", "database": "EIS"
        },
        "include_tables": ["UserMaster"],
    }
}

# --- LOGGING SETUP ---

logging.basicConfig(
    filename=os.path.expanduser("~/.eis_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# --- UTILS & FORMATTING ---

def clean_sql(raw_sql: str) -> str:
    """
    Cleans LLM-generated SQL. Extracts SQL from code blocks or removes non-SQL preamble.
    """
    match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
    if match:
        sql = match.group(1)
    else:
        # Remove backticks and preamble
        sql = re.sub(r"```", "", raw_sql)
        sql = re.sub(r"^(.*?)(SELECT|INSERT|UPDATE|DELETE|WITH)", r"\2", sql, flags=re.IGNORECASE | re.DOTALL)
    # Remove any trailing semicolons and whitespace
    return sql.strip().rstrip(";")

def format_answer(result: List[tuple], columns: Optional[List[str]] = None) -> str:
    """
    Formats the database query result into a human-readable string.
    Supports tabular display if column info is available.
    """
    if not result:
        return "  • No data found for your request."

    # If result is a single value (e.g., COUNT, AVG)
    if len(result) == 1 and len(result[0]) == 1:
        return f"  • Result: {result[0][0]}"

    # If columns provided, display as a table
    if columns:
        col_line = "    | " + " | ".join(columns) + " |"
        sep_line = "    |" + "|".join('-' * (len(c) + 2) for c in columns) + "|"
        rows = [col_line, sep_line]
        for row in result:
            rows.append("    | " + " | ".join(str(x) for x in row) + " |")
        return "  • Results:\n" + "\n".join(rows)

    # Otherwise, simple list
    rows = "\n".join("    - " + ", ".join(map(str, row)) for row in result)
    return f"  • Results:\n{rows}"

def is_select_query(sql: str) -> bool:
    """Checks if the query is a read-only SELECT statement."""
    return sql.strip().lower().startswith('select')

def print_help(category: str = ""):
    print("\n📖 HELP")
    print("Type natural language questions, e.g.:")
    if category == "team":
        print("  - Show all employees in Portal team")
        print("  - Give me details of employee named John Smith")
        print("  - Count employees in EIS project")
    elif category == "process":
        print("  - Which process uses maximum memory?")
        print("  - List all processes run by 'root'")
        print("  - Show processes sorted by CPU usage")
    elif category == "system":
        print("  - What is the latest system metric entry?")
        print("  - Show average CPU usage")
        print("  - List all disk usage values")
    print("Type 'tables' to see available tables.")
    print("Type 'describe <table>' to see table schema.")
    print("Type 'columns <table>' to see table columns.")
    print("Type 'stats' for summary statistics (if applicable).")
    print("Type 'clear' to clear the screen.")
    print("Type 'help' to see this help message again.")
    print("Type 'exit' to quit the session.\n")

def clear_screen():
    os.system("cls" if os.name == "nt" else "clear")

# --- SESSION & HANDLER ---

class AIQueryHandler:
    """
    Manages the AI model, database connection, and user interaction for a specific category.
    """
    def __init__(self, category_key: str):
        self.category_key = category_key
        self.config = DB_CONFIGS[category_key]
        self.logger = logging.getLogger(self.category_key)
        self.llm = None
        self.chain = None
        self.db_conn = None

    def _initialize(self) -> bool:
        """Initializes components once, lazily."""
        try:
            print(f"\n🔗 Initializing '{self.config['name']}' handler...")
            self.llm = OllamaLLM(model="mistral:7b-instruct-q4_K_M", temperature=0)
            db_cfg = self.config['db_config']
            uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"
            db_for_llm = SQLDatabase.from_uri(uri, include_tables=self.config.get("include_tables"))
            self.chain = create_sql_query_chain(self.llm, db_for_llm)
            self.db_conn = pymysql.connect(**db_cfg)
            print("✅ Initialization complete.")
            return True
        except Exception as e:
            print(f"❌ Initialization failed: {e}")
            self.logger.error(f"Initialization failed: {e}", exc_info=True)
            return False

    def _get_table_names(self) -> List[str]:
        with self.db_conn.cursor() as cursor:
            cursor.execute("SHOW TABLES")
            tables = [row[0] for row in cursor.fetchall()]
        return tables

    def _get_table_columns(self, table: str) -> List[str]:
        with self.db_conn.cursor() as cursor:
            cursor.execute(f"DESCRIBE `{table}`")
            columns = [row[0] for row in cursor.fetchall()]
        return columns

    def _describe_table(self, table: str) -> List[tuple]:
        with self.db_conn.cursor() as cursor:
            cursor.execute(f"DESCRIBE `{table}`")
            result = cursor.fetchall()
        return result

    def _run_sql_query(self, sql_query: str) -> Optional[tuple]:
        """
        Safely runs a read-only SQL query. Rejects any non-SELECT statements.
        """
        # --- MODIFICATION START ---
        # 1. Enforce read-only access by rejecting any query that is not a SELECT statement.
        if not is_select_query(sql_query):
            print("  • ❗ Error: Only read-only (SELECT) queries are allowed.")
            self.logger.warning(f"Blocked a non-SELECT query: {sql_query}")
            return None, None
        # --- MODIFICATION END ---

        try:
            with self.db_conn.cursor() as cursor:
                cursor.execute(sql_query)
                res = cursor.fetchall()
                columns = [desc[0] for desc in cursor.description] if cursor.description else None

            # --- MODIFICATION START ---
            # 2. The commit() logic has been removed entirely to prevent any possibility of writing to the DB.
            # --- MODIFICATION END ---
            return res, columns
        except pymysql.err.ProgrammingError as e:
            if "doesn't exist" in str(e):
                print("  • Error: The table you requested does not exist in this category.")
            elif "You have an error in your SQL syntax" in str(e):
                print("  • Error: The generated SQL was not valid. Please rephrase your question.")
            else:
                print(f"  • SQL Error: {e}")
            self.logger.error(f"SQL error: {e}", exc_info=True)
            return None, None
        except Exception as e:
            print(f"  • Error running SQL: {e}")
            self.logger.error(f"SQL execution error: {e}\n{traceback.format_exc()}", exc_info=True)
            return None, None

    def _summary_stats(self):
        # Try to provide a summary for the current category
        try:
            table = self._get_table_names()[0]
            with self.db_conn.cursor() as cursor:
                cursor.execute(f"SELECT COUNT(*) FROM `{table}`")
                count = cursor.fetchone()[0]
            print(f"  • Table '{table}' has {count} rows.")
        except Exception:
            print("  • Cannot compute stats for this category.")

    def start_session(self) -> None:
        """Starts the interactive question-and-answer session."""
        if not self._initialize():
            return

        print(f"\n✅ Ask questions about '{self.config['name']}'. Type 'exit' to return.\n")
        print_help(self.category_key)
        while True:
            try:
                q = input("You > ").strip()
            except (KeyboardInterrupt, EOFError):
                print("\nExiting session.")
                break
            if not q:
                continue
            lq = q.lower()
            if lq in ("exit", "quit"):
                break
            elif lq == "help":
                print_help(self.category_key)
                continue
            elif lq == "clear":
                clear_screen()
                continue
            elif lq == "tables":
                tables = self._get_table_names()
                print(f"  • Tables available: {', '.join(tables)}")
                continue
            elif lq.startswith("describe "):
                table = q.split(" ", 1)[1].strip()
                try:
                    desc = self._describe_table(table)
                    print("  • Table schema:")
                    print("    | Field | Type | Null | Key | Default | Extra |")
                    print("    |-------|------|------|-----|---------|-------|")
                    for row in desc:
                        print("    | " + " | ".join(str(x) for x in row) + " |")
                except Exception as e:
                    print(f"  • Error: {e}")
                continue
            elif lq.startswith("columns "):
                table = q.split(" ", 1)[1].strip()
                try:
                    cols = self._get_table_columns(table)
                    print(f"  • Columns in '{table}': {', '.join(cols)}")
                except Exception as e:
                    print(f"  • Error: {e}")
                continue
            elif lq == "stats":
                self._summary_stats()
                continue

            try:
                self.logger.info(f"Question: {q}")
                # Chain invocation and LLM SQL generation
                raw_sql = self.chain.invoke({"question": q})
                sql = clean_sql(raw_sql)
                print(f"\n🧠 SQL Generated:\n{sql}\n")
                self.logger.info(f"Generated SQL: {sql}")

                result, columns = self._run_sql_query(sql)
                if result is not None:
                    answer = format_answer(result, columns)
                    print(f"📢 Answer:\n{answer}\n")
            except Exception as e:
                print(f"\n❌ An error occurred: {e}\n")
                self.logger.error(f"Error processing question '{q}': {e}\n{traceback.format_exc()}", exc_info=True)
                if "connection" in str(e).lower():
                    print("Attempting to reconnect...")
                    self._initialize()

        if self.db_conn:
            self.db_conn.close()
            print(f"🔌 Connection to '{self.config['name']}' closed.")

# --- MAIN PROGRAM ---

def main():
    """Main function to run the Unified Info Assistant."""
    print("🔍 Unified Info Assistant: Process | System | Team\n")
    handlers = {key: AIQueryHandler(key) for key in DB_CONFIGS}

    while True:
        print("Please choose a category or type 'exit' to quit:")
        for c in list(DB_CONFIGS.keys()):
            print(f"  - {c}")
        try:
            choice = input("\nEnter category: ").strip().lower()
        except (KeyboardInterrupt, EOFError):
            print("\n👋 Bye!")
            break

        if choice == "exit":
            print("\n👋 Bye!")
            break

        if choice in handlers:
            handler = handlers[choice]
            handler.start_session()
        else:
            print("❌ Invalid choice. Please try again.\n")

if __name__ == "__main__":
    main()
