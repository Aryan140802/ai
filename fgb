import os
import re
import logging
import subprocess
import pymysql
import traceback
from typing import List, Optional, Dict, Any
from datetime import datetime
import json

from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain
from langchain.prompts import PromptTemplate

# --- CONFIGURATION ---

DB_CONFIGS = {
    "process": {
        "name": "FAR Details",
        "db_config": {
            "host": "localhost", "user": "root", "password": "root123", "database": "EIS_n"
        },
        "include_tables": ["FarDetailsAll"],
    },
    "system": {
        "name": "System Metrics",
        "db_config": {
            "host": "localhost", "user": "ray", "password": "", "database": "system_monitor_db"
        },
        "include_tables": None,
    },
    "team": {
        "name": "Team Info",
        "db_config": {
            "host": "localhost", "user": "root", "password": "root123", "database": "EIS_n"
        },
        "include_tables": ["UserMaster"],
    }
}

SAFE_COMMANDS = {
    "cpu": "top -bn1 | grep 'Cpu(s)'",
    "cpu_util": "mpstat 1 1 | grep 'Average' || grep 'all' /proc/stat",
    "memory": "free -m",
    "disk": "df -h",
    "uptime": "uptime",
    "load": "cat /proc/loadavg",
    "processes": "ps aux --sort=-%cpu | head -20",
    "netstat": "ss -tuln | head -20",
    "iostat": "iostat -x 1 1",
    "vmstat": "vmstat 1 2",
    "who": "who",
    "whoami": "whoami",
    "date": "date",
    "hostname": "hostname",
    "uname": "uname -a",
    "lscpu": "lscpu",
    "lsblk": "lsblk",
    "mount": "mount | grep -E '^/dev'",
    "systemctl": "systemctl list-units --type=service --state=active | head -20",
    "pidof": "pidof {process_name}",
    "pgrep": "pgrep -fl {process_name}",
    "ps_pid": "ps -C {process_name} -o pid,cmd --no-headers",
    "topcpu": "ps -eo pid,comm,%cpu,%mem --sort=-%cpu | head -n 11",
    "topmem": "ps -eo pid,comm,%mem,%cpu --sort=-%mem | head -n 11",
    "psaux_grep": "ps aux | grep {process_name} | grep -v grep",
    "top": "top -b -n1 | head -20",
}

BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b"
]

# Custom prompt template to avoid LIKE clauses
CUSTOM_PROMPT = PromptTemplate.from_template("""
You are a MySQL expert. Given an input question, create a syntactically correct MySQL query to run.
Unless the user specifically asks for pattern matching, you should always use exact matches (=) instead of LIKE in your queries.
Never query for all columns from a table. You must query only the columns that are needed to answer the question.

Use the following format:
Question: "Question here"
SQLQuery: "SQL Query to run"

Only use the following tables:
{table_info}

Question: {question}
SQLQuery:""")

logging.basicConfig(
    filename=os.path.expanduser("~/.unified_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def detect_query_type(question: str) -> str:
    question = question.lower()
    system_patterns = [
        r'\b(cpu|memory|ram|disk|storage|uptime|load|processes|running|network|port|iostat|vmstat)\b',
        r'\b(show|check|what|how much|current|live|real.?time)\b.*\b(cpu|memory|disk|load|system|server)\b',
        r'\b(top|ps|free|df|netstat|who|hostname|uname)\b',
        r'\bsystem\b.*\b(status|info|usage|performance|health)\b',
        r'\b(server|linux|unix)\b.*\b(status|info|performance)\b',
        r'\bhow\s+(much|many)\b.*\b(cpu|memory|disk|process|running)\b'
    ]
    team_patterns = [
        r'\b(team|user|employee|staff|member|person|people)\b',
        r'\b(show|list|find|get|count|search)\b.*\b(employee|user|team|staff)\b',
        r'\b(who|which\s+user|which\s+employee)\b',
        r'\bname.*\b(john|smith|portal|eis|project)\b',
        r'\b(portal|eis|project)\b.*\b(team|user|employee)\b'
    ]
    process_patterns = [
        r'\b(process|pid|far|details)\b.*\b(database|table|stored|history|log)\b',
        r'\b(which|what|show|list)\b.*\bprocess\b.*\b(memory|cpu|usage|database)\b',
        r'\bfar\s*details\b',
        r'\bprocess\b.*\b(sorted|maximum|minimum|highest|lowest)\b',
        r'\b(database|table|stored)\b.*\bprocess\b'
    ]
    system_db_patterns = [
        r'\b(metrics|monitoring|historical|logged|stored)\b.*\b(cpu|memory|disk|system)\b',
        r'\b(average|total|sum|count|maximum|minimum)\b.*\b(cpu|memory|disk|usage)\b',
        r'\b(system|server)\b.*\b(metrics|monitoring|database|table|history)\b',
        r'\b(latest|recent|last|previous)\b.*\b(system|metric|entry)\b'
    ]
    for pattern in system_patterns:
        if re.search(pattern, question):
            return "system"
    for pattern in team_patterns:
        if re.search(pattern, question):
            return "team"
    for pattern in process_patterns:
        if re.search(pattern, question):
            return "process"
    for pattern in system_db_patterns:
        if re.search(pattern, question):
            return "system_db"
    words = question.split()
    if any(word in ['current', 'now', 'live', 'real-time', 'status', 'running'] for word in words):
        if any(word in ['cpu', 'memory', 'disk', 'process', 'system', 'server'] for word in words):
            return "system"
    if any(word in ['count', 'total', 'average', 'maximum', 'minimum', 'list', 'show', 'find'] for word in words):
        if any(word in ['employee', 'user', 'team', 'staff', 'member'] for word in words):
            return "team"
        elif any(word in ['process', 'pid', 'far'] for word in words):
            return "process"
        elif any(word in ['metric', 'monitoring', 'system', 'database'] for word in words):
            return "system_db"
    return "general"

def clean_sql(raw_sql: str) -> str:
    match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
    if match:
        sql = match.group(1)
    else:
        sql = re.sub(r"```", "", raw_sql)
        sql = re.sub(r"^(.*?)(SELECT|INSERT|UPDATE|DELETE|WITH)", r"\2", sql, flags=re.IGNORECASE | re.DOTALL)
    
    # Replace all LIKE clauses with exact matches
    sql = re.sub(r"LIKE\s+['\"](%?)([^%'\" ]+)(%?)['\"]", 
                 lambda m: f"= '{m.group(2)}'", 
                 sql, flags=re.IGNORECASE)
    
    return sql.strip().rstrip(";")

def format_answer(result: List[tuple], columns: Optional[List[str]] = None) -> str:
    if not result:
        return "No data found for your request."
    if len(result) == 1 and len(result[0]) == 1:
        return f"Result: {result[0][0]}"
    if columns and len(result) <= 10:
        output = []
        col_widths = [max(len(str(col)), max(len(str(row[i])) for row in result)) for i, col in enumerate(columns)]
        header = " | ".join(col.ljust(width) for col, width in zip(columns, col_widths))
        separator = "-+-".join("-" * width for width in col_widths)
        output.append(header)
        output.append(separator)
        for row in result[:10]:
            formatted_row = " | ".join(str(val).ljust(width) for val, width in zip(row, col_widths))
            output.append(formatted_row)
        if len(result) > 10:
            output.append(f"... and {len(result) - 10} more rows")
        return "\n".join(output)
    rows = []
    for row in result[:20]:
        rows.append(" | ".join(str(val) for val in row))
    if len(result) > 20:
        rows.append(f"... and {len(result) - 20} more rows")
    return "\n".join(rows)

def is_select_query(sql: str) -> bool:
    return sql.strip().lower().startswith('select')

def clear_screen():
    os.system("cls" if os.name == "nt" else "clear")

class UnifiedAIAssistant:
    def __init__(self):
        self.llm = None
        self.db_handlers = {}
        self.initialized = False
        self.chat_history = []

    def initialize(self):
        try:
            print("ğŸ”§ Initializing AI Assistant...")
            self.llm = OllamaLLM(model="mistral:latest", temperature=0.1)
            for category, config in DB_CONFIGS.items():
                try:
                    db_cfg = config['db_config']
                    uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"
                    db_for_llm = SQLDatabase.from_uri(uri, include_tables=config.get("include_tables"))
                    
                    # Use our custom prompt that instructs to avoid LIKE
                    chain = create_sql_query_chain(self.llm, db_for_llm, prompt=CUSTOM_PROMPT)
                    
                    db_conn = pymysql.connect(**db_cfg)
                    self.db_handlers[category] = {
                        'chain': chain,
                        'connection': db_conn,
                        'config': config
                    }
                    print(f"âœ… {config['name']} database connected")
                except Exception as e:
                    print(f"âš ï¸  Failed to connect to {config['name']}: {e}")
                    logger.error(f"DB connection failed for {category}: {e}")
            self.initialized = True
            print("âœ… AI Assistant initialized successfully!")
            return True
        except Exception as e:
            print(f"âŒ Initialization failed: {e}")
            logger.error(f"Initialization failed: {e}", exc_info=True)
            return False

    def save_feedback(self, question, answer, feedback):
        data = {
            "question": question,
            "answer": answer,
            "feedback": feedback,
            "timestamp": datetime.now().isoformat()
        }
        try:
            with open("feedback_log.jsonl", "a") as f:
                f.write(json.dumps(data) + "\n")
        except Exception as e:
            logger.error(f"Failed to save feedback: {e}")

    def find_relevant_feedback(self, question):
        try:
            with open("feedback_log.jsonl", "r") as f:
                lines = f.readlines()
            for line in lines[::-1]:
                entry = json.loads(line)
                if entry["question"].strip().lower() in question.strip().lower():
                    return entry["feedback"]
        except Exception:
            pass
        return None

    def run_system_command(self, question: str) -> str:
        question_lower = question.lower()
        command_map = {
            'cpu': ['cpu usage', 'cpu percent', 'cpu utilization', 'cpu load', 'processor usage', 'processor utilization'],
            'cpu_util': ['cpu stat', 'cpu statistics', 'cpu total', 'average cpu'],
            'memory': ['memory usage', 'ram usage', 'mem usage'],
            'disk': ['disk usage', 'storage usage', 'space usage', 'filesystem'],
            'uptime': ['uptime', 'boot time', 'system running'],
            'load': ['load average', 'system load'],
            'processes': ['process list', 'running processes', 'ps', 'processes'],
            'netstat': ['network', 'open port', 'connection', 'port', 'socket'],
            'iostat': ['io', 'input', 'output'],
            'vmstat': ['virtual', 'vm'],
            'who': ['logged user', 'who is logged in', 'session'],
            'hostname': ['hostname', 'host name', 'server name'],
            'uname': ['kernel version', 'os version', 'uname'],
            'lscpu': ['cpu info', 'processor info'],
            'lsblk': ['block device', 'disk device'],
            'mount': ['mounted device', 'mount point'],
            'systemctl': ['service', 'daemon', 'systemctl'],
            'pidof': ['pid of', 'process id of', 'find pid', 'get pid'],
            'pgrep': ['pid for', 'pgrep', 'process name'],
            'ps_pid': ['process id', 'ps -C'],
            'psaux_grep': ['search process', 'grep process', 'find process'],
            'topcpu': ['top cpu', 'most cpu', 'highest cpu', 'max cpu', 'cpu hog'],
            'topmem': ['top memory', 'most memory', 'highest memory', 'max memory', 'memory hog'],
            'top': ['top'],
        }
        process_name = None
        cmd = None
        pid_patterns = [
            (r'(?:pid of|process id of|get pid for|find pid for)\s+([a-zA-Z0-9_\-\.]+)', 'pidof'),
            (r'(?:pid for|pgrep|process name)\s+([a-zA-Z0-9_\-\.]+)', 'pgrep'),
            (r'(?:process id|ps -c)\s+([a-zA-Z0-9_\-\.]+)', 'ps_pid'),
            (r'(?:search process|grep process|find process)\s+([a-zA-Z0-9_\-\.]+)', 'psaux_grep')
        ]
        for pattern, key in pid_patterns:
            match = re.search(pattern, question_lower)
            if match:
                process_name = match.group(1)
                cmd = SAFE_COMMANDS[key].format(process_name=process_name)
                break
        if not cmd:
            matched_cmd = None
            for cmd_key, keywords in command_map.items():
                if any(keyword in question_lower for keyword in keywords):
                    if cmd_key in ['pidof', 'pgrep', 'ps_pid', 'psaux_grep']:
                        proc_match = re.search(r'(?:pid of|get pid for|pgrep|process id for|process id|ps -c|search process|grep process|find process)\s+([a-zA-Z0-9_\-\.]+)', question_lower)
                        if proc_match:
                            process_name = proc_match.group(1)
                            cmd = SAFE_COMMANDS[cmd_key].format(process_name=process_name)
                            matched_cmd = cmd
                            break
                        else:
                            continue
                    else:
                        matched_cmd = SAFE_COMMANDS.get(cmd_key)
                        break
            if not matched_cmd:
                matched_cmd = SAFE_COMMANDS['processes']
            if not cmd:
                cmd = matched_cmd
        try:
            output = subprocess.getoutput(cmd)
            context = ""
            for turn in self.chat_history[-5:]:
                context += f"User: {turn['user']}\nAssistant: {turn['assistant']}\n"
            context += f"User: {question}\nAssistant:"
            context += f"""
Here's the system command output:
{output}

Please provide a clear, helpful response that directly answers the user's question based on this system information. Be concise but informative. Focus on what the user specifically asked about.
"""
            feedback = self.find_relevant_feedback(question)
            if feedback:
                context += f"\nNote: Previously, a user provided this correction for a similar question: '{feedback}'"
            ai_response = self.llm.invoke(context)
            self.chat_history.append({"user": question, "assistant": ai_response})
            return ai_response
        except Exception as e:
            logger.error(f"System command error: {e}")
            return f"âŒ Error getting system information: {e}"

    def query_database(self, question: str, category: str) -> str:
        if category not in self.db_handlers:
            return f"âŒ Database category '{category}' not available."
        handler = self.db_handlers[category]
        try:
            # Add instruction to avoid LIKE in the prompt
            modified_question = f"{question} (Note: Please use exact matches with = instead of LIKE in SQL queries)"
            raw_sql = handler['chain'].invoke({"question": modified_question})
            sql = clean_sql(raw_sql)
            print(sql)
            if not is_select_query(sql):
                return "ğŸš« Only SELECT queries are allowed for security."
            with handler['connection'].cursor() as cursor:
                print("connection established")
                cursor.execute(sql)
                result = cursor.fetchall()
                print(result)
                columns = [desc[0] for desc in cursor.description] if cursor.description else None
            if not result:
                return "No data found matching your query."
            print(result)
            formatted_result = format_answer(result, columns)
            context = ""
            for turn in self.chat_history[-5:]:
                context += f"User: {turn['user']}\nAssistant: {turn['assistant']}\n"
            context += f"""User: {question}
Assistant:

Database query results:
{formatted_result}

Please provide a clear, natural language response that directly answers the user's question based on this data. Make it conversational and helpful."""
            feedback = self.find_relevant_feedback(question)
            if feedback:
                context += f"\nNote: Previously, a user provided this correction for a similar question: '{feedback}'"
            ai_interpretation = self.llm.invoke(context)
            self.chat_history.append({"user": question, "assistant": ai_interpretation})
            return ai_interpretation
        except Exception as e:
            logger.error(f"Database query error: {e}")
            return f"âŒ Unable to retrieve that information: {e}"

    def general_ai_response(self, question: str) -> str:
        try:
            context = ""
            for turn in self.chat_history[-5:]:
                context += f"User: {turn['user']}\nAssistant: {turn['assistant']}\n"
            context += f"""User: {question}
Assistant:
You are a helpful AI assistant with expertise in system administration, databases, and general technical knowledge.

Please provide a clear, helpful, and accurate response. If this is a technical question, provide practical advice. If it's a general question, be informative and conversational."""
            feedback = self.find_relevant_feedback(question)
            if feedback:
                context += f"\nNote: Previously, a user provided this correction for a similar question: '{feedback}'"
            response = self.llm.invoke(context)
            self.chat_history.append({"user": question, "assistant": response})
            return response
        except Exception as e:
            logger.error(f"AI response error: {e}")
            return f"âŒ Unable to process your question: {e}"

    def process_question(self, question: str) -> str:
        if not self.initialized:
            return "âŒ Assistant not initialized. Please restart."
        if is_dangerous(question):
            return "ğŸš« Question blocked for security reasons."
        query_type = detect_query_type(question)
        if query_type == "system":
            return self.run_system_command(question)
        elif query_type in ["team", "process", "system_db"]:
            db_category = query_type if query_type != "system_db" else "system"
            return self.query_database(question, db_category)
        else:
            return self.general_ai_response(question)

    def show_help(self):
        help_text = """
ğŸ“– UNIFIED AI ASSISTANT HELP

ğŸ–¥ï¸  SYSTEM COMMANDS:
  - "Show CPU usage" / "What's the CPU load?"
  - "Check memory usage" / "How much RAM is used?"
  - "Show disk space" / "What's the disk usage?"
  - "Show running processes" / "List active processes"
  - "System uptime" / "How long has system been running?"
  - "Show network connections" / "What ports are open?"
  - "PID of httpd" / "Get PID for sshd"
  - "Top CPU process" / "Top memory process"

ğŸ’¾ DATABASE QUERIES:
  Team/User Info:
  - "Show all employees in Portal team"
  - "Give me details of employee named John"
  - "Count employees in EIS project"

  Process Info:
  - "Which process uses maximum memory?"
  - "List all processes run by root"
  - "Show processes sorted by CPU usage"

  System Metrics:
  - "What is the latest system metric?"
  - "Show average CPU usage from database"
  - "List all disk usage values"

ğŸ¤– GENERAL AI:
  - Ask any general question
  - Get explanations and help
  - Technical assistance

ğŸ’¡ COMMANDS:
  - 'help' - Show this help
  - 'clear' - Clear screen
  - 'status' - Show system status
  - 'exit' - Quit assistant

ğŸ”’ SECURITY:
  - Only safe, read-only operations allowed
  - Dangerous commands are blocked
  - Database writes are prevented
  - Uses exact matches in database queries (no LIKE)
        """
        print(help_text)

    def show_status(self):
        print("ğŸ” SYSTEM STATUS")
        print(f"ğŸ“… Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"ğŸ¤– AI Model: Initialized ({'âœ…' if self.initialized else 'âŒ'})")
        print(f"ğŸ’¾ Database Connections: {len(self.db_handlers)}")
        for category, handler in self.db_handlers.items():
            status = "âœ…" if handler['connection'].open else "âŒ"
            print(f"   - {handler['config']['name']}: {status}")

    def start_interactive_session(self):
        if not self.initialize():
            return
        clear_screen()
        print("ğŸ¤– AI Assistant Ready")
        print("Ask me anything about your system, databases, or general questions...")
        print("Type 'exit' to quit\n")
        while True:
            try:
                question = input("ğŸ’¬ ").strip()
                if not question:
                    continue
                question_lower = question.lower()
                if question_lower in ['exit', 'quit', 'q']:
                    print("ğŸ‘‹ Goodbye!")
                    break
                elif question_lower == 'help':
                    self.show_help()
                    continue
                elif question_lower == 'clear':
                    clear_screen()
                    continue
                elif question_lower == 'status':
                    self.show_status()
                    continue
                response = self.process_question(question)
                print(f"\n{response}\n")
                feedback = input("Was this answer helpful? (yes/no/correction): ")
                if feedback.lower() not in ['yes', 'y']:
                    self.save_feedback(question, response, feedback)
            except KeyboardInterrupt:
                print("\nğŸ‘‹ Goodbye!")
                break
            except Exception as e:
                print(f"\nâŒ Error: {e}")
                logger.error(f"Session error: {e}", exc_info=True)
        for handler in self.db_handlers.values():
            if handler['connection'].open:
                handler['connection'].close()
        print("Connection closed.")

def main():
    assistant = UnifiedAIAssistant()
    assistant.start_interactive_session()

if __name__ == "__main__":
    main()
