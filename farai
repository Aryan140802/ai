import os
import re
import logging
import pymysql
from typing import List, Optional
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

# --- FAR DETAILS CONFIGURATION ---
FAR_DB_CONFIG = {
    "name": "FAR Details",
    "db_config": {
        "host": "localhost", 
        "user": "readonly_user",
        "password": "readonly_pass", 
        "database": "EIS_n"
    },
    "include_tables": ["FarDetailsAll"],
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

# Setup logging
logging.basicConfig(
    filename=os.path.expanduser("~/.far_details_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    """Check if text contains dangerous patterns"""
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def clean_sql(raw_sql: str) -> str:
    """Clean and enhance SQL for LIKE operations"""
    match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
    if match:
        sql = match.group(1)
    else:
        sql = re.sub(r"```", "", raw_sql)
        sql = re.sub(r"^(.*?)(SELECT|WITH)", r"\2", sql, flags=re.IGNORECASE | re.DOTALL)
    
    # Convert exact matches to LIKE for text fields (except Far_Id)
    sql = re.sub(r"(\w+)\s*=\s*'([^']*)'", 
                lambda m: f"{m.group(1)} = '{m.group(2)}'" if m.group(1).lower() == 'far_id' 
                         else f"{m.group(1)} LIKE '%{m.group(2)}%'", 
                sql, flags=re.IGNORECASE)
    
    sql = re.sub(r"(\w+)\s*=\s*\"([^\"]*)\"", 
                lambda m: f"{m.group(1)} = \"{m.group(2)}\"" if m.group(1).lower() == 'far_id' 
                         else f"{m.group(1)} LIKE \"%{m.group(2)}%\"", 
                sql, flags=re.IGNORECASE)
    
    return sql.strip().rstrip(";")

def format_answer(result: List[tuple], columns: Optional[List[str]] = None) -> str:
    """Format database results for display"""
    if not result:
        return "No results found."
    
    # Special formatting for common FAR queries
    if columns and len(result) == 1 and 'far_id' in [col.lower() for col in columns]:
        output = []
        for col, val in zip(columns, result[0]):
            output.append(f"{col}: {val}")
        return "\n".join(output)
    
    if columns and len(result) <= 10:
        output = []
        col_widths = [max(len(str(col)), max(len(str(row[i])) for row in result)) 
                     for i, col in enumerate(columns)]
        header = " | ".join(col.ljust(width) for col, width in zip(columns, col_widths))
        separator = "-+-".join("-" * width for width in col_widths)
        output.append(header)
        output.append(separator)
        for row in result[:10]:
            formatted_row = " | ".join(str(val).ljust(width) for val, width in zip(row, col_widths))
            output.append(formatted_row)
        if len(result) > 10:
            output.append(f"... and {len(result) - 10} more rows")
        return "\n".join(output)
    
    rows = []
    for row in result[:20]:
        rows.append(" | ".join(str(val) for val in row))
    if len(result) > 20:
        rows.append(f"... and {len(result) - 20} more rows")
    return "\n".join(rows)

def is_readonly_query(sql: str) -> bool:
    """Check if query is a safe SELECT query"""
    sql_lower = sql.strip().lower()
    
    # Must start with SELECT, WITH (for CTEs), or be a simple SHOW/DESCRIBE
    if not sql_lower.startswith(('select', 'with', 'show', 'describe', 'explain')):
        return False
    
    # Check for any blocked SQL keywords in the query
    blocked_keywords = [
        'insert', 'update', 'delete', 'drop', 'alter', 'create',
        'truncate', 'grant', 'revoke', 'replace', 'merge', ';'
    ]
    
    for keyword in blocked_keywords:
        if re.search(rf'\b{keyword}\b', sql_lower):
            return False
            
    return True

def validate_far_columns(sql: str) -> bool:
    """Validate that only existing FAR Details columns are queried"""
    allowed_columns = {
        'far_id', 'subject', 'status', 'created', 'expires',
        'requested_source', 'requested_destination', 'requested_service',
        'requested_source_nat', 'requested_destination_nat',
        'requested_port_translation', 'change_source', 'change_destination',
        'change_service', 'change_source_nat', 'change_destination_nat',
        'translated_destination', 'translated_service',
        'dependent_application', 'permanent_rule', 'zone',
        'created_op', 'expires_op'
    }
    
    # Extract column names from query
    select_match = re.search(r'select\s+(.*?)\s+from', sql.lower(), re.DOTALL)
    if not select_match:
        return False
        
    columns_part = select_match.group(1)
    if columns_part.strip() == '*':
        return True
        
    columns = []
    for col in columns_part.split(','):
        col = col.strip().split()[0].strip('`"[]')
        columns.append(col)
    
    # Check all columns are allowed
    return all(col in allowed_columns for col in columns)

class FarDetailsAssistant:
    def __init__(self):
        self.llm = None
        self.db_handler = None
        self.initialized = False

    def initialize(self):
        """Initialize the FAR Details Assistant"""
        try:
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.1)
            
            db_cfg = FAR_DB_CONFIG['db_config']
            uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"
            db_for_llm = SQLDatabase.from_uri(uri, include_tables=FAR_DB_CONFIG.get("include_tables"))
            
            chain = create_sql_query_chain(self.llm, db_for_llm)
            db_conn = pymysql.connect(**db_cfg)
            
            self.db_handler = {
                'chain': chain,
                'connection': db_conn,
                'config': FAR_DB_CONFIG
            }
            
            self.initialized = True
            return True
            
        except Exception as e:
            logger.error(f"Initialization failed: {e}", exc_info=True)
            return False

    def query_far_details(self, question: str) -> str:
        """Query FAR details database with table-specific optimizations"""
        if not self.db_handler:
            return "Database connection not available."
        
        try:
            # Enhanced prompt with table-specific guidance
            enhanced_question = f"""
            {question}
            
            Database Schema:
            - Table: FarDetailsAll
            - Columns:
              * Far_Id (integer, primary key) - use exact matches
              * Subject, Status, Created, Expires (text)
              * Requested_* (network source/destination/service/NAT)
              * Change_* (modified network parameters)
              * Translated_* (final network parameters)
              * Dependent_application, Permanent_Rule, ZONE
            
            Query Guidelines:
            1. For Far_Id use exact matches: Far_Id = 123
            2. For text fields use LIKE: Status LIKE '%Approved%'
            3. Keep queries simple and focused
            4. Only query existing columns
            """
            
            raw_sql = self.db_handler['chain'].invoke({"question": enhanced_question})
            sql = clean_sql(raw_sql)
            
            # Validate the query
            if not is_readonly_query(sql):
                return "Error: Only read-only queries are allowed."
                
            if not validate_far_columns(sql):
                return "Error: Query contains invalid columns for FAR Details."
            
            with self.db_handler['connection'].cursor() as cursor:
                cursor.execute(sql)
                result = cursor.fetchall()
                columns = [desc[0] for desc in cursor.description] if cursor.description else None
            
            if not result:
                return "No matching FAR records found."
            
            formatted_result = format_answer(result, columns)
            
            # Get interpretation of results
            context = f"""
            Question about FAR details: {question}
            
            Query Results:
            {formatted_result}
            
            Provide a concise answer focusing on:
            - Key identifiers (Far_Id if present)
            - Current status and dates
            - Important network parameters
            - Any notable details from Subject field
            """
            
            return self.llm.invoke(context)
            
        except pymysql.Error as e:
            logger.error(f"Database error: {e}")
            return f"Database error: {str(e)}"
        except Exception as e:
            logger.error(f"Query processing error: {e}")
            return f"Error processing request: {str(e)}"

    def process_question(self, question: str) -> str:
        """Process all questions as FAR-related queries"""
        if not self.initialized:
            return "Assistant not ready. Please try again later."
        
        if is_dangerous(question):
            return "Invalid request."
        
        return self.query_far_details(question)

    def start_interactive_session(self):
        """Start interactive session"""
        if not self.initialize():
            return
        
        print("FAR Details Assistant ready. Enter your query or 'exit' to quit.")
        
        while True:
            try:
                question = input("FAR Query: ").strip()
                if not question:
                    continue
                
                if question.lower() in ['exit', 'quit', 'q']:
                    break
                
                response = self.process_question(question)
                print(f"\n{response}\n")
                    
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(f"Error: {e}")
                logger.error(f"Session error: {e}", exc_info=True)
        
        if self.db_handler and self.db_handler['connection'].open:
            self.db_handler['connection'].close()

def main():
    assistant = FarDetailsAssistant()
    assistant.start_interactive_session()

if __name__ == "__main__":
    main()
