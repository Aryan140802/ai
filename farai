import os
import re
import logging
import pymysql
import traceback
from typing import List, Optional, Dict, Any
from datetime import datetime, date, timedelta
import json

from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

today_date = date.today()

# --- FAR DETAILS CONFIGURATION ---
FAR_DB_CONFIG = {
    "name": "FAR Details",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["FarDetailsAll"],
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

def get_date_context():
    """Generate comprehensive date context for better LLM understanding"""
    current_date = date.today()
    current_year = current_date.year
    current_month = current_date.month
    next_year = current_year + 1
    prev_year = current_year - 1
    
    # Calculate next month
    if current_month == 12:
        next_month = 1
        next_month_year = next_year
    else:
        next_month = current_month + 1
        next_month_year = current_year
    
    # Calculate previous month
    if current_month == 1:
        prev_month = 12
        prev_month_year = prev_year
    else:
        prev_month = current_month - 1
        prev_month_year = current_year
    
    return {
        'current_date': current_date.strftime('%Y-%m-%d'),
        'current_year': current_year,
        'current_month': current_month,
        'next_year': next_year,
        'prev_year': prev_year,
        'next_month': next_month,
        'next_month_year': next_month_year,
        'prev_month': prev_month,
        'prev_month_year': prev_month_year,
        'month_names': {
            1: 'January', 2: 'February', 3: 'March', 4: 'April',
            5: 'May', 6: 'June', 7: 'July', 8: 'August',
            9: 'September', 10: 'October', 11: 'November', 12: 'December'
        }
    }

# Enhanced SQL Generation Prompt Template with comprehensive date handling
def get_sql_generation_prompt():
    date_ctx = get_date_context()
    
    return f"""You are an expert SQL query generator for a FAR (Firewall Access Request) database.

**CURRENT DATE CONTEXT:**
- Today's date: {date_ctx['current_date']}
- Current year: {date_ctx['current_year']}
- Current month: {date_ctx['current_month']} ({date_ctx['month_names'][date_ctx['current_month']]})
- Next year: {date_ctx['next_year']}
- Previous year: {date_ctx['prev_year']}
- Next month: {date_ctx['next_month']} ({date_ctx['month_names'][date_ctx['next_month']]}) in year {date_ctx['next_month_year']}
- Previous month: {date_ctx['prev_month']} ({date_ctx['month_names'][date_ctx['prev_month']]}) in year {date_ctx['prev_month_year']}

**Schema definition:**
+----------------------------+----------+------+-----+---------+-------+
| Field                      | Type     | Null | Key | Default | Extra |
+----------------------------+----------+------+-----+---------+-------+
| Far_Id                     | int      | NO   | PRI | NULL    |       |
| Subject                    | longtext | YES  |     | NULL    |       |
| Status                     | longtext | NO   |     | NULL    |       |
| Created                    | longtext | NO   |     | NULL    |       |
| Expires                    | longtext | YES  |     | NULL    |       |
| Requested_Source           | longtext | NO   |     | NULL    |       |
| Requested_Destination      | longtext | NO   |     | NULL    |       |
| Requested_Service          | longtext | NO   |     | NULL    |       |
| Requested_Source_NAT       | longtext | YES  |     | NULL    |       |
| Requested_Destination_NAT  | longtext | YES  |     | NULL    |       |
| Requested_Port_Translation | longtext | YES  |     | NULL    |       |
| Change_Source              | longtext | YES  |     | NULL    |       |
| Change_Destination         | longtext | YES  |     | NULL    |       |
| Change_Service             | longtext | YES  |     | NULL    |       |
| Change_Source_NAT          | longtext | YES  |     | NULL    |       |
| Change_Destination_NAT     | longtext | YES  |     | NULL    |       |
| Translated_Destination     | longtext | YES  |     | NULL    |       |
| Translated_Service         | longtext | YES  |     | NULL    |       |
| Dependent_application      | longtext | YES  |     | NULL    |       |
| Permanent_Rule             | longtext | YES  |     | NULL    |       |
| ZONE                       | longtext | YES  |     | NULL    |       |
| Created_op                 | longtext | YES  |     | NULL    |       |
| Expires_op                 | longtext | YES  |     | NULL    |       |
+----------------------------+----------+------+-----+---------+-------+

**CRITICAL DATE HANDLING INSTRUCTIONS:**
- Created and Expires columns store dates as TEXT in format 'YYYY-MM-DD HH:MM:SS'
- ALWAYS use STR_TO_DATE() function to convert text to date for ALL date comparisons
- For date comparisons, use: STR_TO_DATE(column_name, '%Y-%m-%d %H:%i:%s')
- Current date functions: CURDATE(), NOW()
- NEVER use LIMIT clause unless specifically requested with a number

**COMPREHENSIVE DATE QUERY PATTERNS:**
1. **Year-based queries:**
   - "this year" â†’ YEAR(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = {date_ctx['current_year']}
   - "next year" â†’ YEAR(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = {date_ctx['next_year']}
   - "previous year" / "last year" â†’ YEAR(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = {date_ctx['prev_year']}
   - "2024" or any specific year â†’ YEAR(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = 2024

2. **Month-based queries:**
   - "this month" â†’ MONTH(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = {date_ctx['current_month']} AND YEAR(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = {date_ctx['current_year']}
   - "next month" â†’ MONTH(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = {date_ctx['next_month']} AND YEAR(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = {date_ctx['next_month_year']}
   - "previous month" / "last month" â†’ MONTH(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = {date_ctx['prev_month']} AND YEAR(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = {date_ctx['prev_month_year']}
   - "January 2025" â†’ MONTH(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = 1 AND YEAR(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = 2025

3. **Day-based queries:**
   - "today" â†’ DATE(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = CURDATE()
   - "yesterday" â†’ DATE(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = DATE_SUB(CURDATE(), INTERVAL 1 DAY)
   - "tomorrow" â†’ DATE(STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s')) = DATE_ADD(CURDATE(), INTERVAL 1 DAY)

4. **Range queries:**
   - "last 30 days" â†’ STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s') >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
   - "next 30 days" â†’ STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s') BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL 30 DAY)
   - "between dates" â†’ STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s') BETWEEN 'start_date' AND 'end_date'

**DATABASE SCHEMA:**
Table: FarDetailsAll
Columns and their proper usage:
- Far_Id (INT): Unique identifier - use = for exact matches (e.g., Far_Id = 123)
- Subject (TEXT): Request title - use LIKE with % wildcards (e.g., Subject LIKE '%firewall%')
- Status (TEXT): Current status - use LIKE (e.g., Status LIKE '%active%' or Status LIKE '%resolved%')
- Created (TEXT): Creation timestamp - use STR_TO_DATE for date operations
- Expires (TEXT): Expiry timestamp - use STR_TO_DATE for date operations
- Requested_Source (TEXT): Source IPs - use LIKE (e.g., Requested_Source LIKE '%192.168%')
- Requested_Destination (TEXT): Destination IPs - use LIKE (e.g., Requested_Destination LIKE '%10.0%')
- Requested_Service (TEXT): Services/ports - use LIKE (e.g., Requested_Service LIKE '%80%')
- Dependent_application (TEXT): Applications - use LIKE (e.g., Dependent_application LIKE '%web%')
- ZONE (TEXT): Environment zone - use LIKE (e.g., ZONE LIKE '%PROD%')
- Permanent_Rule (TEXT): Permanent status - use LIKE (e.g., Permanent_Rule LIKE '%yes%')

**CRITICAL INSTRUCTIONS:**
1. ONLY generate SELECT statements - no INSERT, UPDATE, DELETE, DROP, etc.
2. Always use the exact table name: FarDetailsAll
3. For text searches, use LIKE with % wildcards for partial matches
4. For numeric IDs, use exact equality (=)
5. For dates, ALWAYS use STR_TO_DATE() function: STR_TO_DATE(column_name, '%Y-%m-%d %H:%i:%s')
6. Return ONLY the SQL query - no explanations, markdown, or additional text
7. Always try to find the requested prompt in all the columns with LIKE with % wildcards for partial matches
8. When instructions mention time periods, use the date context provided above
9. FAR means (Firewall access request)
10. This table contains firewall access request details from source to destination
11. Always try to find details across multiple columns if not found in one
12. DO NOT add LIMIT clause unless specifically requested with a number
13. Handle relative date terms (next year, this year, last year) using the current date context provided

**QUERY EXAMPLES WITH CURRENT DATE CONTEXT:**
- "123" â†’ SELECT * FROM FarDetailsAll WHERE Far_Id = 123
- "Show FAR 123" â†’ SELECT * FROM FarDetailsAll WHERE Far_Id = 123
- "Active FARs" â†’ SELECT * FROM FarDetailsAll WHERE Status LIKE '%active%'
- "Count resolved FARs" â†’ SELECT COUNT(*) as total_resolved FROM FarDetailsAll WHERE Status LIKE '%resolved%'
- "FARs in PROD zone" â†’ SELECT * FROM FarDetailsAll WHERE ZONE LIKE '%PROD%'
- "FARs created this year" â†’ SELECT * FROM FarDetailsAll WHERE YEAR(STR_TO_DATE(Created, '%Y-%m-%d %H:%i:%s')) = {date_ctx['current_year']}
- "FARs created next year" â†’ SELECT * FROM FarDetailsAll WHERE YEAR(STR_TO_DATE(Created, '%Y-%m-%d %H:%i:%s')) = {date_ctx['next_year']}
- "FARs expiring next month" â†’ SELECT * FROM FarDetailsAll WHERE MONTH(STR_TO_DATE(Expires, '%Y-%m-%d %H:%i:%s')) = {date_ctx['next_month']} AND YEAR(STR_TO_DATE(Expires, '%Y-%m-%d %H:%i:%s')) = {date_ctx['next_month_year']}
- "Count FARs created today" â†’ SELECT COUNT(*) FROM FarDetailsAll WHERE DATE(STR_TO_DATE(Created, '%Y-%m-%d %H:%i:%s')) = CURDATE()
- "List all FARs having Aadhar vault" â†’ SELECT * FROM FarDetailsAll WHERE CONCAT_WS(' ',Subject,Requested_Source,Requested_Destination,Dependent_application) LIKE '%Aadhar vault%'

**USER QUESTION:** {{question}}
"""

# Setup logging
logging.basicConfig(
    filename=os.path.expanduser("~/.far_details_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    """Check if text contains dangerous patterns"""
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def clean_and_fix_sql(raw_sql: str) -> str:
    """Clean and fix SQL with proper handling for different column types"""
    print(f"DEBUG - Raw SQL input: {repr(raw_sql)}")

    # Handle case where LLM returns descriptive text instead of SQL
    if "sql query" in raw_sql.lower() and "far_id" in raw_sql.lower():
        # Try to extract the actual ID from the text
        id_match = re.search(r"far[\s_]*id[\s_]*(\d+)", raw_sql.lower())
        if id_match:
            far_id = id_match.group(1)
            sql = f"SELECT * FROM FarDetailsAll WHERE Far_Id = {far_id}"
            print(f"DEBUG - Extracted FAR ID {far_id}, generated SQL: {sql}")
            return sql

    # Extract SQL from code block if present
    match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
    if match:
        sql = match.group(1).strip()
        print(f"DEBUG - Extracted from code block: {sql}")
    else:
        # Remove any markdown formatting
        sql = re.sub(r"```", "", raw_sql)

        # Look for SELECT statement more aggressively
        select_match = re.search(r"(SELECT.*?)(?:\n|$|;)", sql, re.IGNORECASE | re.DOTALL)
        if select_match:
            sql = select_match.group(1).strip()
            print(f"DEBUG - Extracted SELECT: {sql}")
        else:
            # Try to find SQL pattern starting with SELECT
            sql = re.sub(r"^(.*?)(SELECT|INSERT|UPDATE|DELETE|WITH)", r"\2", sql, flags=re.IGNORECASE | re.DOTALL)
            sql = sql.strip()

    # If we still don't have a proper SQL query, try to construct one
    if not sql.upper().strip().startswith('SELECT'):
        print(f"DEBUG - No valid SELECT found, trying to construct from: {raw_sql}")

        # Check if it's asking for a specific FAR ID
        far_id_match = re.search(r"(\d+)", raw_sql)
        if far_id_match and "far" in raw_sql.lower():
            far_id = far_id_match.group(1)
            sql = f"SELECT * FROM FarDetailsAll WHERE Far_Id = {far_id}"
            print(f"DEBUG - Constructed FAR ID query: {sql}")
        else:
            print(f"DEBUG - Could not construct valid SQL from: {raw_sql}")
            return raw_sql  # Return as-is and let validation catch it

    print(f"DEBUG - SQL before field processing: {sql}")

    # Don't convert everything to LIKE - be smart about it
    # Only convert text fields to LIKE, keep IDs and dates as exact matches
    text_fields = ['Subject', 'Status', 'Requested_Source', 'Requested_Destination',
                   'Requested_Service', 'Dependent_application', 'ZONE', 'Permanent_Rule']

    # Apply LIKE only to text fields, not to Far_Id or date fields
    for field in text_fields:
        # Convert = to LIKE for text fields only
        sql = re.sub(f"({field})\\s*=\\s*'([^']*)'", f"\\1 LIKE '%\\2%'", sql, flags=re.IGNORECASE)
        sql = re.sub(f"({field})\\s*=\\s*\"([^\"]*)\"", f"\\1 LIKE '%\\2%'", sql, flags=re.IGNORECASE)

    # Remove trailing semicolons
    sql = sql.strip().rstrip(";")

    # Remove any unwanted LIMIT clauses unless they were specifically requested
    # Only keep LIMIT if it was in the original question
    sql = re.sub(r'\s+LIMIT\s+\d+\s*$', '', sql, flags=re.IGNORECASE)

    print(f"DEBUG - Final cleaned SQL: {sql}")
    return sql

def format_query_results_natural(result: List[Dict], question: str) -> str:
    """Format database results in natural language"""
    if not result:
        return "I couldn't find any FAR records matching your criteria."

    # Handle single value results (like COUNT)
    if len(result) == 1 and len(result[0]) == 1:
        value = list(result[0].values())[0]
        if "count" in question.lower():
            return f"There are {value} FAR records matching your criteria."
        else:
            return f"The result is: {value}"

    # Handle single record
    if len(result) == 1:
        record = result[0]
        response = f"I found 1 FAR record:\n\n"

        # Format key information naturally
        if 'Far_Id' in record:
            response += f"ğŸ“‹ FAR ID: {record['Far_Id']}\n"
        if 'Subject' in record:
            response += f"ğŸ“ Subject: {record['Subject']}\n"
        if 'Status' in record:
            response += f"ğŸ”„ Status: {record['Status']}\n"
        if 'Created' in record:
            response += f"ğŸ“… Created: {record['Created']}\n"
        if 'Expires' in record:
            response += f"â° Expires: {record['Expires']}\n"
        if 'ZONE' in record:
            response += f"ğŸŒ Zone: {record['ZONE']}\n"
        if 'Requested_Source' in record:
            response += f"ğŸ”— Source: {record['Requested_Source']}\n"
        if 'Requested_Destination' in record:
            response += f"ğŸ¯ Destination: {record['Requested_Destination']}\n"
        if 'Requested_Service' in record:
            response += f"âš™ï¸ Service: {record['Requested_Service']}\n"
        if 'Dependent_application' in record:
            response += f"ğŸ“± Application: {record['Dependent_application']}\n"
        if 'Permanent_Rule' in record:
            response += f"ğŸ”’ Permanent Rule: {record['Permanent_Rule']}\n"

        return response.strip()

    # Handle multiple records - provide summary + tabular format
    response = f"I found {len(result)} FAR records matching your criteria:\n\n"

    # Add summary information
    if 'Status' in result[0]:
        status_counts = {}
        for record in result:
            status = record.get('Status', 'Unknown')
            status_counts[status] = status_counts.get(status, 0) + 1

        response += "ğŸ“Š Status Summary:\n"
        for status, count in status_counts.items():
            response += f"   â€¢ {status}: {count} records\n"
        response += "\n"

    # For multiple records, show tabular format for reasonable number of records
    if len(result) <= 20:
        response += "ğŸ“‹ Detailed Results:\n"
        response += format_query_results_tabular(result)
    else:
        response += f"ğŸ“‹ Summary: {len(result)} records found. Showing first 10:\n"
        response += format_query_results_tabular(result[:10])
        response += f"\n... and {len(result) - 10} more records."

    return response

def format_query_results_tabular(result: List[Dict]) -> str:
    """Format database results in tabular format"""
    if not result:
        return "No records found."

    # Get columns from first record
    columns = list(result[0].keys())

    # Convert dict results to tuples for formatting
    result_tuples = [tuple(row.values()) for row in result]

    output = []

    # Calculate column widths with reasonable limits
    col_widths = []
    for i, col in enumerate(columns):
        max_content_width = max(len(str(row[i])) for row in result_tuples) if result_tuples else 0
        col_width = min(max(len(str(col)), max_content_width), 60)  # Max 60 chars per column
        col_widths.append(col_width)

    # Build header
    header = " | ".join(col.ljust(width) for col, width in zip(columns, col_widths))
    separator = "-+-".join("-" * width for width in col_widths)
    output.append(header)
    output.append(separator)

    # Add rows
    for row in result_tuples:
        formatted_row = " | ".join(
            (str(val)[:57] + "..." if len(str(val)) > 60 else str(val)).ljust(width)
            if val is not None else "NULL".ljust(width)
            for val, width in zip(row, col_widths)
        )
        output.append(formatted_row)

    output.append(f"\nTotal records: {len(result)}")
    return "\n".join(output)

def is_select_query(sql: str) -> bool:
    """Check if query is a safe SELECT query"""
    sql_clean = sql.strip().lower()
    print(f"DEBUG - Validating SQL: {repr(sql_clean)}")

    # Check if it starts with SELECT
    starts_with_select = sql_clean.startswith('select')

    # Check for dangerous operations
    dangerous_ops = ['insert', 'update', 'delete', 'drop', 'alter', 'create', 'truncate', 'grant', 'revoke']
    has_dangerous_ops = any(kw in sql_clean for kw in dangerous_ops)

    # Check if it's just descriptive text
    descriptive_phrases = ['this is', 'sql query', 'the query', 'here is', 'generate', 'create']
    is_descriptive = any(phrase in sql_clean for phrase in descriptive_phrases)

    is_valid = starts_with_select and not has_dangerous_ops and not is_descriptive

    print(f"DEBUG - SQL validation: starts_with_select={starts_with_select}, has_dangerous_ops={has_dangerous_ops}, is_descriptive={is_descriptive}, final_valid={is_valid}")

    return is_valid

class FarDetailsAssistant:
    def __init__(self):
        self.llm = None
        self.db_handler = None
        self.initialized = False
        self.chat_history = []

    def initialize(self):
        """Initialize the FAR Details Assistant"""
        try:
            # Initialize LLM
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.1)

            # Set up database connection
            db_cfg = FAR_DB_CONFIG['db_config']
            uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"

            # Connect to database
            db_for_llm = SQLDatabase.from_uri(
                uri,
                include_tables=FAR_DB_CONFIG.get("include_tables"),
                engine_args={
                    "pool_pre_ping": True,
                    "pool_recycle": 3600,
                    "connect_args": {
                        "connect_timeout": 15,
                        "charset": "utf8mb4"
                    }
                }
            )

            # Create query chain
            chain = create_sql_query_chain(self.llm, db_for_llm)

            # Create direct connection for executing queries
            db_conn = pymysql.connect(
                host=db_cfg['host'],
                user=db_cfg['user'],
                password=db_cfg['password'],
                database=db_cfg['database'],
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor,
                autocommit=True
            )

            self.db_handler = {
                'chain': chain,
                'connection': db_conn,
                'config': FAR_DB_CONFIG
            }

            self.initialized = True
            return True

        except Exception as e:
            logger.error(f"Initialization failed: {e}\n{traceback.format_exc()}")
            return False

    def query_far_details(self, question: str) -> str:
        """Query FAR details database and always show results"""
        if not self.db_handler:
            return "âŒ FAR Details database not available."

        try:
            # Use the question directly with the LLM chain
            print(f"DEBUG - Original question: {question}")
            
            # Get current date context and create enhanced question
            date_ctx = get_date_context()
            
            enhanced_question = f"""Current date context:
- Today: {date_ctx['current_date']}
- Current year: {date_ctx['current_year']}
- Next year: {date_ctx['next_year']}
- Previous year: {date_ctx['prev_year']}
- Current month: {date_ctx['current_month']} ({date_ctx['month_names'][date_ctx['current_month']]})
- Next month: {date_ctx['next_month']} ({date_ctx['month_names'][date_ctx['next_month']]}) in year {date_ctx['next_month_year']}

For date-related queries:
- If 'created' is mentioned, search in the Created column using STR_TO_DATE function
- If 'expires' or 'expiry' is mentioned, search in the Expires column using STR_TO_DATE function  
- If status is not specified, search across all statuses
- If month/year is not specified, search across all time periods
- Use proper STR_TO_DATE conversion for all date comparisons
- Handle relative terms like "next year", "this year", "last year" based on current date context
- DO NOT add LIMIT clause unless specifically requested

Original question: {question}"""
            
            # Create a temporary prompt for this query
            temp_prompt = get_sql_generation_prompt()
            
            # Generate the SQL query using the standard chain with enhanced context
            raw_sql = self.db_handler['chain'].invoke({"question": enhanced_question})
            print(f"DEBUG - Raw SQL from LLM: {repr(raw_sql)}")
            logger.info(f"Generated SQL: {raw_sql}")

            # Clean and fix the SQL
            sql = clean_and_fix_sql(raw_sql)
            print(f"DEBUG - Final SQL after cleaning: {sql}")
            logger.info(f"Cleaned SQL: {sql}")

            # Validate query safety
            if not is_select_query(sql):
                return f"âŒ Error: Invalid query generated. Raw output was: {repr(raw_sql)}\nCleaned to: {sql}\nOnly SELECT queries are allowed."

            # Execute the query
            with self.db_handler['connection'].cursor() as cursor:
                try:
                    print(f"DEBUG - Executing SQL: {sql}")
                    cursor.execute(sql)
                    result = cursor.fetchall()
                    print(f"DEBUG - Query result count: {len(result)}")

                    logger.info(f"Query returned {len(result)} rows")

                    # Format output in natural language
                    if not result:
                        response = "I couldn't find any FAR records matching your criteria.\n\n"
                        response += "ğŸ’¡ Suggestions:\n"
                        response += "â€¢ Try using broader search terms\n"
                        response += "â€¢ Check if the data exists for the specified time period\n"
                        response += "â€¢ Modify date ranges or status values\n"
                        response += f"â€¢ Current date context: Today is {date_ctx['current_date']}, current year is {date_ctx['current_year']}, next year is {date_ctx['next_year']}\n"
                        response += f"\nğŸ” Query executed: {sql}"
                        return response
                    else:
                        # Format results in natural language
                        natural_response = format_query_results_natural(result, question)

                        # Add query info for debugging on large result sets or when helpful
                        if len(result) > 10 or "debug" in question.lower():
                            natural_response += f"\n\nğŸ” Query executed: {sql}"

                        return natural_response

                except pymysql.Error as db_error:
                    error_msg = f"âŒ Database Error: {str(db_error)}\n"
                    error_msg += f"SQL Query: {sql}\n"
                    error_msg += f"Original LLM output: {repr(raw_sql)}\n"
                    error_msg += "Please check the query syntax and try again."
                    logger.error(f"Database error: {db_error}\nSQL: {sql}")
                    return error_msg

        except Exception as e:
            error_msg = f"âŒ Error processing request: {str(e)}\n"
            error_msg += f"Raw LLM output: {repr(raw_sql) if 'raw_sql' in locals() else 'N/A'}\n"
            error_msg += "Please try rephrasing your question."
            logger.error(f"Query processing error: {e}\n{traceback.format_exc()}")
            return error_msg

    def process_question(self, question: str) -> str:
        """Process questions and return results"""
        if not self.initialized and not self.initialize():
            return "âŒ FAR Details Assistant initialization failed. Please check database connection."

        if is_dangerous(question):
            return "âŒ Question blocked for security reasons."

        # Add to chat history
        self.chat_history.append(f"User: {question}")

        # Get response
        response = self.query_far_details(question)

        # Add response to history
        self.chat_history.append(f"Assistant: {response}")

        return response

    def start_interactive_session(self, query):
        """Process single query and return result"""
        if not self.initialize():
            return "âŒ Failed to initialize FAR Details Assistant. Check database connection."

        try:
            if query.lower() in ['exit', 'quit', 'q']:
                return "ğŸ‘‹ Session ended."

            print("ğŸ” Processing your query...")
            response = self.process_question(query)
            return response

        except KeyboardInterrupt:
            return "ğŸ‘‹ Session interrupted."
        except Exception as e:
            error_msg = f"âŒ Session error: {str(e)}"
            logger.error(f"Session error: {e}\n{traceback.format_exc()}")
            return error_msg
        finally:
            # Clean up database connection
            try:
                if self.db_handler and self.db_handler['connection'] and self.db_handler['connection'].open:
                    self.db_handler['connection'].close()
            except:
                pass

def Farmain(query):
    """Main function to process FAR queries"""
    print("ğŸš€ Starting FAR Details Assistant...")
    assistant = FarDetailsAssistant()
    result = assistant.start_interactive_session(query)
    print("âœ… Query processing complete.")
    return result

# Test the function with enhanced date handling
if __name__ == "__main__":
    # Test with comprehensive date queries including next year scenarios
    test_queries = [
        "Show me FAR with ID 175",
        "List all FARs created in 2020",
        "Show me all FARs that expire in March 2020", 
        "Count FARs created today",
        "FARs expiring this month",
        "All FARs with status resolved",
        "FARs created next year",  # This should now work properly
        "Count FARs expiring next year",
        "FARs created this year",
        "Show FARs created last year",
        "FARs expiring next month",
        "Count all active FARs created in the previous year",
        "List FARs that will expire in January 2026",  # Specific future date
        "Show me FARs created between 2020 and 2023"
    ]

    for query in test_queries:
        print(f"\n{'='*60}")
        print(f"Testing: {query}")
        print('='*60)
        result = Farmain(query)
        print(result)
