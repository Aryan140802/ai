import os
import re
import logging
import pymysql
import traceback
from typing import List, Optional, Dict, Any
from datetime import datetime
import json

from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

# --- FAR DETAILS CONFIGURATION ---
FAR_DB_CONFIG = {
    "name": "FAR Details",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["FarDetailsAll"],
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

# Column metadata for better query generation
COLUMN_INFO = {
    "Far_Id": "int - Unique FAR identifier (use = for exact match)",
    "Subject": "text - FAR subject/title (use LIKE for search)",
    "Status": "text - Current status like active, resolved, rejected (use LIKE for search)",
    "Created": "date - Creation date in YYYY-MM-DD HH:MM:SS format (use date functions)",
    "Expires": "date - Expiry date in YYYY-MM-DD HH:MM:SS format (use date functions)",
    "Requested_Source": "text - Source IP addresses (use LIKE for search)",
    "Requested_Destination": "text - Destination IP addresses (use LIKE for search)",
    "Requested_Service": "text - Service/port information (use LIKE for search)",
    "Dependent_application": "text - Related applications (use LIKE for search)",
    "ZONE": "text - Environment zone like PROD, UAT (use LIKE for search)",
    "Permanent_Rule": "text - Whether rule is permanent (use LIKE for search)"
}

# Setup logging
logging.basicConfig(
    filename=os.path.expanduser("~/.far_details_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    """Check if text contains dangerous patterns"""
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def clean_and_fix_sql(raw_sql: str) -> str:
    """Clean and fix SQL with proper handling for different column types"""
    # Extract SQL from code block if present
    match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
    if match:
        sql = match.group(1).strip()
    else:
        sql = re.sub(r"```", "", raw_sql)
        sql = re.sub(r"^(.*?)(SELECT|INSERT|UPDATE|DELETE|WITH)", r"\2", sql, flags=re.IGNORECASE | re.DOTALL)
        sql = sql.strip()

    # Don't convert everything to LIKE - be smart about it
    # Only convert text fields to LIKE, keep IDs and dates as exact matches
    text_fields = ['Subject', 'Status', 'Requested_Source', 'Requested_Destination', 
                   'Requested_Service', 'Dependent_application', 'ZONE', 'Permanent_Rule']
    
    # Apply LIKE only to text fields, not to Far_Id or date fields
    for field in text_fields:
        # Convert = to LIKE for text fields only
        sql = re.sub(f"({field})\\s*=\\s*'([^']*)'", f"\\1 LIKE '%\\2%'", sql, flags=re.IGNORECASE)
        sql = re.sub(f"({field})\\s*=\\s*\"([^\"]*)\"", f"\\1 LIKE '%\\2%'", sql, flags=re.IGNORECASE)

    # Handle date fields properly - use STR_TO_DATE for date comparisons
    date_fields = ['Created', 'Expires']
    for field in date_fields:
        # Convert simple date comparisons to use STR_TO_DATE
        sql = re.sub(f"({field})\\s*([><=!]+)\\s*'([^']*)'", 
                    f"STR_TO_DATE(\\1, '%Y-%m-%d %H:%i:%s') \\2 STR_TO_DATE('\\3', '%Y-%m-%d %H:%i:%s')", 
                    sql, flags=re.IGNORECASE)

    # Remove trailing semicolons
    sql = sql.strip().rstrip(";")
    
    # Add reasonable limit if none exists and it's not a COUNT query
    if not re.search(r"\bLIMIT\b", sql, re.IGNORECASE) and not re.search(r"\bCOUNT\s*\(", sql, re.IGNORECASE):
        sql += " LIMIT 50"
    
    return sql

def format_query_results(result: List[tuple], columns: Optional[List[str]] = None) -> str:
    """Format database results for display with better formatting"""
    if not result:
        return "No records found."

    # If single value result (like COUNT), return it directly
    if len(result) == 1 and len(result[0]) == 1:
        return f"Result: {result[0][0]}"

    # Format as table if we have column names
    if columns:
        output = []
        
        # Calculate column widths with reasonable limits
        col_widths = []
        for i, col in enumerate(columns):
            max_content_width = max(len(str(row[i])) for row in result) if result else 0
            col_width = min(max(len(str(col)), max_content_width), 60)  # Max 60 chars per column
            col_widths.append(col_width)

        # Build header
        header = " | ".join(col.ljust(width) for col, width in zip(columns, col_widths))
        separator = "-+-".join("-" * width for width in col_widths)
        output.append(header)
        output.append(separator)

        # Add rows
        for row in result:
            formatted_row = " | ".join(
                (str(val)[:57] + "..." if len(str(val)) > 60 else str(val)).ljust(width) 
                if val is not None else "NULL".ljust(width) 
                for val, width in zip(row, col_widths)
            )
            output.append(formatted_row)

        output.append(f"\nTotal records: {len(result)}")
        return "\n".join(output)

    # Fallback format without column names
    rows = []
    for row in result:
        rows.append(" | ".join(str(val) if val is not None else "NULL" for val in row))
    rows.append(f"\nTotal records: {len(result)}")
    return "\n".join(rows)

def is_select_query(sql: str) -> bool:
    """Check if query is a safe SELECT query"""
    sql_clean = sql.strip().lower()
    # Must start with SELECT and not contain dangerous operations
    return (sql_clean.startswith('select') and 
            not any(kw in sql_clean for kw in ['insert', 'update', 'delete', 'drop', 'alter', 'create', 'truncate']))

class FarDetailsAssistant:
    def __init__(self):
        self.llm = None
        self.db_handler = None
        self.initialized = False
        self.chat_history = []

    def initialize(self):
        """Initialize the FAR Details Assistant"""
        try:
            # Initialize LLM
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.1)

            # Set up database connection
            db_cfg = FAR_DB_CONFIG['db_config']
            uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"

            # Connect to database
            db_for_llm = SQLDatabase.from_uri(
                uri,
                include_tables=FAR_DB_CONFIG.get("include_tables"),
                engine_args={
                    "pool_pre_ping": True,
                    "pool_recycle": 3600,
                    "connect_args": {
                        "connect_timeout": 15,
                        "charset": "utf8mb4"
                    }
                }
            )

            # Create query chain
            chain = create_sql_query_chain(self.llm, db_for_llm)

            # Create direct connection for executing queries
            db_conn = pymysql.connect(
                host=db_cfg['host'],
                user=db_cfg['user'],
                password=db_cfg['password'],
                database=db_cfg['database'],
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor,
                autocommit=True
            )

            self.db_handler = {
                'chain': chain,
                'connection': db_conn,
                'config': FAR_DB_CONFIG
            }

            self.initialized = True
            return True

        except Exception as e:
            logger.error(f"Initialization failed: {e}\n{traceback.format_exc()}")
            return False

    def build_enhanced_prompt(self, question: str) -> str:
        """Build enhanced prompt with column information"""
        column_details = "\n".join([f"- {col}: {desc}" for col, desc in COLUMN_INFO.items()])
        
        current_date = datetime.now().strftime('%Y-%m-%d')
        
        enhanced_prompt = f"""
Question: {question}

DATABASE SCHEMA - FarDetailsAll table columns:
{column_details}

IMPORTANT QUERY RULES:
1. Always query from the FarDetailsAll table
2. For text searches (Subject, Status, etc.): use LIKE '%value%' 
3. For exact ID matches: use Far_Id = value (no quotes for numbers)
4. For date comparisons: use STR_TO_DATE(column, '%Y-%m-%d %H:%i:%s') for proper date handling
5. Current date is {current_date}
6. Do NOT add LIMIT 5 or very small limits - use LIMIT 50 or higher for good results
7. Include relevant columns in SELECT based on the question

EXAMPLE QUERIES:
- "SELECT Far_Id, Subject, Status FROM FarDetailsAll WHERE Status LIKE '%active%' LIMIT 50"
- "SELECT * FROM FarDetailsAll WHERE Far_Id = 175"  
- "SELECT Far_Id, Subject, Expires FROM FarDetailsAll WHERE STR_TO_DATE(Expires, '%Y-%m-%d %H:%i:%s') > NOW() LIMIT 50"
- "SELECT COUNT(*) FROM FarDetailsAll WHERE Status LIKE '%resolved%'"
- "SELECT Far_Id, Subject, Status, ZONE FROM FarDetailsAll WHERE Subject LIKE '%firewall%' AND ZONE LIKE '%PROD%' LIMIT 50"

Generate a proper SQL query for the question above:
"""
        return enhanced_prompt

    def query_far_details(self, question: str) -> str:
        """Query FAR details database and always show results"""
        if not self.db_handler:
            return "âŒ FAR Details database not available."

        try:
            # Build enhanced prompt
            enhanced_question = self.build_enhanced_prompt(question)

            # Generate the SQL query
            raw_sql = self.db_handler['chain'].invoke({"question": enhanced_question})
            logger.info(f"Generated SQL: {raw_sql}")

            # Clean and fix the SQL
            sql = clean_and_fix_sql(raw_sql)
            logger.info(f"Cleaned SQL: {sql}")

            # Validate query safety
            if not is_select_query(sql):
                return "âŒ Error: Only SELECT queries are allowed for security reasons."

            # Execute the query
            with self.db_handler['connection'].cursor() as cursor:
                try:
                    cursor.execute(sql)
                    result = cursor.fetchall()

                    # Get column names
                    columns = list(result[0].keys()) if result and isinstance(result[0], dict) else None

                    # Convert dict results to tuples for formatting
                    if columns:
                        result_tuples = [tuple(row.values()) for row in result]
                    else:
                        result_tuples = result

                    logger.info(f"Query returned {len(result)} rows")

                    # Format output - ALWAYS show the query results
                    output_parts = []
                    output_parts.append("=" * 80)
                    output_parts.append("ğŸ“Š QUERY RESULTS")
                    output_parts.append("=" * 80)
                    output_parts.append(f"SQL Query: {sql}")
                    output_parts.append(f"Records Found: {len(result)}")
                    output_parts.append("")

                    if not result:
                        output_parts.append("No FAR records found matching your criteria.")
                        output_parts.append("\nğŸ’¡ Try:")
                        output_parts.append("- Using broader search terms")
                        output_parts.append("- Checking if the data exists in the database")
                        output_parts.append("- Modifying date ranges or status values")
                    else:
                        # Format and display the actual results
                        formatted_results = format_query_results(result_tuples, columns)
                        output_parts.append(formatted_results)

                    output_parts.append("=" * 80)
                    
                    return "\n".join(output_parts)

                except pymysql.Error as db_error:
                    error_msg = f"âŒ Database Error: {str(db_error)}\n"
                    error_msg += f"SQL Query: {sql}\n"
                    error_msg += "Please check the query syntax and try again."
                    logger.error(f"Database error: {db_error}\nSQL: {sql}")
                    return error_msg

        except Exception as e:
            error_msg = f"âŒ Error processing request: {str(e)}\n"
            error_msg += "Please try rephrasing your question."
            logger.error(f"Query processing error: {e}\n{traceback.format_exc()}")
            return error_msg

    def process_question(self, question: str) -> str:
        """Process questions and return results"""
        if not self.initialized and not self.initialize():
            return "âŒ FAR Details Assistant initialization failed. Please check database connection."

        if is_dangerous(question):
            return "âŒ Question blocked for security reasons."

        # Add to chat history
        self.chat_history.append(f"User: {question}")

        # Get response
        response = self.query_far_details(question)

        # Add response to history
        self.chat_history.append(f"Assistant: {response}")

        return response

    def start_interactive_session(self, query):
        """Process single query and return result"""
        if not self.initialize():
            return "âŒ Failed to initialize FAR Details Assistant. Check database connection."

        try:
            if query.lower() in ['exit', 'quit', 'q']:
                return "ğŸ‘‹ Session ended."

            print("ğŸ” Processing your query...")
            response = self.process_question(query)
            return response

        except KeyboardInterrupt:
            return "ğŸ‘‹ Session interrupted."
        except Exception as e:
            error_msg = f"âŒ Session error: {str(e)}"
            logger.error(f"Session error: {e}\n{traceback.format_exc()}")
            return error_msg
        finally:
            # Clean up database connection
            try:
                if self.db_handler and self.db_handler['connection'] and self.db_handler['connection'].open:
                    self.db_handler['connection'].close()
            except:
                pass

def Farmain(query):
    """Main function to process FAR queries"""
    print("ğŸš€ Starting FAR Details Assistant...")
    assistant = FarDetailsAssistant()
    result = assistant.start_interactive_session(query)
    print("âœ… Query processing complete.")
    return result

# Test the function
if __name__ == "__main__":
    # Test with sample queries
    test_queries = [
        "Show me FAR with ID 175",
        "List all FARs with status resolved",
        "Show me all FARs that expire in 2020",
        "Count FARs by status"
    ]
    
    for query in test_queries:
        print(f"\n{'='*60}")
        print(f"Testing: {query}")
        print('='*60)
        result = Farmain(query)
        print(result)
