import os
import re
import traceback
import pymysql
import sqlparse
from sqlalchemy import create_engine, text
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain
from langchain_core.prompts import PromptTemplate
from langchain_core.runnables import RunnablePassthrough
from langchain_core.output_parsers import StrOutputParser

# --- Configuration ---

# Database connection details
DB_CONFIG = {
    "host": "localhost",
    "user": "root",
    "password": "root123",
    "database": "EIS_n"
}

# LLM model to use
LLM_MODEL = "mistral:7b-instruct-q4_K_M"

# --- Database Setup ---

def get_db_connection():
    """Establishes and returns a SQLAlchemy engine for the database."""
    uri = f"mysql+pymysql://{DB_CONFIG['user']}:{DB_CONFIG['password']}@{DB_CONFIG['host']}/{DB_CONFIG['database']}"
    return create_engine(uri)

# Instantiate the database engine
try:
    db_engine = get_db_connection()
    # Test connection
    with db_engine.connect() as connection:
        print("✅ Database connection successful.")
    db = SQLDatabase(engine=db_engine)
except Exception as e:
    print(f"❌ Database connection failed. Please check your credentials and ensure the MySQL server is running.")
    print(f"Error: {e}")
    exit()

# --- LLM and Prompt Setup ---

# Initialize the Ollama LLM
llm = OllamaLLM(model=LLM_MODEL)

# Detailed prompt template for generating SQL queries
# This prompt includes schema details, rules, and examples to guide the LLM.
sql_prompt_template = """### Instructions
You are an AI assistant that generates read-only MySQL queries for a database with the following schema.
Your ONLY output should be the MySQL query. Do not add any explanation, commentary, or markdown formatting like ```sql.

### Rules
1.   **IMPORTANT**: You MUST only generate read-only `SELECT` queries. Never generate `UPDATE`, `DELETE`, `INSERT`, `DROP`, or any other write-modifying queries.
2.  The table name is `FarDetailsAll`.
3.  Use `LIKE` for string comparisons to allow for partial matches.
4.  Analyze the user's question to infer the correct column and values for the `WHERE` clause.

### Table Schema: `FarDetailsAll`
- Far_Id (int): far id (e.g., 186).
- Subject (longtext): subject (e.g., 'For Communication between EIS and DCMS servers for IVR').
- Status (longtext): status (e.g., 'rejected').
- Created (longtext): created (e.g., '2020-03-02 18:57:19').
- Expires (longtext): expires (e.g., '2020-03-11').
- Requested_Source (longtext): requested source ip (e.g., '10.191.172.41,10.191.172.44-10.191.172.45').
- Requested_Destination (longtext): requested destination ip (e.g., '10.191.172.38, 10.191.172.35').
- Requested_Service (longtext): requested service (e.g., 'tcp/7029, tcp/7030,tcp/7030, tcp/7029').
- Requested_Source_NAT (longtext): requested source nat ip (e.g., '103.209.96.209').
- Requested_Destination_NAT (longtext): requested destination nat ip (e.g., '103.209.96.208').
- Requested_Port_Translation (longtext): requested port translation (e.g., 'tcp/2443,tcp/443, tcp/80').
- Change_Source (longtext): change source ip (e.g., '10.191.172.41,10.191.172.44, 10.191.172.45').
- Change_Destination (longtext): change destination ip (e.g., '10.189.192.52, 10.209.160.180').
- Change_Service (longtext): change service (e.g., 'tcp/7029, tcp/7030').
- Change_Source_NAT (longtext): change source nat ip (e.g., '103.209.96.209').
- Change_Destination_NAT (longtext): change destination nat ip (e.g., '103.209.96.208').
- Translated_Destination (longtext): translated destination (e.g., '10.189.40.5-10.189.40.6').
- Translated_Service (longtext): translated service ip (e.g., 'tcp/7029,tcp/7030').
- Dependent_application (longtext): dependent applications (e.g., 'CRM').
- Permanent_Rule (longtext): permanent rule (e.g., 'No').
- ZONE (longtext): zone (e.g., 'UAT').

### Query Examples
- Question: "what is the subject of far id 186 ?"
  Query: SELECT Subject FROM FarDetailsAll WHERE Far_Id=186;
- Question: "which far are expiring in march 2020 ?"
  Query: SELECT Far_Id FROM FarDetailsAll WHERE Expires LIKE '%2020-03-%';
- Question: "how many far are expiring in march ?"
  Query: SELECT COUNT(*) FROM FarDetailsAll WHERE Expires LIKE '%-03-%';

### User Question
{question}

### Your MySQL Query
"""

SQL_PROMPT = PromptTemplate.from_template(sql_prompt_template)

# Prompt template for explaining the results to the user
explanation_prompt_template = """### Instructions
You are an AI assistant. A user asked a question, a database query was run, and you have the results.
Your task is to provide a clear, human-like explanation of the data as an answer to the user's question.
If the result is empty, inform the user that no matching records were found. Do not mention the database or the query.

### User's Question
{question}

### Database Result
{result}

### Your Answer
"""

EXPLANATION_PROMPT = PromptTemplate.from_template(explanation_prompt_template)

# --- Result Formatting Functions ---

def format_query_results_natural(result: list, question: str) -> str:
    """Format query results in a natural language response"""
    if not result:
        return "I couldn't find any FAR records matching your criteria."

    # Handle single value results (like COUNT)
    if len(result) == 1 and len(result[0]) == 1:
        value = list(result[0].values())[0]
        if "count" in question.lower():
            return f"There are {value} FAR records matching your criteria."
        else:
            return f"The result is: {value}"

    # Handle single record
    if len(result) == 1:
        record = result[0]
        response = f"I found 1 FAR record:\n\n"

        # Format key information
        key_fields = ['Far_Id', 'Subject', 'Status', 'Created', 'Expires', 'ZONE',
                     'Requested_Source', 'Requested_Destination', 'Requested_Service',
                     'Dependent_application', 'Permanent_Rule']

        icons = {'Far_Id': '📋', 'Subject': '📝', 'Status': '🔄', 'Created': '📅',
                'Expires': '⏰', 'ZONE': '🌐', 'Requested_Source': '🔗',
                'Requested_Destination': '🎯', 'Requested_Service': '⚙️',
                'Dependent_application': '📱', 'Permanent_Rule': '🔒'}

        for field in key_fields:
            if field in record and record[field] is not None:
                icon = icons.get(field, '•')
                response += f"{icon} {field.replace('_', ' ')}: {record[field]}\n"

        return response.strip()

    # Handle multiple records
    response = f"I found {len(result)} FAR records matching your criteria:\n\n"

    # Add status summary if available
    if 'Status' in result[0]:
        status_counts = {}
        for record in result:
            status = record.get('Status', 'Unknown')
            status_counts[status] = status_counts.get(status, 0) + 1

        response += "📊 Status Summary:\n"
        for status, count in status_counts.items():
            response += f"   • {status}: {count} records\n"
        response += "\n"

    # Show detailed results based on count
    if len(result) <= 10:
        response += "📋 Detailed Results:\n"
        response += format_query_results_tabular(result)
    elif len(result) <= 50:
        response += f"📋 First 10 Results (of {len(result)} total):\n"
        response += format_query_results_tabular(result[:10])
        response += f"\n... and {len(result) - 10} more records."
    else:
        response += f"📋 Sample Results (showing 5 of {len(result)} total):\n"
        response += format_query_results_tabular(result[:5])
        response += f"\n... and {len(result) - 5} more records."

    return response

def format_query_results_tabular(result: list) -> str:
    """Format results in a clean table"""
    if not result:
        return "No records found."

    # Select most important columns for display
    important_cols = ['Far_Id', 'Subject', 'Status', 'Created', 'Expires', 'ZONE']
    available_cols = [col for col in important_cols if col in result[0]]

    if not available_cols:
        available_cols = list(result[0].keys())[:6]  # First 6 columns

    output = []

    # Calculate column widths
    col_widths = {}
    for col in available_cols:
        max_width = len(col)
        for row in result:
            if row.get(col):
                max_width = max(max_width, len(str(row[col])))
        col_widths[col] = min(max_width, 50)  # Max 50 chars per column

    # Header
    header = " | ".join(col.ljust(col_widths[col]) for col in available_cols)
    separator = "-+-".join("-" * col_widths[col] for col in available_cols)
    output.append(header)
    output.append(separator)

    # Rows
    for row in result:
        formatted_row = " | ".join(
            str(row.get(col, 'NULL'))[:col_widths[col]-3] + "..."
            if len(str(row.get(col, 'NULL'))) > col_widths[col]
            else str(row.get(col, 'NULL')).ljust(col_widths[col])
            for col in available_cols
        )
        output.append(formatted_row)

    return "\n".join(output)

# --- Core Functions ---

def is_readonly_query(sql_query: str) -> bool:
    """Checks if the generated SQL query is a read-only SELECT statement."""
    parsed = sqlparse.parse(sql_query)
    if not parsed:
        return False
    # Check the first statement's type
    return parsed[0].get_type() == 'SELECT'

def clean_and_fix_sql(raw_sql: str) -> str:
    """Clean and fix SQL query from LLM output"""
    # Remove markdown formatting
    sql = raw_sql.strip().replace("```sql", "").replace("```", "").strip()
    
    # Remove common prefixes/suffixes
    sql = re.sub(r'^(here is|here\'s|sql query|query|the query is)?\s*:?\s*', '', sql, flags=re.IGNORECASE)
    sql = re.sub(r'\s*;?\s*$', '', sql)
    
    # Find SELECT statement
    select_match = re.search(r'(SELECT\s+.*?)(?:\n\s*$|$)', sql, re.IGNORECASE | re.DOTALL)
    if select_match:
        sql = select_match.group(1).strip()
    
    return sql

def validate_and_fix_sql(sql: str) -> tuple[str, bool]:
    """Validate SQL and attempt to fix common issues"""
    fixed_sql = sqlparse.format(sql, strip_comments=True).strip()
    return fixed_sql, True

def execute_query(sql: str) -> list:
    """Execute SQL query and return results"""
    with db_engine.connect() as connection:
        result = connection.execute(text(sql))
        return [dict(row) for row in result]

# --- LangChain Chains ---

# Chain to generate the SQL query
sql_generation_chain = (
    RunnablePassthrough.assign(schema=lambda _: db.get_table_info())
    | SQL_PROMPT
    | llm
    | StrOutputParser()
)

# Chain to explain the results
explanation_chain = EXPLANATION_PROMPT | llm | StrOutputParser()

# --- Main Function ---

def Teammain(query: str) -> str:
    """Process user query and return formatted results"""
    try:
        # 1. Generate SQL Query
        generated_sql = sql_generation_chain.invoke({"question": query})
        generated_sql = clean_and_fix_sql(generated_sql)
        
        # 2. Validate the Query
        if not is_readonly_query(generated_sql):
            return "❌ Error: Only read-only queries are allowed."
        
        # 3. Execute the Query
        results = execute_query(generated_sql)
        
        # 4. Format the results
        return format_query_results_natural(results, query)
        
    except Exception as e:
        return f"❌ An error occurred: {str(e)}"

# Test the function
if __name__ == "__main__":
    test_queries = [
        "Show me FAR with ID 175",
        "List all FARs created in 2020",
        "Show me all FARs that expire in March 2020",
        "Count FARs created today",
        "FARs expiring this month",
        "All FARs with status resolved",
        "FARs created next year",
        "Count FARs expiring next year",
        "FARs created this year",
        "Show FARs created last year",
        "FARs expiring next month",
        "Count all active FARs created in the previous year",
        "List FARs that will expire in January 2026",
        "Show me FARs created between 2020 and 2023",
        "How many FARs are expiring in July 2026"
    ]

    for query in test_queries:
        print(f"\n{'='*60}")
        print(f"Testing: {query}")
        print('='*60)
        result = Teammain(query)
        print(result)
