import os
import re
import logging
import pymysql
import traceback
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime
import json
import sqlparse
from functools import lru_cache
import mysql.connector.pooling

# Try to import langchain components, but continue if not available
try:
    from langchain_community.utilities import SQLDatabase
    from langchain_ollama import OllamaLLM
    from langchain.chains import create_sql_query_chain
    LANGCHAIN_AVAILABLE = True
except ImportError:
    LANGCHAIN_AVAILABLE = False
    print("Warning: LangChain not available. Using fallback SQL generation.")

# --- TEAM DETAILS CONFIGURATION ---
TEAM_DB_CONFIG = {
    "name": "Team Details",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n",
        "pool_name": "team_pool",
        "pool_size": 5
    },
    "include_tables": ["UserMaster"],
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

# Sensitive field patterns (case-insensitive)
SENSITIVE_PATTERNS = [
    r"pwd", r"password", r"pass", r"secq", r"seca", r"secret", 
    r"auth", r"token", r"key", r"hash", r"salt"
]

# Setup logging
log_dir = os.path.expanduser("~")
log_file = os.path.join(log_dir, ".team_details_ai.log")

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    """Check if text contains dangerous patterns"""
    if not text:
        return False
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def is_sensitive_field(field_name: str) -> bool:
    """Check if field name contains sensitive information"""
    if not field_name:
        return False
    return any(re.search(pattern, field_name.lower()) for pattern in SENSITIVE_PATTERNS)

class DatabaseSchemaManager:
    """Manages database schema discovery and caching"""
    
    def __init__(self, connection_pool):
        self.connection_pool = connection_pool
        self.schema_cache = {}
        self.field_mappings = {}
        self.safe_columns = []
        self.load_schema()
    
    def load_schema(self):
        """Load and cache database schema with enhanced debugging"""
        connection = None
        try:
            connection = self.connection_pool.get_connection()
            print("DEBUG - Loading database schema...")
            
            with connection.cursor(dictionary=True) as cursor:
                cursor.execute("""
                    SELECT TABLE_NAME 
                    FROM INFORMATION_SCHEMA.TABLES 
                    WHERE TABLE_SCHEMA = %s AND TABLE_NAME = 'UserMaster'
                """, (TEAM_DB_CONFIG['db_config']['database'],))
                
                table_check = cursor.fetchone()
                if not table_check:
                    cursor.execute("""
                        SELECT TABLE_NAME 
                        FROM INFORMATION_SCHEMA.TABLES 
                        WHERE TABLE_SCHEMA = %s AND TABLE_NAME LIKE '%user%'
                    """, (TEAM_DB_CONFIG['db_config']['database'],))
                    similar_tables = cursor.fetchall()
                    
                    error_msg = "UserMaster table not found in database."
                    if similar_tables:
                        table_names = [t['TABLE_NAME'] for t in similar_tables]
                        error_msg += f" Similar tables found: {', '.join(table_names)}"
                    
                    print(f"DEBUG - {error_msg}")
                    raise Exception(error_msg)
                
                print("DEBUG - UserMaster table found, loading columns...")
                
                cursor.execute("""
                    SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE, COLUMN_DEFAULT, COLUMN_COMMENT
                    FROM INFORMATION_SCHEMA.COLUMNS 
                    WHERE TABLE_SCHEMA = %s AND TABLE_NAME = 'UserMaster'
                    ORDER BY ORDINAL_POSITION
                """, (TEAM_DB_CONFIG['db_config']['database'],))
                
                columns = cursor.fetchall()
                print(f"DEBUG - Found {len(columns)} columns in UserMaster table")
                
                if not columns:
                    raise Exception("UserMaster table exists but no columns are accessible")
                
                self.schema_cache['UserMaster'] = {}
                self.safe_columns = []
                
                print("DEBUG - Processing columns:")
                for col in columns:
                    col_name = col['COLUMN_NAME']
                    col_type = col['DATA_TYPE']
                    
                    print(f"DEBUG -   Column: {col_name} ({col_type})")
                    
                    if is_sensitive_field(col_name):
                        print(f"DEBUG -     -> Skipped (sensitive)")
                        logger.info(f"Skipping sensitive field: {col_name}")
                        continue
                    
                    print(f"DEBUG -     -> Added to safe columns")
                    self.safe_columns.append(col_name)
                    self.schema_cache['UserMaster'][col_name] = {
                        'type': col_type,
                        'nullable': col['IS_NULLABLE'] == 'YES',
                        'default': col['COLUMN_DEFAULT'],
                        'comment': col['COLUMN_COMMENT'] or ''
                    }
                
                print(f"DEBUG - Schema loaded with {len(self.safe_columns)} safe columns: {self.safe_columns}")
                logger.info(f"Loaded schema with {len(self.safe_columns)} safe columns: {self.safe_columns}")
                
                self._create_field_mappings()
                print("DEBUG - Field mappings created")
                
        except Exception as e:
            logger.error(f"Schema loading failed: {e}")
            print(f"DEBUG - Schema loading failed: {e}")
            
            self.safe_columns = []
            print("DEBUG - Using fallback: trying to get columns from table directly")
            
            try:
                with connection.cursor(dictionary=True) as cursor:
                    cursor.execute("DESCRIBE UserMaster")
                    desc_result = cursor.fetchall()
                    for row in desc_result:
                        col_name = row['Field']
                        if not is_sensitive_field(col_name):
                            self.safe_columns.append(col_name)
                    print(f"DEBUG - Fallback found columns: {self.safe_columns}")
            except Exception as fallback_error:
                print(f"DEBUG - Fallback also failed: {fallback_error}")
                self.safe_columns = ['*']
            
            if not self.safe_columns:
                raise Exception(f"Could not load any safe columns from database: {e}")
        finally:
            if connection:
                connection.close()
    
    def _create_field_mappings(self):
        """Create intelligent field mappings based on actual column names"""
        self.field_mappings = {}
        
        id_col = self._find_column_by_patterns(['uid', 'user_?id', 'emp_?id', 'employee_?id', '^id$'])
        name_col = self._find_column_by_patterns(['name', 'emp_?name', 'employee_?name', 'full_?name'])
        contact_col = self._find_column_by_patterns(['contact', 'phone', 'mobile', 'cell'])
        email_col = self._find_column_by_patterns(['email', 'mail', 'e_?mail'])
        position_col = self._find_column_by_patterns(['position', 'role', 'designation', 'title'])
        team_col = self._find_column_by_patterns(['team', 'group', 'department', 'dept'])
        project_col = self._find_column_by_patterns(['project', 'proj'])
        level_col = self._find_column_by_patterns(['level', 'grade', 'band'])
        
        if id_col:
            self.field_mappings['id'] = id_col
            self.field_mappings['employee_id'] = id_col
            self.field_mappings['emp_id'] = id_col
            self.field_mappings['user_id'] = id_col
        
        if name_col:
            self.field_mappings['name'] = name_col
            self.field_mappings['employee_name'] = name_col
            self.field_mappings['emp_name'] = name_col
        
        if contact_col:
            self.field_mappings['phone'] = contact_col
            self.field_mappings['mobile'] = contact_col
            self.field_mappings['contact'] = contact_col
            self.field_mappings['phone_number'] = contact_col
        
        if email_col:
            self.field_mappings['email'] = email_col
            self.field_mappings['mail'] = email_col
        
        if position_col:
            self.field_mappings['position'] = position_col
            self.field_mappings['role'] = position_col
            self.field_mappings['designation'] = position_col
        
        if team_col:
            self.field_mappings['team'] = team_col
            self.field_mappings['department'] = team_col
            self.field_mappings['group'] = team_col
        
        if project_col:
            self.field_mappings['project'] = project_col
        
        if level_col:
            self.field_mappings['level'] = level_col
            self.field_mappings['grade'] = level_col
    
    def _find_column_by_patterns(self, patterns: List[str]) -> Optional[str]:
        """Find column by matching patterns"""
        for pattern in patterns:
            for col in self.safe_columns:
                if re.search(pattern, col.lower()):
                    return col
        return None
    
    def get_safe_columns(self) -> List[str]:
        """Get list of safe (non-sensitive) columns"""
        return self.safe_columns.copy()
    
    @lru_cache(maxsize=1000)
    def map_user_terms(self, question: str) -> str:
        """Map user terms to actual database columns"""
        mapped_question = question.lower()
        
        for term, actual_column in self.field_mappings.items():
            pattern = rf'\b{re.escape(term)}\b'
            mapped_question = re.sub(pattern, actual_column, mapped_question, flags=re.IGNORECASE)
        
        return mapped_question
    
    def get_column_info_string(self) -> str:
        """Get formatted column information for LLM context"""
        if 'UserMaster' not in self.schema_cache:
            return f"Available columns: {', '.join(self.safe_columns)}"
        
        info_parts = []
        for col_name, col_info in self.schema_cache['UserMaster'].items():
            type_info = col_info['type']
            if type_info in ['varchar', 'text', 'char']:
                usage = "text - use LIKE '%value%' for partial matching"
            elif type_info in ['int', 'bigint', 'decimal']:
                usage = "numeric - use = for exact matching"
            elif type_info in ['datetime', 'date', 'timestamp']:
                usage = "date - use appropriate date functions"
            else:
                usage = f"{type_info} - handle appropriately"
            
            info_parts.append(f"{col_name}: {usage}")
        
        return "\n".join(info_parts)

class SQLQueryProcessor:
    """Processes and validates SQL queries"""
    
    def __init__(self, schema_manager: DatabaseSchemaManager):
        self.schema_manager = schema_manager
    
    def clean_and_validate_sql(self, raw_sql: str, question: str) -> Tuple[str, bool]:
        """Clean SQL and validate it's safe"""
        try:
            logger.info(f"Processing raw SQL: {raw_sql}")
            
            if not self._contains_sql(raw_sql):
                constructed_sql = self._construct_sql_from_question(question)
                if constructed_sql:
                    return self._finalize_sql(constructed_sql), True
                return "", False
            
            sql = self._extract_sql(raw_sql)
            
            if not sql:
                return "", False
            
            if not self._is_safe_select(sql):
                return "", False
            
            sql = self._remove_sensitive_fields(sql)
            sql = self._fix_column_references(sql)
            sql = self._optimize_text_searches(sql)
            sql = self._finalize_sql(sql)
            
            logger.info(f"Final processed SQL: {sql}")
            return sql, True
            
        except Exception as e:
            logger.error(f"SQL processing error: {e}")
            return "", False
    
    def _contains_sql(self, text: str) -> bool:
        """Check if text contains SQL"""
        if not text:
            return False
        sql_indicators = ['select', 'from', 'where', 'join']
        text_lower = text.lower()
        return any(indicator in text_lower for indicator in sql_indicators)
    
    def _extract_sql(self, raw_sql: str) -> str:
        """Extract SQL from various formats"""
        if not raw_sql:
            return ""
            
        code_block_match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
        if code_block_match:
            return code_block_match.group(1).strip()
        
        select_match = re.search(r"(SELECT.*?)(?:\n\n|$|;)", raw_sql, re.IGNORECASE | re.DOTALL)
        if select_match:
            return select_match.group(1).strip()
        
        sql = re.sub(r"```", "", raw_sql)
        sql = re.sub(r"^.*?(SELECT|INSERT|UPDATE|DELETE)", r"\1", sql, flags=re.IGNORECASE | re.DOTALL)
        return sql.strip()
    
    def _construct_sql_from_question(self, question: str) -> Optional[str]:
        """Construct basic SQL from question patterns"""
        safe_columns = self.schema_manager.get_safe_columns()
        if not safe_columns:
            return None
        
        question_lower = question.lower()
        
        id_match = re.search(r'\b(\d+)\b', question)
        id_column = self.schema_manager._find_column_by_patterns(['uid', 'id', 'user_id', 'emp_id'])
        
        if id_match and id_column:
            return f"SELECT * FROM UserMaster WHERE `{id_column}` = {id_match.group(1)}"
        
        name_column = self.schema_manager._find_column_by_patterns(['name', 'emp_name', 'employee_name'])
        if name_column:
            name_match = re.search(r'(?:details?|info|about|of)\s+(\w+)', question_lower)
            if name_match:
                name = name_match.group(1)
                return f"SELECT * FROM UserMaster WHERE `{name_column}` LIKE '%{name}%'"
        
        return "SELECT * FROM UserMaster LIMIT 20"
    
    def _is_safe_select(self, sql: str) -> bool:
        """Validate SQL is safe SELECT only"""
        if not sql:
            return False
            
        sql_clean = sql.strip().lower()
        
        if not sql_clean.startswith('select'):
            return False
        
        dangerous_keywords = [
            'insert', 'update', 'delete', 'drop', 'alter', 'create', 
            'truncate', 'exec', 'execute', 'sp_', 'xp_'
        ]
        
        return not any(keyword in sql_clean for keyword in dangerous_keywords)
    
    def _remove_sensitive_fields(self, sql: str) -> str:
        """Remove references to sensitive fields"""
        safe_columns = self.schema_manager.get_safe_columns()
        
        if not safe_columns:
            return sql
        
        if re.search(r'SELECT\s+\*', sql, re.IGNORECASE):
            safe_cols_str = ', '.join(f"`{col}`" for col in safe_columns if col != '*')
            if safe_cols_str:
                sql = re.sub(r'SELECT\s+\*', f'SELECT {safe_cols_str}', sql, flags=re.IGNORECASE)
        
        return sql
    
    def _fix_column_references(self, sql: str) -> str:
        """Fix column references to match actual schema"""
        safe_columns = self.schema_manager.get_safe_columns()
        
        for actual_col in safe_columns:
            if actual_col == '*':
                continue
            
            patterns_to_clean = [
                (f'```{actual_col}```', f'`{actual_col}`'),
                (f'``{actual_col}``', f'`{actual_col}`'),
                (f'"{actual_col}"', f'`{actual_col}`'),
                (f"'{actual_col}'", f'`{actual_col}`'),
            ]
            
            for pattern, replacement in patterns_to_clean:
                sql = sql.replace(pattern, replacement)
            
            sql = re.sub(f'\\b{re.escape(actual_col)}\\b(?![`"\'])', f'`{actual_col}`', sql, flags=re.IGNORECASE)
        
        sql = re.sub(r'`{2,}', '`', sql)
        
        return sql
    
    def _optimize_text_searches(self, sql: str) -> str:
        """Optimize text field searches"""
        if 'UserMaster' not in self.schema_manager.schema_cache:
            return sql
            
        for col_name, col_info in self.schema_manager.schema_cache['UserMaster'].items():
            if col_info.get('type') in ['varchar', 'text', 'char']:
                patterns = [
                    (f"`{col_name}`\\s*=\\s*'([^']*)'", f"`{col_name}` LIKE '%\\1%'"),
                    (f"`{col_name}`\\s*=\\s*\"([^\"]*)\"", f"`{col_name}` LIKE '%\\1%'"),
                ]
                
                for pattern, replacement in patterns:
                    sql = re.sub(pattern, replacement, sql, flags=re.IGNORECASE)
        
        return sql
    
    def _finalize_sql(self, sql: str) -> str:
        """Final SQL cleanup and optimization"""
        if not sql:
            return sql
            
        sql = sql.strip().rstrip(';')
        
        if not re.search(r'\bLIMIT\b', sql, re.IGNORECASE):
            if not re.search(r'\bCOUNT\s*\(', sql, re.IGNORECASE):
                sql += " LIMIT 20"
        
        sql = re.sub(r'\s+', ' ', sql).strip()
        
        return sql

class ResultFormatter:
    """Formats query results for display"""
    
    @staticmethod
    def format_natural(result: List[Dict], question: str) -> str:
        """Format results in natural language with enhanced formatting"""
        if not result:
            return ResultFormatter._no_results_message(question)
        
        if len(result) == 1 and len(result[0]) == 1:
            value = list(result[0].values())[0]
            if "count" in question.lower():
                return f"""
                ╔════════════════════════════╗
                ║         Query Result        ║
                ╚════════════════════════════╝
                Total employees: {value}
                """
            return f"""
            ╔════════════════════════════╗
            ║         Query Result        ║
            ╚════════════════════════════╝
            Result: {value}
            """
        
        if len(result) == 1:
            return ResultFormatter._format_single_record(result[0])
        
        return ResultFormatter._format_multiple_records(result, question)
    
    @staticmethod
    def _no_results_message(question: str) -> str:
        """Generate helpful no results message"""
        suggestions = [
            "Try using broader search terms",
            "Check spelling of names or terms",
            "Try searching by partial matches",
            "Verify the data exists in the database"
        ]
        
        return f"""
        ╔════════════════════════════╗
        ║        No Results Found    ║
        ╚════════════════════════════╝
        No employee records found for: {question}
        
        📌 Suggestions:
        {'\n'.join(f"  • {suggestion}" for suggestion in suggestions)}
        """
    
    @staticmethod
    def _format_single_record(record: Dict) -> str:
        """Format single record with boxed layout"""
        field_patterns = [
            ('🆔 Employee ID', ['uid', 'id', 'emp_id', 'employee_id', 'user_id']),
            ('👤 Name', ['empname', 'name', 'employee_name', 'full_name', 'emp_name']),
            ('📞 Contact', ['contact', 'phone', 'mobile', 'cell', 'telephone']),
            ('📧 Email', ['email', 'mail', 'tcsemail', 'sbiemail', 'e_mail']),
            ('🔑 AD ID', ['adid', 'ad_id', 'active_directory_id']),
            ('💼 Position', ['position', 'role', 'designation', 'title', 'job']),
            ('📊 Level', ['level', 'grade', 'band']),
            ('👥 Team', ['team', 'department', 'group', 'dept']),
            ('📂 Project', ['project', 'proj'])
        ]
        
        response = ["╔════════════════════════════╗"]
        response.append("║      Employee Details      ║")
        response.append("╚════════════════════════════╝")
        
        displayed_fields = set()
        
        for icon_label, possible_fields in field_patterns:
            for field in possible_fields:
                actual_field = None
                for record_key in record.keys():
                    if record_key.lower() == field.lower():
                        actual_field = record_key
                        break
                
                if actual_field and record[actual_field] is not None and str(record[actual_field]).strip():
                    response.append(f"{icon_label}: {record[actual_field]}")
                    displayed_fields.add(actual_field)
                    break
        
        for key, value in record.items():
            if key not in displayed_fields and value is not None and str(value).strip():
                response.append(f"📋 {key}: {value}")
        
        return "\n".join(response)
    
    @staticmethod
    def _format_multiple_records(result: List[Dict], question: str) -> str:
        """Format multiple records with summary and boxed layout"""
        response = [
            "╔════════════════════════════╗",
            f"║ Found {len(result)} Employee Records ║",
            "╚════════════════════════════╝"
        ]
        
        team_field = None
        for field in ['Team', 'team', 'Department', 'department', 'Group', 'group']:
            if field in result[0]:
                team_field = field
                break
        
        if team_field:
            team_counts = {}
            for record in result:
                team = record.get(team_field, 'Unknown')
                if team:
                    team_counts[team] = team_counts.get(team, 0) + 1
            
            if len(team_counts) > 1:
                response.append("\n📊 Team Distribution:")
                for team, count in sorted(team_counts.items()):
                    response.append(f"  • {team}: {count} employees")
                response.append("")
        
        response.append("📋 Detailed Results:")
        response.append(ResultFormatter._format_tabular(result))
        
        return "\n".join(response)
    
    @staticmethod
    def _format_tabular(result: List[Dict]) -> str:
        """Format results in boxed table format"""
        if not result:
            return "No records found."
        
        columns = list(result[0].keys())
        col_widths = []
        for col in columns:
            max_width = max(
                len(str(col)),
                max(len(str(row.get(col, ''))) for row in result) if result else 0
            )
            col_widths.append(min(max_width, 30))
        
        output = []
        top_border = "┌" + "┬".join("─" * (width + 2) for width in col_widths) + "┐"
        mid_border = "├" + "┼".join("─" * (width + 2) for width in col_widths) + "┤"
        bot_border = "└" + "┴".join("─" * (width + 2) for width in col_widths) + "┘"
        
        output.append(top_border)
        header = "│" + " │ ".join(col.ljust(width) for col, width in zip(columns, col_widths)) + "│"
        output.append(header)
        output.append(mid_border)
        
        for row in result:
            formatted_row = "│" + " │ ".join(
                str(row.get(col, ''))[:27] + "..." if len(str(row.get(col, ''))) > 30 
                else str(row.get(col, '')).ljust(width)
                for col, width in zip(columns, col_widths)
            ) + "│"
            output.append(formatted_row)
        
        output.append(bot_border)
        output.append(f"\nTotal records displayed: {len(result)}")
        return "\n".join(output)

class FallbackSQLGenerator:
    """Fallback SQL generator when LangChain is not available"""
    
    def __init__(self, schema_manager: DatabaseSchemaManager):
        self.schema_manager = schema_manager
    
    @lru_cache(maxsize=1000)
    def generate_sql(self, question: str) -> str:
        """Generate SQL using pattern matching"""
        question_lower = question.lower()
        safe_columns = self.schema_manager.get_safe_columns()
        
        if not safe_columns:
            return "SELECT * FROM UserMaster LIMIT 20"
        
        if re.search(r'\b(\d+)\b', question):
            id_match = re.search(r'\b(\d+)\b', question)
            id_column = self.schema_manager._find_column_by_patterns(['uid', 'id', 'user_id', 'emp_id'])
            if id_match and id_column:
                return f"SELECT * FROM UserMaster WHERE `{id_column}` = {id_match.group(1)}"
        
        name_patterns = [r'details?\s+(?:about|of)\s+(\w+)', r'(?:info|information)\s+(?:about|of)\s+(\w+)', r'find\s+(\w+)']
        for pattern in name_patterns:
            match = re.search(pattern, question_lower)
            if match:
                name = match.group(1)
                name_column = self.schema_manager._find_column_by_patterns(['name', 'emp_name', 'employee_name'])
                if name_column:
                    return f"SELECT * FROM UserMaster WHERE `{name_column}` LIKE '%{name}%'"
        
        if any(term in question_lower for term in ['phone', 'contact', 'mobile', 'number']):
            contact_column = self.schema_manager._find_column_by_patterns(['contact', 'phone', 'mobile'])
            name_match = re.search(r'(?:phone|contact|mobile|number)\s+(?:of|for)\s+(\w+)', question_lower)
            if contact_column and name_match:
                name = name_match.group(1)
                name_column = self.schema_manager._find_column_by_patterns(['name', 'emp_name', 'employee_name'])
                if name_column:
                    return f"SELECT `{contact_column}` FROM UserMaster WHERE `{name_column}` LIKE '%{name}%'"
        
        if 'count' in question_lower:
            return "SELECT COUNT(*) as total_employees FROM UserMaster"
        
        if any(term in question_lower for term in ['team', 'department', 'group']):
            team_column = self.schema_manager._find_column_by_patterns(['team', 'department', 'group'])
            if team_column:
                return f"SELECT `{team_column}`, COUNT(*) as count FROM UserMaster GROUP BY `{team_column}`"
        
        return "SELECT * FROM UserMaster LIMIT 20"

class TeamDetailsAssistant:
    def __init__(self):
        self.llm = None
        self.connection_pool = None
        self.schema_manager = None
        self.sql_processor = None
        self.fallback_generator = None
        self.initialized = False
    
    def initialize(self) -> bool:
        """Initialize the assistant with robust error handling"""
        try:
            logger.info("Initializing Team Details Assistant...")
            
            if not self._init_database():
                return False
            
            self._init_llm()
            
            self.schema_manager = DatabaseSchemaManager(self.connection_pool)
            self.sql_processor = SQLQueryProcessor(self.schema_manager)
            self.fallback_generator = FallbackSQLGenerator(self.schema_manager)
            
            self.initialized = True
            logger.info("Team Details Assistant initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"Initialization failed: {e}\n{traceback.format_exc()}")
            return False
    
    def _init_database(self) -> bool:
        """Initialize database connection pool"""
        try:
            db_cfg = TEAM_DB_CONFIG['db_config']
            print(f"DEBUG - Creating connection pool: {db_cfg['host']}/{db_cfg['database']}")
            
            self.connection_pool = mysql.connector.pooling.MySQLConnectionPool(
                pool_name=db_cfg['pool_name'],
                pool_size=db_cfg['pool_size'],
                host=db_cfg['host'],
                user=db_cfg['user'],
                password=db_cfg['password'],
                database=db_cfg['database'],
                charset='utf8mb4',
                use_pure=True,
                connect_timeout=10,
                option_files=None
            )
            
            connection = self.connection_pool.get_connection()
            with connection.cursor(dictionary=True) as cursor:
                cursor.execute("SELECT 1 as test")
                test_result = cursor.fetchone()
                print(f"DEBUG - Database connection test: {test_result}")
            connection.close()
            
            print("DEBUG - Connection pool created successfully")
            logger.info("Database connection pool established")
            return True
            
        except Exception as e:
            error_msg = f"Connection pool creation failed: {e}"
            logger.error(error_msg)
            print(f"DEBUG - {error_msg}")
            
            db_cfg = TEAM_DB_CONFIG['db_config']
            print(f"DEBUG - Connection details:")
            print(f"DEBUG -   Host: {db_cfg['host']}")
            print(f"DEBUG -   User: {db_cfg['user']}")
            print(f"DEBUG -   Database: {db_cfg['database']}")
            
            return False
    
    def _init_llm(self) -> bool:
        """Initialize LLM (optional)"""
        try:
            if LANGCHAIN_AVAILABLE:
                self.llm = OllamaLLM(model="myllm:latest", temperature=0.1)
                test_response = self.llm.invoke("SELECT 1")
                logger.info("LLM initialized successfully")
                return True
            else:
                logger.info("LangChain not available, using fallback SQL generation")
                return False
                
        except Exception as e:
            logger.warning(f"LLM initialization failed, using fallback: {e}")
            return False
    
    def process_question(self, question: str) -> str:
        """Process user question and return results"""
        if not self.initialized and not self.initialize():
            return """
            ╔════════════════════════════╗
            ║        Error Occurred      ║
            ╚════════════════════════════╝
            Initialization failed. Please check database connection.
            """
        
        if is_dangerous(question):
            return """
            ╔════════════════════════════╗
            ║        Security Alert      ║
            ╚════════════════════════════╝
            Question blocked for security reasons.
            """
        
        try:
            print(f"DEBUG - Processing question: {question}")
            
            mapped_question = self.schema_manager.map_user_terms(question)
            print(f"DEBUG - Mapped question: {mapped_question}")
            
            if self.llm and LANGCHAIN_AVAILABLE:
                print("DEBUG - Using LLM for SQL generation")
                raw_sql = self._generate_sql_with_llm(mapped_question)
            else:
                print("DEBUG - Using fallback SQL generation")
                raw_sql = self.fallback_generator.generate_sql(question)
            
            print(f"DEBUG - Raw SQL generated: {raw_sql}")
            
            final_sql, is_valid = self.sql_processor.clean_and_validate_sql(raw_sql, question)
            print(f"DEBUG - Final SQL: {final_sql}")
            print(f"DEBUG - SQL is valid: {is_valid}")
            
            if not is_valid:
                return f"""
                ╔════════════════════════════╗
                ║        Invalid Query       ║
                ╚════════════════════════════╝
                Could not generate valid SQL query. Please rephrase your question.
                Debug info: {raw_sql}
                """
            
            result = self._execute_query(final_sql)
            
            if result is None:
                return """
                ╔════════════════════════════╗
                ║        Query Failed        ║
                ╚════════════════════════════╝
                Query execution failed. Check the debug output for details.
                """
            
            print(f"DEBUG - Query execution successful, formatting results...")
            
            formatted_result = ResultFormatter.format_natural(result, question)
            return formatted_result
            
        except Exception as e:
            error_trace = traceback.format_exc()
            logger.error(f"Question processing error: {e}\n{error_trace}")
            print(f"DEBUG - Question processing error: {e}")
            print(f"DEBUG - Full traceback: {error_trace}")
            return f"""
            ╔════════════════════════════╗
            ║        Error Occurred      ║
            ╚════════════════════════════╝
            Error processing your question: {str(e)}
            """
    
    def _generate_sql_with_llm(self, question: str) -> str:
        """Generate SQL using LLM"""
        try:
            schema_info = self.schema_manager.get_column_info_string()
            safe_columns = self.schema_manager.get_safe_columns()
            
            context = f"""
Question: {question}

Database: UserMaster table with the following columns:
{schema_info}

IMPORTANT RULES:
1. ONLY use SELECT statements
2. ONLY reference these available columns: {', '.join(safe_columns)}
3. Use LIKE '%value%' for text searches, not exact equals
4. For numeric IDs, use exact equals (=)
5. Always include proper table name: UserMaster
6. Do not include sensitive fields in any query
7. Limit results appropriately (use LIMIT clause)

Generate a SQL query to answer the question.
"""
            
            if LANGCHAIN_AVAILABLE:
                db_cfg = TEAM_DB_CONFIG['db_config']
                uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"
                
                db_for_llm = SQLDatabase.from_uri(
                    uri,
                    include_tables=TEAM_DB_CONFIG.get("include_tables", ["UserMaster"])
                )
                
                chain = create_sql_query_chain(self.llm, db_for_llm)
                raw_sql = chain.invoke({"question": context})
                
                logger.info(f"Generated SQL with LLM: {raw_sql}")
                return raw_sql
            else:
                return self.fallback_generator.generate_sql(question)
                
        except Exception as e:
            logger.error(f"SQL generation with LLM failed: {e}")
            return self.fallback_generator.generate_sql(question)
    
    def _execute_query(self, sql: str) -> Optional[List[Dict]]:
        """Execute SQL query safely"""
        connection = None
        try:
            connection = self.connection_pool.get_connection()
            
            with connection.cursor(dictionary=True) as cursor:
                logger.info(f"Executing SQL: {sql}")
                print(f"DEBUG - Executing SQL: {sql}")
                
                cursor.execute(sql)
                result = cursor.fetchall()
                
                logger.info(f"Query returned {len(result)} rows")
                print(f"DEBUG - Query returned {len(result)} rows")
                
                return result
                
        except mysql.connector.Error as e:
            error_code = e.errno if hasattr(e, 'errno') else 'Unknown'
            error_msg = str(e)
            
            logger.error(f"MySQL Error {error_code}: {error_msg}")
            print(f"DEBUG - MySQL Error {error_code}: {error_msg}")
            print(f"DEBUG - Failed SQL: {sql}")
            
            if "Unknown column" in error_msg:
                available_cols = self.schema_manager.get_safe_columns()
                print(f"DEBUG - Available columns: {available_cols}")
                logger.error(f"Available columns: {available_cols}")
            elif "Table" in error_msg and "doesn't exist" in error_msg:
                logger.error("UserMaster table doesn't exist")
                print("DEBUG - UserMaster table doesn't exist")
            elif "Access denied" in error_msg:
                logger.error("Database access denied - check credentials")
                print("DEBUG - Database access denied")
            
            return None
            
        except Exception as e:
            logger.error(f"Unexpected query execution error: {e}\n{traceback.format_exc()}")
            print(f"DEBUG - Unexpected error: {e}")
            print(f"DEBUG - Failed SQL: {sql}")
            return None
        finally:
            if connection:
                connection.close()
    
    def cleanup(self):
        """Clean up resources"""
        try:
            if self.connection_pool:
                self.connection_pool._remove_connections()
                logger.info("Connection pool closed")
        except Exception as e:
            logger.error(f"Cleanup error: {e}")

def Teammain(query: str) -> str:
    """Main function to process team queries"""
    if not query or not query.strip():
        return """
        ╔════════════════════════════╗
        ║        Invalid Input       ║
        ╚════════════════════════════╝
        Please provide a valid query.
        """
    
    logger.info(f"Processing query: {query}")
    assistant = TeamDetailsAssistant()
    
    try:
        result = assistant.process_question(query.strip())
        return result
    except Exception as e:
        logger.error(f"Main function error: {e}")
        return f"""
        ╔════════════════════════════╗
        ║        Error Occurred      ║
        ╚════════════════════════════╝
        An unexpected error occurred: {str(e)}
        """
    finally:
        assistant.cleanup()

if __name__ == "__main__":
    test_queries = [
        "Show me employee with ID 12345",
        "tell me details about aryan",
        "details of abhishek", 
        "phone number of aryan",
        "details of 2798445",
        "List all employees in team ABC",
        "Count employees by team"
    ]
    
    print("╔════════════════════════════════════════╗")
    print("║     Team Details Assistant Tests       ║")
    print("╚════════════════════════════════════════╝")
    
    for i, query in enumerate(test_queries, 1):
        print(f"\n🔍 Test {i}: {query}")
        print("─" * 40)
        try:
            result = Teammain(query)
            print(result)
        except Exception as e:
            print(f"""
            ╔════════════════════════════╗
            ║        Test Failed         ║
            ╚════════════════════════════╝
            Error in test {i}: {e}
            """)
        print("─" * 40)
    
    print("\n✅ All tests completed!")
