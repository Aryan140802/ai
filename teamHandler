import os
import re
import logging
import pymysql
import traceback
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime
import json
import sqlparse

# Try to import langchain components, but continue if not available
try:
    from langchain_community.utilities import SQLDatabase
    from langchain_ollama import OllamaLLM
    from langchain.chains import create_sql_query_chain
    LANGCHAIN_AVAILABLE = True
except ImportError:
    LANGCHAIN_AVAILABLE = False
    print("Warning: LangChain not available. Using fallback SQL generation.")

# --- TEAM DETAILS CONFIGURATION ---
TEAM_DB_CONFIG = {
    "name": "Team Details",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["UserMaster"],
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

# Sensitive field patterns (case-insensitive)
SENSITIVE_PATTERNS = [
    r"pwd", r"password", r"pass", r"secq", r"seca", r"secret", 
    r"auth", r"token", r"key", r"hash", r"salt"
]

# Setup logging
log_dir = os.path.expanduser("~")
log_file = os.path.join(log_dir, ".team_details_ai.log")

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    """Check if text contains dangerous patterns"""
    if not text:
        return False
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def is_sensitive_field(field_name: str) -> bool:
    """Check if field name contains sensitive information"""
    if not field_name:
        return False
    return any(re.search(pattern, field_name.lower()) for pattern in SENSITIVE_PATTERNS)

class DatabaseSchemaManager:
    """Manages database schema discovery and caching"""
    
    def __init__(self, connection):
        self.connection = connection
        self.schema_cache = {}
        self.field_mappings = {}
        self.safe_columns = []
        self.load_schema()
    
    def load_schema(self):
        """Load and cache database schema"""
        try:
            with self.connection.cursor() as cursor:
                # Get all columns for UserMaster table
                cursor.execute("""
                    SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE, COLUMN_DEFAULT, COLUMN_COMMENT
                    FROM INFORMATION_SCHEMA.COLUMNS 
                    WHERE TABLE_SCHEMA = %s AND TABLE_NAME = 'UserMaster'
                    ORDER BY ORDINAL_POSITION
                """, (TEAM_DB_CONFIG['db_config']['database'],))
                
                columns = cursor.fetchall()
                
                if not columns:
                    raise Exception("UserMaster table not found or no columns accessible")
                
                self.schema_cache['UserMaster'] = {}
                self.safe_columns = []
                
                for col in columns:
                    col_name = col['COLUMN_NAME']
                    col_type = col['DATA_TYPE']
                    
                    # Skip sensitive fields
                    if is_sensitive_field(col_name):
                        logger.info(f"Skipping sensitive field: {col_name}")
                        continue
                    
                    self.safe_columns.append(col_name)
                    self.schema_cache['UserMaster'][col_name] = {
                        'type': col_type,
                        'nullable': col['IS_NULLABLE'] == 'YES',
                        'default': col['COLUMN_DEFAULT'],
                        'comment': col['COLUMN_COMMENT'] or ''
                    }
                
                logger.info(f"Loaded schema with {len(self.safe_columns)} safe columns: {self.safe_columns}")
                
                # Create intelligent field mappings based on actual columns
                self._create_field_mappings()
                
        except Exception as e:
            logger.error(f"Schema loading failed: {e}")
            # Set default safe columns if schema loading fails
            self.safe_columns = ['*']  # Will be handled by query processor
            raise
    
    def _create_field_mappings(self):
        """Create intelligent field mappings based on actual column names"""
        self.field_mappings = {}
        
        # Find actual columns for common terms
        id_col = self._find_column_by_patterns(['uid', 'user_?id', 'emp_?id', 'employee_?id', '^id$'])
        name_col = self._find_column_by_patterns(['name', 'emp_?name', 'employee_?name', 'full_?name'])
        contact_col = self._find_column_by_patterns(['contact', 'phone', 'mobile', 'cell'])
        email_col = self._find_column_by_patterns(['email', 'mail', 'e_?mail'])
        position_col = self._find_column_by_patterns(['position', 'role', 'designation', 'title'])
        team_col = self._find_column_by_patterns(['team', 'group', 'department', 'dept'])
        project_col = self._find_column_by_patterns(['project', 'proj'])
        level_col = self._find_column_by_patterns(['level', 'grade', 'band'])
        
        # Create mappings
        if id_col:
            self.field_mappings['id'] = id_col
            self.field_mappings['employee_id'] = id_col
            self.field_mappings['emp_id'] = id_col
            self.field_mappings['user_id'] = id_col
        
        if name_col:
            self.field_mappings['name'] = name_col
            self.field_mappings['employee_name'] = name_col
            self.field_mappings['emp_name'] = name_col
        
        if contact_col:
            self.field_mappings['phone'] = contact_col
            self.field_mappings['mobile'] = contact_col
            self.field_mappings['contact'] = contact_col
            self.field_mappings['phone_number'] = contact_col
        
        if email_col:
            self.field_mappings['email'] = email_col
            self.field_mappings['mail'] = email_col
        
        if position_col:
            self.field_mappings['position'] = position_col
            self.field_mappings['role'] = position_col
            self.field_mappings['designation'] = position_col
        
        if team_col:
            self.field_mappings['team'] = team_col
            self.field_mappings['department'] = team_col
            self.field_mappings['group'] = team_col
        
        if project_col:
            self.field_mappings['project'] = project_col
        
        if level_col:
            self.field_mappings['level'] = level_col
            self.field_mappings['grade'] = level_col
    
    def _find_column_by_patterns(self, patterns: List[str]) -> Optional[str]:
        """Find column by matching patterns"""
        for pattern in patterns:
            for col in self.safe_columns:
                if re.search(pattern, col.lower()):
                    return col
        return None
    
    def get_safe_columns(self) -> List[str]:
        """Get list of safe (non-sensitive) columns"""
        return self.safe_columns.copy()
    
    def map_user_terms(self, question: str) -> str:
        """Map user terms to actual database columns"""
        mapped_question = question.lower()
        
        for term, actual_column in self.field_mappings.items():
            pattern = rf'\b{re.escape(term)}\b'
            mapped_question = re.sub(pattern, actual_column, mapped_question, flags=re.IGNORECASE)
        
        return mapped_question
    
    def get_column_info_string(self) -> str:
        """Get formatted column information for LLM context"""
        if 'UserMaster' not in self.schema_cache:
            return f"Available columns: {', '.join(self.safe_columns)}"
        
        info_parts = []
        for col_name, col_info in self.schema_cache['UserMaster'].items():
            type_info = col_info['type']
            if type_info in ['varchar', 'text', 'char']:
                usage = "text - use LIKE '%value%' for partial matching"
            elif type_info in ['int', 'bigint', 'decimal']:
                usage = "numeric - use = for exact matching"
            elif type_info in ['datetime', 'date', 'timestamp']:
                usage = "date - use appropriate date functions"
            else:
                usage = f"{type_info} - handle appropriately"
            
            info_parts.append(f"{col_name}: {usage}")
        
        return "\n".join(info_parts)

class SQLQueryProcessor:
    """Processes and validates SQL queries"""
    
    def __init__(self, schema_manager: DatabaseSchemaManager):
        self.schema_manager = schema_manager
    
    def clean_and_validate_sql(self, raw_sql: str, question: str) -> Tuple[str, bool]:
        """Clean SQL and validate it's safe"""
        try:
            logger.info(f"Processing raw SQL: {raw_sql}")
            
            # Handle non-SQL responses
            if not self._contains_sql(raw_sql):
                # Try to construct SQL from question
                constructed_sql = self._construct_sql_from_question(question)
                if constructed_sql:
                    return self._finalize_sql(constructed_sql), True
                return "", False
            
            # Extract SQL from various formats
            sql = self._extract_sql(raw_sql)
            
            if not sql:
                return "", False
            
            # Validate and clean
            if not self._is_safe_select(sql):
                return "", False
            
            # Remove sensitive fields
            sql = self._remove_sensitive_fields(sql)
            
            # Fix column references
            sql = self._fix_column_references(sql)
            
            # Optimize for text searches
            sql = self._optimize_text_searches(sql)
            
            # Add limits and final cleanup
            sql = self._finalize_sql(sql)
            
            logger.info(f"Final processed SQL: {sql}")
            return sql, True
            
        except Exception as e:
            logger.error(f"SQL processing error: {e}")
            return "", False
    
    def _contains_sql(self, text: str) -> bool:
        """Check if text contains SQL"""
        if not text:
            return False
        sql_indicators = ['select', 'from', 'where', 'join']
        text_lower = text.lower()
        return any(indicator in text_lower for indicator in sql_indicators)
    
    def _extract_sql(self, raw_sql: str) -> str:
        """Extract SQL from various formats"""
        if not raw_sql:
            return ""
            
        # Try code block first
        code_block_match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
        if code_block_match:
            return code_block_match.group(1).strip()
        
        # Try to find SELECT statement
        select_match = re.search(r"(SELECT.*?)(?:\n\n|$|;)", raw_sql, re.IGNORECASE | re.DOTALL)
        if select_match:
            return select_match.group(1).strip()
        
        # Clean and return
        sql = re.sub(r"```", "", raw_sql)
        sql = re.sub(r"^.*?(SELECT|INSERT|UPDATE|DELETE)", r"\1", sql, flags=re.IGNORECASE | re.DOTALL)
        return sql.strip()
    
    def _construct_sql_from_question(self, question: str) -> Optional[str]:
        """Construct basic SQL from question patterns"""
        safe_columns = self.schema_manager.get_safe_columns()
        if not safe_columns:
            return None
        
        question_lower = question.lower()
        
        # Look for ID-based queries
        id_match = re.search(r'\b(\d+)\b', question)
        id_column = self.schema_manager._find_column_by_patterns(['uid', 'id', 'user_id', 'emp_id'])
        
        if id_match and id_column:
            return f"SELECT * FROM UserMaster WHERE `{id_column}` = {id_match.group(1)}"
        
        # Look for name-based queries
        name_column = self.schema_manager._find_column_by_patterns(['name', 'emp_name', 'employee_name'])
        if name_column:
            # Extract potential name
            name_match = re.search(r'(?:details?|info|about|of)\s+(\w+)', question_lower)
            if name_match:
                name = name_match.group(1)
                return f"SELECT * FROM UserMaster WHERE `{name_column}` LIKE '%{name}%'"
        
        # Default: select all with limit
        return "SELECT * FROM UserMaster LIMIT 10"
    
    def _is_safe_select(self, sql: str) -> bool:
        """Validate SQL is safe SELECT only"""
        if not sql:
            return False
            
        sql_clean = sql.strip().lower()
        
        if not sql_clean.startswith('select'):
            return False
        
        dangerous_keywords = [
            'insert', 'update', 'delete', 'drop', 'alter', 'create', 
            'truncate', 'exec', 'execute', 'sp_', 'xp_'
        ]
        
        return not any(keyword in sql_clean for keyword in dangerous_keywords)
    
    def _remove_sensitive_fields(self, sql: str) -> str:
        """Remove references to sensitive fields"""
        safe_columns = self.schema_manager.get_safe_columns()
        
        if not safe_columns:
            return sql
        
        # If SELECT *, replace with safe columns
        if re.search(r'SELECT\s+\*', sql, re.IGNORECASE):
            safe_cols_str = ', '.join(f"`{col}`" for col in safe_columns if col != '*')
            if safe_cols_str:
                sql = re.sub(r'SELECT\s+\*', f'SELECT {safe_cols_str}', sql, flags=re.IGNORECASE)
        
        return sql
    
    def _fix_column_references(self, sql: str) -> str:
        """Fix column references to match actual schema"""
        safe_columns = self.schema_manager.get_safe_columns()
        
        # Create a mapping of quoted and unquoted column references
        for actual_col in safe_columns:
            if actual_col == '*':
                continue
                
            # Replace various quote styles with backticks
            patterns = [
                (f'`{actual_col}`', f'`{actual_col}`'),
                (f'"{actual_col}"', f'`{actual_col}`'),
                (f"'{actual_col}'", f'`{actual_col}`'),
                (f'\\b{re.escape(actual_col)}\\b', f'`{actual_col}`')
            ]
            
            for pattern, replacement in patterns:
                sql = re.sub(pattern, replacement, sql, flags=re.IGNORECASE)
        
        return sql
    
    def _optimize_text_searches(self, sql: str) -> str:
        """Optimize text field searches"""
        if 'UserMaster' not in self.schema_manager.schema_cache:
            return sql
            
        for col_name, col_info in self.schema_manager.schema_cache['UserMaster'].items():
            if col_info.get('type') in ['varchar', 'text', 'char']:
                # Convert = to LIKE for text fields - handle various quote patterns
                patterns = [
                    (f"`{col_name}`\\s*=\\s*'([^']*)'", f"`{col_name}` LIKE '%\\1%'"),
                    (f"`{col_name}`\\s*=\\s*\"([^\"]*)\"", f"`{col_name}` LIKE '%\\1%'"),
                ]
                
                for pattern, replacement in patterns:
                    sql = re.sub(pattern, replacement, sql, flags=re.IGNORECASE)
        
        return sql
    
    def _finalize_sql(self, sql: str) -> str:
        """Final SQL cleanup and optimization"""
        if not sql:
            return sql
            
        # Remove trailing semicolons
        sql = sql.strip().rstrip(';')
        
        # Add reasonable limit if none exists
        if not re.search(r'\bLIMIT\b', sql, re.IGNORECASE):
            if not re.search(r'\bCOUNT\s*\(', sql, re.IGNORECASE):
                sql += " LIMIT 50"
        
        # Clean up extra whitespace
        sql = re.sub(r'\s+', ' ', sql).strip()
        
        return sql

class ResultFormatter:
    """Formats query results for display"""
    
    @staticmethod
    def format_natural(result: List[Dict], question: str) -> str:
        """Format results in natural language"""
        if not result:
            return ResultFormatter._no_results_message(question)
        
        # Handle single value results
        if len(result) == 1 and len(result[0]) == 1:
            value = list(result[0].values())[0]
            if "count" in question.lower():
                return f"There are {value} employee records matching your criteria."
            return f"The result is: {value}"
        
        # Handle single record
        if len(result) == 1:
            return ResultFormatter._format_single_record(result[0])
        
        # Handle multiple records
        return ResultFormatter._format_multiple_records(result, question)
    
    @staticmethod
    def _no_results_message(question: str) -> str:
        """Generate helpful no results message"""
        suggestions = [
            "Try using broader search terms",
            "Check spelling of names or terms",
            "Try searching by partial matches",
            "Verify the data exists in the database"
        ]
        
        response = "I couldn't find any employee records matching your criteria.\n\n"
        response += "ğŸ’¡ Suggestions:\n"
        response += "\n".join(f"â€¢ {suggestion}" for suggestion in suggestions)
        
        return response
    
    @staticmethod
    def _format_single_record(record: Dict) -> str:
        """Format single record nicely"""
        response = "I found 1 employee record:\n\n"
        
        # Define display order and icons with flexible field matching
        field_patterns = [
            ('ğŸ†” Employee ID', ['uid', 'id', 'emp_id', 'employee_id', 'user_id']),
            ('ğŸ‘¤ Name', ['empname', 'name', 'employee_name', 'full_name', 'emp_name']),
            ('ğŸ“ Contact', ['contact', 'phone', 'mobile', 'cell', 'telephone']),
            ('ğŸ“§ Email', ['email', 'mail', 'tcsemail', 'sbiemail', 'e_mail']),
            ('ğŸ”‘ AD ID', ['adid', 'ad_id', 'active_directory_id']),
            ('ğŸ’¼ Position', ['position', 'role', 'designation', 'title', 'job']),
            ('ğŸ“Š Level', ['level', 'grade', 'band']),
            ('ğŸ‘¥ Team', ['team', 'department', 'group', 'dept']),
            ('ğŸ“‚ Project', ['project', 'proj'])
        ]
        
        displayed_fields = set()
        
        for icon_label, possible_fields in field_patterns:
            for field in possible_fields:
                # Find matching field (case-insensitive)
                actual_field = None
                for record_key in record.keys():
                    if record_key.lower() == field.lower():
                        actual_field = record_key
                        break
                
                if actual_field and record[actual_field] is not None and str(record[actual_field]).strip():
                    response += f"{icon_label}: {record[actual_field]}\n"
                    displayed_fields.add(actual_field)
                    break
        
        # Add any remaining fields not in the standard display
        for key, value in record.items():
            if key not in displayed_fields and value is not None and str(value).strip():
                response += f"ğŸ“‹ {key}: {value}\n"
        
        return response.strip()
    
    @staticmethod
    def _format_multiple_records(result: List[Dict], question: str) -> str:
        """Format multiple records with summary"""
        response = f"I found {len(result)} employee records matching your criteria:\n\n"
        
        # Add summary if we have team information
        team_field = None
        for field in ['Team', 'team', 'Department', 'department', 'Group', 'group']:
            if field in result[0]:
                team_field = field
                break
        
        if team_field:
            team_counts = {}
            for record in result:
                team = record.get(team_field, 'Unknown')
                if team:
                    team_counts[team] = team_counts.get(team, 0) + 1
            
            if len(team_counts) > 1:
                response += "ğŸ“Š Team Summary:\n"
                for team, count in sorted(team_counts.items()):
                    response += f"   â€¢ {team}: {count} employees\n"
                response += "\n"
        
        # Show detailed results
        response += "ğŸ“‹ Detailed Results:\n"
        response += ResultFormatter._format_tabular(result)
        
        return response
    
    @staticmethod
    def _format_tabular(result: List[Dict]) -> str:
        """Format results in table format"""
        if not result:
            return "No records found."
        
        columns = list(result[0].keys())
        
        # Calculate column widths
        col_widths = []
        for col in columns:
            max_width = max(
                len(str(col)),
                max(len(str(row.get(col, ''))) for row in result) if result else 0
            )
            col_widths.append(min(max_width, 30))  # Cap at 30 chars
        
        # Build table
        output = []
        
        # Header
        header = " | ".join(col.ljust(width) for col, width in zip(columns, col_widths))
        separator = "-+-".join("-" * width for width in col_widths)
        output.append(header)
        output.append(separator)
        
        # Rows
        for row in result:
            formatted_row = " | ".join(
                str(row.get(col, ''))[:27] + "..." if len(str(row.get(col, ''))) > 30 
                else str(row.get(col, '')).ljust(width)
                for col, width in zip(columns, col_widths)
            )
            output.append(formatted_row)
        
        output.append(f"\nTotal records: {len(result)}")
        return "\n".join(output)

class FallbackSQLGenerator:
    """Fallback SQL generator when LangChain is not available"""
    
    def __init__(self, schema_manager: DatabaseSchemaManager):
        self.schema_manager = schema_manager
    
    def generate_sql(self, question: str) -> str:
        """Generate SQL using pattern matching"""
        question_lower = question.lower()
        safe_columns = self.schema_manager.get_safe_columns()
        
        if not safe_columns:
            return "SELECT * FROM UserMaster LIMIT 10"
        
        # Pattern-based SQL generation
        if re.search(r'\b(\d+)\b', question):
            # ID-based query
            id_match = re.search(r'\b(\d+)\b', question)
            id_column = self.schema_manager._find_column_by_patterns(['uid', 'id', 'user_id', 'emp_id'])
            if id_match and id_column:
                return f"SELECT * FROM UserMaster WHERE `{id_column}` = {id_match.group(1)}"
        
        # Name-based query
        name_patterns = [r'details?\s+(?:about|of)\s+(\w+)', r'(?:info|information)\s+(?:about|of)\s+(\w+)', r'find\s+(\w+)']
        for pattern in name_patterns:
            match = re.search(pattern, question_lower)
            if match:
                name = match.group(1)
                name_column = self.schema_manager._find_column_by_patterns(['name', 'emp_name', 'employee_name'])
                if name_column:
                    return f"SELECT * FROM UserMaster WHERE `{name_column}` LIKE '%{name}%'"
        
        # Phone/contact query
        if any(term in question_lower for term in ['phone', 'contact', 'mobile', 'number']):
            contact_column = self.schema_manager._find_column_by_patterns(['contact', 'phone', 'mobile'])
            name_match = re.search(r'(?:phone|contact|mobile|number)\s+(?:of|for)\s+(\w+)', question_lower)
            if contact_column and name_match:
                name = name_match.group(1)
                name_column = self.schema_manager._find_column_by_patterns(['name', 'emp_name', 'employee_name'])
                if name_column:
                    return f"SELECT `{contact_column}` FROM UserMaster WHERE `{name_column}` LIKE '%{name}%'"
        
        # Count queries
        if 'count' in question_lower:
            return "SELECT COUNT(*) as total_employees FROM UserMaster"
        
        # Team queries
        if any(term in question_lower for term in ['team', 'department', 'group']):
            team_column = self.schema_manager._find_column_by_patterns(['team', 'department', 'group'])
            if team_column:
                return f"SELECT `{team_column}`, COUNT(*) as count FROM UserMaster GROUP BY `{team_column}`"
        
        # Default query
        return "SELECT * FROM UserMaster LIMIT 10"

class TeamDetailsAssistant:
    def __init__(self):
        self.llm = None
        self.db_connection = None
        self.schema_manager = None
        self.sql_processor = None
        self.fallback_generator = None
        self.initialized = False
    
    def initialize(self) -> bool:
        """Initialize the assistant with robust error handling"""
        try:
            logger.info("Initializing Team Details Assistant...")
            
            # Initialize database connection first
            if not self._init_database():
                return False
            
            # Initialize LLM (optional)
            self._init_llm()
            
            # Initialize schema manager
            self.schema_manager = DatabaseSchemaManager(self.db_connection)
            self.sql_processor = SQLQueryProcessor(self.schema_manager)
            self.fallback_generator = FallbackSQLGenerator(self.schema_manager)
            
            self.initialized = True
            logger.info("Team Details Assistant initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"Initialization failed: {e}\n{traceback.format_exc()}")
            return False
    
    def _init_database(self) -> bool:
        """Initialize database connection"""
        try:
            db_cfg = TEAM_DB_CONFIG['db_config']
            self.db_connection = pymysql.connect(
                host=db_cfg['host'],
                user=db_cfg['user'],
                password=db_cfg['password'],
                database=db_cfg['database'],
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor,
                autocommit=True,
                connect_timeout=10,
                read_timeout=30
            )
            
            # Test connection
            with self.db_connection.cursor() as cursor:
                cursor.execute("SELECT 1")
                cursor.fetchone()
            
            logger.info("Database connection established")
            return True
            
        except Exception as e:
            logger.error(f"Database connection failed: {e}")
            return False
    
    def _init_llm(self) -> bool:
        """Initialize LLM (optional)"""
        try:
            if LANGCHAIN_AVAILABLE:
                self.llm = OllamaLLM(model="myllm:latest", temperature=0.1)
                # Test LLM
                test_response = self.llm.invoke("SELECT 1")
                logger.info("LLM initialized successfully")
                return True
            else:
                logger.info("LangChain not available, using fallback SQL generation")
                return False
                
        except Exception as e:
            logger.warning(f"LLM initialization failed, using fallback: {e}")
            return False
    
    def process_question(self, question: str) -> str:
        """Process user question and return results"""
        if not self.initialized and not self.initialize():
            return "âŒ Team Details Assistant initialization failed. Please check database connection."
        
        if is_dangerous(question):
            return "âŒ Question blocked for security reasons."
        
        try:
            # Map user terms to database columns
            mapped_question = self.schema_manager.map_user_terms(question)
            
            # Generate SQL
            if self.llm and LANGCHAIN_AVAILABLE:
                raw_sql = self._generate_sql_with_llm(mapped_question)
            else:
                raw_sql = self.fallback_generator.generate_sql(question)
            
            # Process and validate SQL
            final_sql, is_valid = self.sql_processor.clean_and_validate_sql(raw_sql, question)
            
            if not is_valid:
                return f"âŒ Could not generate valid SQL query. Please rephrase your question.\nDebug info: {raw_sql}"
            
            # Execute query
            result = self._execute_query(final_sql)
            
            if result is None:
                return "âŒ Query execution failed. Please try again."
            
            # Format and return results
            formatted_result = ResultFormatter.format_natural(result, question)
            return formatted_result
            
        except Exception as e:
            logger.error(f"Question processing error: {e}\n{traceback.format_exc()}")
            return f"âŒ Error processing your question: {str(e)}"
    
    def _generate_sql_with_llm(self, question: str) -> str:
        """Generate SQL using LLM"""
        try:
            # Create context for LLM
            schema_info = self.schema_manager.get_column_info_string()
            safe_columns = self.schema_manager.get_safe_columns()
            
            context = f"""
Question: {question}

Database: UserMaster table with the following columns:
{schema_info}

IMPORTANT RULES:
1. ONLY use SELECT statements
2. ONLY reference these available columns: {', '.join(safe_columns)}
3. Use LIKE '%value%' for text searches, not exact equals
4. For numeric IDs, use exact equals (=)
5. Always include proper table name: UserMaster
6. Do not include sensitive fields in any query
7. Limit results appropriately (use LIMIT clause)

Generate a SQL query to answer the question.
"""
            
            # Create a simple query chain if possible
            if LANGCHAIN_AVAILABLE:
                db_cfg = TEAM_DB_CONFIG['db_config']
                uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"
                
                db_for_llm = SQLDatabase.from_uri(
                    uri,
                    include_tables=TEAM_DB_CONFIG.get("include_tables", ["UserMaster"])
                )
                
                chain = create_sql_query_chain(self.llm, db_for_llm)
                raw_sql = chain.invoke({"question": context})
                
                logger.info(f"Generated SQL with LLM: {raw_sql}")
                return raw_sql
            else:
                return self.fallback_generator.generate_sql(question)
                
        except Exception as e:
            logger.error(f"SQL generation with LLM failed: {e}")
            return self.fallback_generator.generate_sql(question)
    
    def _execute_query(self, sql: str) -> Optional[List[Dict]]:
        """Execute SQL query safely"""
        try:
            with self.db_connection.cursor() as cursor:
                logger.info(f"Executing: {sql}")
                cursor.execute(sql)
                result = cursor.fetchall()
                logger.info(f"Query returned {len(result)} rows")
                return result
                
        except pymysql.Error as e:
            logger.error(f"Database error: {e}")
            error_msg = f"Database Error: {str(e)}"
            if "Unknown column" in str(e):
                available_cols = ', '.join(self.schema_manager.get_safe_columns())
                error_msg += f"\nAvailable columns: {available_cols}"
            return None
        except Exception as e:
            logger.error(f"Query execution error: {e}")
            return None
    
    def cleanup(self):
        """Clean up resources"""
        try:
            if self.db_connection and self.db_connection.open:
                self.db_connection.close()
                logger.info("Database connection closed")
        except Exception as e:
            logger.error(f"Cleanup error: {e}")

def Teammain(query: str) -> str:
    """Main function to process team queries"""
    if not query or not query.strip():
        return "âŒ Please provide a valid query."
    
    logger.info(f"Processing query: {query}")
    assistant = TeamDetailsAssistant()
    
    try:
        result = assistant.process_question(query.strip())
        return result
    except Exception as e:
        logger.error(f"Main function error: {e}")
        return f"âŒ An unexpected error occurred: {str(e)}"
    finally:
        assistant.cleanup()

# Test the function
if __name__ == "__main__":
    # Test with sample queries
    test_queries = [
        "Show me employee with ID 12345",
        "tell me details about aryan",
        "details of abhishek", 
        "phone number of aryan",
        "details of 2798445",
        "List all employees in team ABC",
        "Count employees by team"
    ]
    
    print("ğŸš€ Starting Team Details Assistant Tests...")
    print("=" * 60)
    
    for i, query in enumerate(test_queries, 1):
        print(f"\nğŸ” Test {i}: {query}")
        print("-" * 40)
        try:
            result = Teammain(query)
            print(result)
        except Exception as e:
            print(f"âŒ Error in test {i}: {e}")
        print("-" * 40)
    
    print("\nâœ… All tests completed!")
