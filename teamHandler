import os
import re
import logging
import pymysql
import traceback
from typing import List, Dict, Any
from datetime import datetime
import json
import sqlparse
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

# --- TEAM DETAILS CONFIGURATION ---
TEAM_DB_CONFIG = {
    "name": "Team Details",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["UserMaster"],
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

# Sensitive fields that should never be included in queries or results
SENSITIVE_FIELDS = ["Pwd", "SecQ", "SecA"]

# Field mappings for better query understanding
FIELD_MAPPINGS = {
    "phone": "Contact",
    "mobile": "Contact",
    "contact": "Contact",
    "phone_number": "Contact",
    "employee_id": "Uid",
    "emp_id": "Uid",
    "id": "Uid",
    "name": "EmpName",
    "employee_name": "EmpName",
    "emp_name": "EmpName",
    "email": "TcsEmail",
    "tcs_email": "TcsEmail",
    "sbi_email": "SbiEmail",
    "ad_id": "AdId",
    "position": "Position",
    "level": "Level",
    "team": "Team",
    "project": "Project"
}

# Column metadata for better query generation
COLUMN_INFO = {
    "Uid": "int - Unique employee identifier (use = for exact match)",
    "EmpName": "text - Employee name (use LIKE for search)",
    "Contact": "text - Phone number (use LIKE for search)",
    "TcsEmail": "text - TCS email address (use LIKE for search)",
    "SbiEmail": "text - SBI email address (use LIKE for search)",
    "AdId": "text - Active Directory ID (use LIKE for search)",
    "Position": "text - Job position (use LIKE for search)",
    "Level": "text - Employee level (use LIKE for search)",
    "Team": "text - Team name (use LIKE for search)",
    "Project": "text - Project name (use LIKE for search)"
}

# Setup logging
logging.basicConfig(
    filename=os.path.expanduser("~/.team_details_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    """Check if text contains dangerous patterns"""
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def clean_and_fix_sql(raw_sql: str) -> str:
    """Clean and fix SQL with proper handling for different column types"""
    print(f"DEBUG - Raw SQL input: {repr(raw_sql)}")
    raw_sql = sqlparse.format(raw_sql, strip_comments=True).strip()

    # Extract SQL from code block if present
    match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
    if match:
        sql = match.group(1).strip()
        print(f"DEBUG - Extracted from code block: {sql}")
    else:
        # Remove any markdown formatting
        sql = re.sub(r"```", "", raw_sql)
        # Look for SELECT statement
        select_match = re.search(r"(SELECT.*?)(?:\n|$|;)", sql, re.IGNORECASE | re.DOTALL)
        if select_match:
            sql = select_match.group(1).strip()
            print(f"DEBUG - Extracted SELECT: {sql}")
        else:
            sql = raw_sql.strip()

    # If not a valid SELECT query, attempt to construct one from context
    if not sql.upper().strip().startswith('SELECT'):
        print(f"DEBUG - No valid SELECT found, trying to construct from: {raw_sql}")
        uid_match = re.search(r"uid[\s_]*(\d+)", raw_sql.lower())
        if uid_match:
            uid = uid_match.group(1)
            sql = f"SELECT * FROM UserMaster WHERE Uid = {uid}"
            print(f"DEBUG - Constructed UID query: {sql}")
        else:
            name_match = re.search(r"employee\s+named\s+(\w+)", raw_sql.lower())
            if name_match:
                name = name_match.group(1)
                sql = f"SELECT * FROM UserMaster WHERE EmpName LIKE '%{name}%'"
                print(f"DEBUG - Constructed name query: {sql}")
            else:
                print(f"DEBUG - Could not construct valid SQL from: {raw_sql}")
                return raw_sql  # Return as-is for validation to catch

    # Remove sensitive fields from query
    for field in SENSITIVE_FIELDS:
        sql = re.sub(rf'\b{field}\b\s*,?\s*', '', sql, flags=re.IGNORECASE)
        sql = re.sub(rf',\s*\b{field}\b', '', sql, flags=re.IGNORECASE)
        sql = re.sub(rf'\bWHERE\s+\b{field}\b[^A-Z]*?(?=\s+(AND|OR|ORDER|GROUP|LIMIT|$))', 'WHERE ', sql, flags=re.IGNORECASE)
        sql = re.sub(rf'\b(AND|OR)\s+\b{field}\b[^A-Z]*?(?=\s+(AND|OR|ORDER|GROUP|LIMIT|$))', '', sql, flags=re.IGNORECASE)

    # Clean up SQL syntax
    sql = re.sub(r',\s*,', ',', sql)
    sql = re.sub(r'SELECT\s*,', 'SELECT ', sql, flags=re.IGNORECASE)
    sql = re.sub(r',\s*FROM', ' FROM', sql, flags=re.IGNORECASE)
    sql = re.sub(r'WHERE\s+AND', 'WHERE', sql, flags=re.IGNORECASE)
    sql = re.sub(r'WHERE\s+OR', 'WHERE', sql, flags=re.IGNORECASE)
    sql = re.sub(r'WHERE\s*$', '', sql, flags=re.IGNORECASE)

    # Convert = to LIKE for text fields
    text_fields = ['EmpName', 'Contact', 'TcsEmail', 'SbiEmail', 'AdId', 'Position', 'Level', 'Team', 'Project']
    for field in text_fields:
        sql = re.sub(f"({field})\\s*=\\s*'([^']*)'", f"\\1 LIKE '%\\2%'", sql, flags=re.IGNORECASE)
        sql = re.sub(f"({field})\\s*=\\s*\"([^\"]*)\"", f"\\1 LIKE '%\\2%'", sql, flags=re.IGNORECASE)

    # Remove trailing semicolons
    sql = sql.strip().rstrip(";")
    print(f"DEBUG - Final cleaned SQL: {sql}")
    return sql

def format_query_results_natural(result: List[Dict], question: str) -> str:
    """Format database results in natural language"""
    if not result:
        return "I couldn't find any employee records matching your criteria."

    if len(result) == 1 and len(result[0]) == 1:
        value = list(result[0].values())[0]
        if "count" in question.lower():
            return f"There are {value} employee records matching your criteria."
        return f"The result is: {value}"

    if len(result) == 1:
        record = result[0]
        response = "I found 1 employee record:\n\n"
        for key, value in record.items():
            if key not in SENSITIVE_FIELDS:
                emojis = {'Uid': 'ðŸ†”', 'EmpName': 'ðŸ‘¤', 'Contact': 'ðŸ“ž', 'TcsEmail': 'ðŸ“§', 'SbiEmail': 'ðŸ“§', 'AdId': 'ðŸ”‘', 'Position': 'ðŸ’¼', 'Level': 'ðŸ“Š', 'Team': 'ðŸ‘¥', 'Project': 'ðŸ“‚'}
                response += f"{emojis.get(key, 'â€¢')} {key}: {value}\n"
        return response.strip()

    response = f"I found {len(result)} employee records matching your criteria:\n\n"
    if 'Team' in result[0]:
        team_counts = {}
        for record in result:
            team = record.get('Team', 'Unknown')
            team_counts[team] = team_counts.get(team, 0) + 1
        response += "ðŸ“Š Team Summary:\n"
        for team, count in team_counts.items():
            response += f"   â€¢ {team}: {count} employees\n"
        response += "\n"

    response += "ðŸ“‹ Detailed Results:\n" + format_query_results_tabular(result)
    if len(result) > 50:
        response += "\n\nâš ï¸ Note: More than 50 records were found. Consider refining your query for better results."
    return response

def format_query_results_tabular(result: List[Dict]) -> str:
    """Format database results in tabular format"""
    if not result:
        return "No records found."

    columns = [col for col in result[0].keys() if col not in SENSITIVE_FIELDS]
    result_tuples = [tuple(row.get(col, 'NULL') for col in columns) for row in result]
    output = []

    col_widths = [min(max(len(str(col)), max(len(str(row[i])) for row in result_tuples) if result_tuples else 0), 60) for i, col in enumerate(columns)]
    header = " | ".join(col.ljust(width) for col, width in zip(columns, col_widths))
    separator = "-+-".join("-" * width for width in col_widths)
    output.extend([header, separator])

    for row in result_tuples:
        formatted_row = " | ".join((str(val)[:57] + "..." if len(str(val)) > 60 else str(val)).ljust(width) if val is not None else "NULL".ljust(width) for val, width in zip(row, col_widths))
        output.append(formatted_row)

    output.append(f"\nTotal records: {len(result)}")
    return "\n".join(output)

def is_select_query(sql: str) -> bool:
    """Check if query is a safe SELECT query"""
    sql_clean = sql.strip().lower()
    print(f"DEBUG - Validating SQL: {repr(sql_clean)}")
    is_valid = sql_clean.startswith('select') and not any(kw in sql_clean for kw in ['insert', 'update', 'delete', 'drop', 'alter', 'create', 'truncate']) and not any(phrase in sql_clean for phrase in ['this is', 'sql query', 'the query', 'here is'])
    print(f"DEBUG - SQL validation result: {is_valid}")
    return is_valid

class TeamDetailsAssistant:
    def __init__(self):
        self.llm = None
        self.db_handler = None
        self.initialized = False
        self.chat_history = []

    def initialize(self):
        """Initialize the Team Details Assistant"""
        try:
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.1)
            db_cfg = TEAM_DB_CONFIG['db_config']
            uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"
            db_for_llm = SQLDatabase.from_uri(uri, include_tables=TEAM_DB_CONFIG.get("include_tables"), engine_args={"pool_pre_ping": True, "pool_recycle": 3600, "connect_args": {"connect_timeout": 15, "charset": "utf8mb4"}})
            self.db_handler = {
                'chain': create_sql_query_chain(self.llm, db_for_llm),
                'connection': pymysql.connect(**db_cfg, charset='utf8mb4', cursorclass=pymysql.cursors.DictCursor, autocommit=True),
                'config': TEAM_DB_CONFIG
            }
            self.initialized = True
            return True
        except Exception as e:
            logger.error(f"Initialization failed: {e}\n{traceback.format_exc()}")
            return False

    def query_team_details(self, question: str) -> str:
        """Query team details database with enhanced user query handling"""
        if not self.db_handler:
            return "âŒ Team Details database not available."

        try:
            # Direct SQL generation for specific patterns
            id_match = re.search(r"^(?:employee\s+with\s+ID\s+|id\s+|uid\s*)(\d+)$", question, re.IGNORECASE)
            if id_match:
                uid = id_match.group(1)
                sql = f"SELECT * FROM UserMaster WHERE Uid = {uid}"
                print(f"DEBUG - Pattern matched: employee ID {uid}")
            else:
                name_match = re.search(r"^(?:employee\s+named\s+|name\s+)(\w+)$", question, re.IGNORECASE)
                if name_match:
                    name = name_match.group(1)
                    sql = f"SELECT * FROM UserMaster WHERE EmpName LIKE '%{name}%'"
                    print(f"DEBUG - Pattern matched: employee name {name}")
                else:
                    # Preprocess question with field mappings
                    processed_question = question.lower()
                    for term, field in FIELD_MAPPINGS.items():
                        processed_question = re.sub(rf'\b{re.escape(term)}\b', field, processed_question, flags=re.IGNORECASE)
                    enhanced_question = f"{processed_question}\n\nIMPORTANT INSTRUCTIONS:\n- Never include sensitive fields: {', '.join(SENSITIVE_FIELDS)}\n- Use Contact for phone numbers\n- Use LIKE for name searches\n- Focus on fields like Uid, EmpName, Project, Team, Contact, TcsEmail, Position, Level"
                    raw_sql = self.db_handler['chain'].invoke({"question": enhanced_question})
                    print(f"DEBUG - Raw SQL from LLM: {repr(raw_sql)}")
                    sql = clean_and_fix_sql(raw_sql)

            if not is_select_query(sql):
                return f"âŒ Error: Invalid query generated. Raw output: {repr(raw_sql)}\nCleaned to: {sql}\nOnly SELECT queries allowed."

            for sensitive_field in SENSITIVE_FIELDS:
                if re.search(rf"\b{sensitive_field}\b", sql, re.IGNORECASE):
                    logger.warning(f"Blocked query with sensitive field: {sensitive_field}")
                    return "ðŸš« Cannot access sensitive information. Rephrase your query."

            with self.db_handler['connection'].cursor() as cursor:
                try:
                    print(f"DEBUG - Executing SQL: {sql}")
                    cursor.execute(sql)
                    result = cursor.fetchall()
                    print(f"DEBUG - Query result count: {len(result)}")
                    return format_query_results_natural(result, question)
                except pymysql.Error as db_error:
                    return f"âŒ Database Error: {str(db_error)}\nSQL Query: {sql}\nOriginal LLM output: {repr(raw_sql) if 'raw_sql' in locals() else 'N/A'}\nPlease check syntax and retry."
        except Exception as e:
            return f"âŒ Error: {str(e)}\nRaw LLM output: {repr(raw_sql) if 'raw_sql' in locals() else 'N/A'}\nRephrase your question."

    def process_question(self, question: str) -> str:
        """Process questions and return results"""
        if not self.initialized and not self.initialize():
            return "âŒ Initialization failed. Check database connection."
        if is_dangerous(question):
            return "âŒ Question blocked for security reasons."
        self.chat_history.append(f"User: {question}")
        response = self.query_team_details(question)
        self.chat_history.append(f"Assistant: {response}")
        return response

    def start_interactive_session(self, query: str) -> str:
        """Process single query and return result"""
        if not self.initialize():
            return "âŒ Failed to initialize. Check database connection."
        try:
            if query.lower() in ['exit', 'quit', 'q']:
                return "ðŸ‘‹ Session ended."
            print("ðŸ” Processing your query...")
            return self.process_question(query)
        except KeyboardInterrupt:
            return "ðŸ‘‹ Session interrupted."
        except Exception as e:
            logger.error(f"Session error: {e}\n{traceback.format_exc()}")
            return f"âŒ Session error: {str(e)}"
        finally:
            if self.db_handler and self.db_handler['connection'].open:
                self.db_handler['connection'].close()

def Teammain(query: str) -> str:
    """Main function to process team queries"""
    print("ðŸš€ Starting Team Details Assistant...")
    assistant = TeamDetailsAssistant()
    result = assistant.start_interactive_session(query)
    print("âœ… Query processing complete.")
    return result

if __name__ == "__main__":
    test_queries = ["12345", "John", "Show me employee with ID 12345", "List all employees named John", "Show me all employees in Project ABC", "Count employees by team"]
    for query in test_queries:
        print(f"\n{'='*60}\nTesting: {query}\n{'='*60}")
        print(Teammain(query))
