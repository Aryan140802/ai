import os
import re
import logging
import pymysql
import traceback
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime
import json
import sqlparse
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

# --- TEAM DETAILS CONFIGURATION ---
TEAM_DB_CONFIG = {
    "name": "Team Details",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["UserMaster"],
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

# Sensitive field patterns (case-insensitive)
SENSITIVE_PATTERNS = [
    r"pwd", r"password", r"pass", r"secq", r"seca", r"secret", 
    r"auth", r"token", r"key", r"hash", r"salt"
]

# Setup logging
logging.basicConfig(
    filename=os.path.expanduser("~/.team_details_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    """Check if text contains dangerous patterns"""
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def is_sensitive_field(field_name: str) -> bool:
    """Check if field name contains sensitive information"""
    return any(re.search(pattern, field_name.lower()) for pattern in SENSITIVE_PATTERNS)

class DatabaseSchemaManager:
    """Manages database schema discovery and caching"""
    
    def __init__(self, connection):
        self.connection = connection
        self.schema_cache = {}
        self.field_mappings = {}
        self.load_schema()
    
    def load_schema(self):
        """Load and cache database schema"""
        try:
            with self.connection.cursor() as cursor:
                # Get all columns for UserMaster table
                cursor.execute("""
                    SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE, COLUMN_DEFAULT, COLUMN_COMMENT
                    FROM INFORMATION_SCHEMA.COLUMNS 
                    WHERE TABLE_SCHEMA = %s AND TABLE_NAME = 'UserMaster'
                    ORDER BY ORDINAL_POSITION
                """, (TEAM_DB_CONFIG['db_config']['database'],))
                
                columns = cursor.fetchall()
                
                if not columns:
                    raise Exception("UserMaster table not found or no columns accessible")
                
                self.schema_cache['UserMaster'] = {}
                safe_columns = []
                
                for col in columns:
                    col_name = col['COLUMN_NAME']
                    col_type = col['DATA_TYPE']
                    
                    # Skip sensitive fields
                    if is_sensitive_field(col_name):
                        logger.info(f"Skipping sensitive field: {col_name}")
                        continue
                    
                    safe_columns.append(col_name)
                    self.schema_cache['UserMaster'][col_name] = {
                        'type': col_type,
                        'nullable': col['IS_NULLABLE'] == 'YES',
                        'default': col['COLUMN_DEFAULT'],
                        'comment': col['COLUMN_COMMENT'] or ''
                    }
                
                logger.info(f"Loaded schema with {len(safe_columns)} safe columns: {safe_columns}")
                
                # Create intelligent field mappings based on actual columns
                self._create_field_mappings(safe_columns)
                
        except Exception as e:
            logger.error(f"Schema loading failed: {e}")
            raise
    
    def _create_field_mappings(self, columns: List[str]):
        """Create intelligent field mappings based on actual column names"""
        self.field_mappings = {}
        
        # Common search terms to actual column mappings
        mapping_patterns = {
            # ID related
            r"(employee_?id|emp_?id|user_?id|id)\b": self._find_id_column(columns),
            # Name related  
            r"(name|employee_?name|emp_?name|full_?name)\b": self._find_name_column(columns),
            # Contact related
            r"(phone|mobile|contact|phone_?number|cell)\b": self._find_contact_column(columns),
            # Email related
            r"(email|mail|e_?mail)\b": self._find_email_column(columns),
            # Position related
            r"(position|role|job|designation|title)\b": self._find_position_column(columns),
            # Team related
            r"(team|group|department|dept)\b": self._find_team_column(columns),
            # Project related
            r"(project|proj)\b": self._find_project_column(columns),
            # Level related
            r"(level|grade|band)\b": self._find_level_column(columns),
        }
        
        for pattern, actual_column in mapping_patterns.items():
            if actual_column:
                self.field_mappings[pattern] = actual_column
    
    def _find_column_by_patterns(self, columns: List[str], patterns: List[str]) -> Optional[str]:
        """Find column by matching patterns"""
        for pattern in patterns:
            for col in columns:
                if re.search(pattern, col.lower()):
                    return col
        return None
    
    def _find_id_column(self, columns: List[str]) -> Optional[str]:
        patterns = [r"uid", r"user_?id", r"emp_?id", r"employee_?id", r"^id$"]
        return self._find_column_by_patterns(columns, patterns)
    
    def _find_name_column(self, columns: List[str]) -> Optional[str]:
        patterns = [r"name", r"emp_?name", r"employee_?name", r"full_?name", r"display_?name"]
        return self._find_column_by_patterns(columns, patterns)
    
    def _find_contact_column(self, columns: List[str]) -> Optional[str]:
        patterns = [r"contact", r"phone", r"mobile", r"cell", r"telephone"]
        return self._find_column_by_patterns(columns, patterns)
    
    def _find_email_column(self, columns: List[str]) -> Optional[str]:
        patterns = [r"email", r"mail", r"e_?mail"]
        return self._find_column_by_patterns(columns, patterns)
    
    def _find_position_column(self, columns: List[str]) -> Optional[str]:
        patterns = [r"position", r"role", r"designation", r"title", r"job"]
        return self._find_column_by_patterns(columns, patterns)
    
    def _find_team_column(self, columns: List[str]) -> Optional[str]:
        patterns = [r"team", r"group", r"department", r"dept"]
        return self._find_column_by_patterns(columns, patterns)
    
    def _find_project_column(self, columns: List[str]) -> Optional[str]:
        patterns = [r"project", r"proj"]
        return self._find_column_by_patterns(columns, patterns)
    
    def _find_level_column(self, columns: List[str]) -> Optional[str]:
        patterns = [r"level", r"grade", r"band"]
        return self._find_column_by_patterns(columns, patterns)
    
    def get_safe_columns(self) -> List[str]:
        """Get list of safe (non-sensitive) columns"""
        return list(self.schema_cache.get('UserMaster', {}).keys())
    
    def map_user_terms(self, question: str) -> str:
        """Map user terms to actual database columns"""
        mapped_question = question.lower()
        
        for pattern, actual_column in self.field_mappings.items():
            mapped_question = re.sub(pattern, actual_column, mapped_question, flags=re.IGNORECASE)
        
        return mapped_question
    
    def get_column_info_string(self) -> str:
        """Get formatted column information for LLM context"""
        if 'UserMaster' not in self.schema_cache:
            return "No schema information available"
        
        info_parts = []
        for col_name, col_info in self.schema_cache['UserMaster'].items():
            type_info = col_info['type']
            if type_info in ['varchar', 'text', 'char']:
                usage = "text - use LIKE '%value%' for partial matching"
            elif type_info in ['int', 'bigint', 'decimal']:
                usage = "numeric - use = for exact matching"
            elif type_info in ['datetime', 'date', 'timestamp']:
                usage = "date - use appropriate date functions"
            else:
                usage = f"{type_info} - handle appropriately"
            
            info_parts.append(f"{col_name}: {usage}")
        
        return "\n".join(info_parts)

class SQLQueryProcessor:
    """Processes and validates SQL queries"""
    
    def __init__(self, schema_manager: DatabaseSchemaManager):
        self.schema_manager = schema_manager
    
    def clean_and_validate_sql(self, raw_sql: str, question: str) -> Tuple[str, bool]:
        """Clean SQL and validate it's safe"""
        try:
            logger.info(f"Processing raw SQL: {raw_sql}")
            
            # Handle non-SQL responses
            if not self._contains_sql(raw_sql):
                # Try to construct SQL from question
                constructed_sql = self._construct_sql_from_question(question)
                if constructed_sql:
                    return self._finalize_sql(constructed_sql), True
                return "", False
            
            # Extract SQL from various formats
            sql = self._extract_sql(raw_sql)
            
            if not sql:
                return "", False
            
            # Validate and clean
            if not self._is_safe_select(sql):
                return "", False
            
            # Remove sensitive fields
            sql = self._remove_sensitive_fields(sql)
            
            # Fix column references
            sql = self._fix_column_references(sql)
            
            # Optimize for text searches
            sql = self._optimize_text_searches(sql)
            
            # Add limits and final cleanup
            sql = self._finalize_sql(sql)
            
            logger.info(f"Final processed SQL: {sql}")
            return sql, True
            
        except Exception as e:
            logger.error(f"SQL processing error: {e}")
            return "", False
    
    def _contains_sql(self, text: str) -> bool:
        """Check if text contains SQL"""
        sql_indicators = ['select', 'from', 'where', 'join']
        text_lower = text.lower()
        return any(indicator in text_lower for indicator in sql_indicators)
    
    def _extract_sql(self, raw_sql: str) -> str:
        """Extract SQL from various formats"""
        # Try code block first
        code_block_match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
        if code_block_match:
            return code_block_match.group(1).strip()
        
        # Try to find SELECT statement
        select_match = re.search(r"(SELECT.*?)(?:\n\n|$|;)", raw_sql, re.IGNORECASE | re.DOTALL)
        if select_match:
            return select_match.group(1).strip()
        
        # Clean and return
        sql = re.sub(r"```", "", raw_sql)
        sql = re.sub(r"^.*?(SELECT|INSERT|UPDATE|DELETE)", r"\1", sql, flags=re.IGNORECASE | re.DOTALL)
        return sql.strip()
    
    def _construct_sql_from_question(self, question: str) -> Optional[str]:
        """Construct basic SQL from question patterns"""
        safe_columns = self.schema_manager.get_safe_columns()
        if not safe_columns:
            return None
        
        question_lower = question.lower()
        
        # Look for ID-based queries
        id_match = re.search(r'\b(\d+)\b', question)
        id_column = self.schema_manager._find_id_column(safe_columns)
        
        if id_match and id_column:
            return f"SELECT * FROM UserMaster WHERE {id_column} = {id_match.group(1)}"
        
        # Look for name-based queries
        name_column = self.schema_manager._find_name_column(safe_columns)
        if name_column:
            # Extract potential name
            name_match = re.search(r'(?:details?|info|about|of)\s+(\w+)', question_lower)
            if name_match:
                name = name_match.group(1)
                return f"SELECT * FROM UserMaster WHERE {name_column} LIKE '%{name}%'"
        
        # Default: select all with limit
        return f"SELECT * FROM UserMaster LIMIT 10"
    
    def _is_safe_select(self, sql: str) -> bool:
        """Validate SQL is safe SELECT only"""
        sql_clean = sql.strip().lower()
        
        if not sql_clean.startswith('select'):
            return False
        
        dangerous_keywords = [
            'insert', 'update', 'delete', 'drop', 'alter', 'create', 
            'truncate', 'exec', 'execute', 'sp_', 'xp_'
        ]
        
        return not any(keyword in sql_clean for keyword in dangerous_keywords)
    
    def _remove_sensitive_fields(self, sql: str) -> str:
        """Remove references to sensitive fields"""
        safe_columns = self.schema_manager.get_safe_columns()
        
        # If SELECT *, replace with safe columns
        if re.search(r'SELECT\s+\*', sql, re.IGNORECASE):
            safe_cols_str = ', '.join(f"`{col}`" for col in safe_columns)
            sql = re.sub(r'SELECT\s+\*', f'SELECT {safe_cols_str}', sql, flags=re.IGNORECASE)
        
        return sql
    
    def _fix_column_references(self, sql: str) -> str:
        """Fix column references to match actual schema"""
        safe_columns = self.schema_manager.get_safe_columns()
        
        # Create a mapping of quoted and unquoted column references
        for actual_col in safe_columns:
            # Replace various quote styles
            patterns = [
                f'`{actual_col}`',
                f'"{actual_col}"',
                f"'{actual_col}'",
                f'\\b{actual_col}\\b'
            ]
            
            for pattern in patterns:
                sql = re.sub(pattern, f'`{actual_col}`', sql, flags=re.IGNORECASE)
        
        return sql
    
    def _optimize_text_searches(self, sql: str) -> str:
        """Optimize text field searches"""
        safe_columns = self.schema_manager.get_safe_columns()
        
        for col in safe_columns:
            col_info = self.schema_manager.schema_cache['UserMaster'].get(col, {})
            if col_info.get('type') in ['varchar', 'text', 'char']:
                # Convert = to LIKE for text fields
                pattern = f"(`{col}`|{col})\\s*=\\s*(['\"][^'\"]*['\"])"
                replacement = f"`{col}` LIKE '%' + \\2 + '%'"
                sql = re.sub(pattern, replacement, sql, flags=re.IGNORECASE)
                
                # Fix the LIKE pattern for MySQL
                sql = re.sub(r"LIKE '%' \+ (['\"][^'\"]*['\""]) \+ '%'", r"LIKE CONCAT('%', \1, '%')", sql)
                # Simpler approach for MySQL
                sql = re.sub(r"LIKE '%' \+ (['\"][^'\"]*['\""]) \+ '%'", r"LIKE '%\1%'", sql)
                sql = re.sub(r"LIKE '%'(['\"][^'\"]*['\"""])'%'", r"LIKE '%\1%'", sql)
        
        return sql
    
    def _finalize_sql(self, sql: str) -> str:
        """Final SQL cleanup and optimization"""
        # Remove trailing semicolons
        sql = sql.strip().rstrip(';')
        
        # Add reasonable limit if none exists
        if not re.search(r'\bLIMIT\b', sql, re.IGNORECASE):
            if not re.search(r'\bCOUNT\s*\(', sql, re.IGNORECASE):
                sql += " LIMIT 50"
        
        # Clean up extra whitespace
        sql = re.sub(r'\s+', ' ', sql).strip()
        
        return sql

class ResultFormatter:
    """Formats query results for display"""
    
    @staticmethod
    def format_natural(result: List[Dict], question: str) -> str:
        """Format results in natural language"""
        if not result:
            return ResultFormatter._no_results_message(question)
        
        # Handle single value results
        if len(result) == 1 and len(result[0]) == 1:
            value = list(result[0].values())[0]
            if "count" in question.lower():
                return f"There are {value} employee records matching your criteria."
            return f"The result is: {value}"
        
        # Handle single record
        if len(result) == 1:
            return ResultFormatter._format_single_record(result[0])
        
        # Handle multiple records
        return ResultFormatter._format_multiple_records(result, question)
    
    @staticmethod
    def _no_results_message(question: str) -> str:
        """Generate helpful no results message"""
        suggestions = [
            "Try using broader search terms",
            "Check spelling of names or terms",
            "Try searching by partial matches",
            "Verify the data exists in the database"
        ]
        
        response = "I couldn't find any employee records matching your criteria.\n\n"
        response += "💡 Suggestions:\n"
        response += "\n".join(f"• {suggestion}" for suggestion in suggestions)
        
        return response
    
    @staticmethod
    def _format_single_record(record: Dict) -> str:
        """Format single record nicely"""
        response = "I found 1 employee record:\n\n"
        
        # Define display order and icons
        field_display = {
            'id': ('🆔 Employee ID', 'Uid'),
            'name': ('👤 Name', ['EmpName', 'Name', 'EmployeeName']),
            'contact': ('📞 Contact', ['Contact', 'Phone', 'Mobile']),
            'email': ('📧 Email', ['TcsEmail', 'Email', 'SbiEmail']),
            'position': ('💼 Position', ['Position', 'Role', 'Designation']),
            'level': ('📊 Level', ['Level', 'Grade', 'Band']),
            'team': ('👥 Team', ['Team', 'Department', 'Group']),
            'project': ('📂 Project', ['Project', 'Proj'])
        }
        
        for display_key, (icon_label, possible_fields) in field_display.items():
            if isinstance(possible_fields, str):
                possible_fields = [possible_fields]
            
            for field in possible_fields:
                if field in record and record[field] is not None:
                    response += f"{icon_label}: {record[field]}\n"
                    break
        
        # Add any remaining fields not in the standard display
        displayed_fields = set()
        for _, (_, fields) in field_display.items():
            if isinstance(fields, str):
                displayed_fields.add(fields)
            else:
                displayed_fields.update(fields)
        
        for key, value in record.items():
            if key not in displayed_fields and value is not None:
                response += f"📋 {key}: {value}\n"
        
        return response.strip()
    
    @staticmethod
    def _format_multiple_records(result: List[Dict], question: str) -> str:
        """Format multiple records with summary"""
        response = f"I found {len(result)} employee records matching your criteria:\n\n"
        
        # Add summary if we have team information
        if result and 'Team' in result[0]:
            team_counts = {}
            for record in result:
                team = record.get('Team', 'Unknown')
                team_counts[team] = team_counts.get(team, 0) + 1
            
            if len(team_counts) > 1:
                response += "📊 Team Summary:\n"
                for team, count in sorted(team_counts.items()):
                    response += f"   • {team}: {count} employees\n"
                response += "\n"
        
        # Show detailed results
        response += "📋 Detailed Results:\n"
        response += ResultFormatter._format_tabular(result)
        
        return response
    
    @staticmethod
    def _format_tabular(result: List[Dict]) -> str:
        """Format results in table format"""
        if not result:
            return "No records found."
        
        columns = list(result[0].keys())
        
        # Calculate column widths
        col_widths = []
        for col in columns:
            max_width = max(
                len(str(col)),
                max(len(str(row.get(col, ''))) for row in result)
            )
            col_widths.append(min(max_width, 30))  # Cap at 30 chars
        
        # Build table
        output = []
        
        # Header
        header = " | ".join(col.ljust(width) for col, width in zip(columns, col_widths))
        separator = "-+-".join("-" * width for width in col_widths)
        output.append(header)
        output.append(separator)
        
        # Rows
        for row in result:
            formatted_row = " | ".join(
                str(row.get(col, ''))[:27] + "..." if len(str(row.get(col, ''))) > 30 
                else str(row.get(col, '')).ljust(width)
                for col, width in zip(columns, col_widths)
            )
            output.append(formatted_row)
        
        output.append(f"\nTotal records: {len(result)}")
        return "\n".join(output)

class TeamDetailsAssistant:
    def __init__(self):
        self.llm = None
        self.db_connection = None
        self.schema_manager = None
        self.sql_processor = None
        self.initialized = False
    
    def initialize(self) -> bool:
        """Initialize the assistant with robust error handling"""
        try:
            logger.info("Initializing Team Details Assistant...")
            
            # Initialize database connection first
            if not self._init_database():
                return False
            
            # Initialize LLM
            if not self._init_llm():
                return False
            
            # Initialize schema manager
            self.schema_manager = DatabaseSchemaManager(self.db_connection)
            self.sql_processor = SQLQueryProcessor(self.schema_manager)
            
            self.initialized = True
            logger.info("Team Details Assistant initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"Initialization failed: {e}\n{traceback.format_exc()}")
            return False
    
    def _init_database(self) -> bool:
        """Initialize database connection"""
        try:
            db_cfg = TEAM_DB_CONFIG['db_config']
            self.db_connection = pymysql.connect(
                host=db_cfg['host'],
                user=db_cfg['user'],
                password=db_cfg['password'],
                database=db_cfg['database'],
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor,
                autocommit=True,
                connect_timeout=10,
                read_timeout=30
            )
            
            # Test connection
            with self.db_connection.cursor() as cursor:
                cursor.execute("SELECT 1")
                cursor.fetchone()
            
            logger.info("Database connection established")
            return True
            
        except Exception as e:
            logger.error(f"Database connection failed: {e}")
            return False
    
    def _init_llm(self) -> bool:
        """Initialize LLM"""
        try:
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.1)
            
            # Test LLM
            test_response = self.llm.invoke("SELECT 1")
            logger.info("LLM initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"LLM initialization failed: {e}")
            return False
    
    def process_question(self, question: str) -> str:
        """Process user question and return results"""
        if not self.initialized and not self.initialize():
            return "❌ Team Details Assistant initialization failed. Please check database connection."
        
        if is_dangerous(question):
            return "❌ Question blocked for security reasons."
        
        try:
            # Map user terms to database columns
            mapped_question = self.schema_manager.map_user_terms(question)
            
            # Create enhanced context for LLM
            context = self._create_llm_context(mapped_question)
            
            # Generate SQL using LLM
            raw_sql = self._generate_sql(context)
            
            # Process and validate SQL
            final_sql, is_valid = self.sql_processor.clean_and_validate_sql(raw_sql, question)
            
            if not is_valid:
                return f"❌ Could not generate valid SQL query. Please rephrase your question.\nOriginal LLM output: {raw_sql}"
            
            # Execute query
            result = self._execute_query(final_sql)
            
            if result is None:
                return "❌ Query execution failed. Please try again."
            
            # Format and return results
            return ResultFormatter.format_natural(result, question)
            
        except Exception as e:
            logger.error(f"Question processing error: {e}\n{traceback.format_exc()}")
            return f"❌ Error processing your question: {str(e)}"
    
    def _create_llm_context(self, question: str) -> str:
        """Create comprehensive context for LLM"""
        schema_info = self.schema_manager.get_column_info_string()
        safe_columns = self.schema_manager.get_safe_columns()
        
        context = f"""
Question: {question}

Database: UserMaster table with the following columns:
{schema_info}

IMPORTANT RULES:
1. ONLY use SELECT statements
2. ONLY reference these available columns: {', '.join(safe_columns)}
3. Use LIKE '%value%' for text searches, not exact equals
4. For numeric IDs, use exact equals (=)
5. Always include proper table name: UserMaster
6. Do not include sensitive fields in any query
7. Limit results appropriately (use LIMIT clause)

Generate a SQL query to answer the question.
"""
        return context
    
    def _generate_sql(self, context: str) -> str:
        """Generate SQL using LLM"""
        try:
            # Create a simple query chain
            db_cfg = TEAM_DB_CONFIG['db_config']
            uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"
            
            db_for_llm = SQLDatabase.from_uri(
                uri,
                include_tables=TEAM_DB_CONFIG.get("include_tables", ["UserMaster"])
            )
            
            chain = create_sql_query_chain(self.llm, db_for_llm)
            raw_sql = chain.invoke({"question": context})
            
            logger.info(f"Generated SQL: {raw_sql}")
            return raw_sql
            
        except Exception as e:
            logger.error(f"SQL generation failed: {e}")
            return ""
    
    def _execute_query(self, sql: str) -> Optional[List[Dict]]:
        """Execute SQL query safely"""
        try:
            with self.db_connection.cursor() as cursor:
                logger.info(f"Executing: {sql}")
                cursor.execute(sql)
                result = cursor.fetchall()
                logger.info(f"Query returned {len(result)} rows")
                return result
                
        except pymysql.Error as e:
            logger.error(f"Database error: {e}")
            return None
        except Exception as e:
            logger.error(f"Query execution error: {e}")
            return None
    
    def cleanup(self):
        """Clean up resources"""
        try:
            if self.db_connection and self.db_connection.open:
                self.db_connection.close()
                logger.info("Database connection closed")
        except:
            pass

def Teammain(query: str) -> str:
    """Main function to process team queries"""
    logger.info(f"Processing query: {query}")
    assistant = TeamDetailsAssistant()
    
    try:
        result = assistant.process_question(query)
        return result
    finally:
        assistant.cleanup()

# Test the function
if __name__ == "__main__":
    # Test with sample queries
    test_queries = [
        "Show me employee with ID 12345",
        "tell me details about aryan",
        "details of abhishek", 
        "phone number of aryan",
        "details of 2798445",
        "List all employees in team ABC",
        "Count employees by team"
    ]
    
    for query in test_queries:
        print(f"\n{'='*60}")
        print(f"Testing: {query}")
        print('='*60)
        try:
            result = Teammain(query)
            print(result)
        except Exception as e:
            print(f"Error: {e}")
