import os
import re
import logging
import pymysql
import traceback
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, date
import json

# --- TEAM DETAILS CONFIGURATION ---
TEAM_DB_CONFIG = {
    "name": "Team Details",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["UserMaster"],
}

# Sensitive fields that should never be included in queries or results
SENSITIVE_FIELDS = ["Pwd", "SecQ", "SecA"]

# Setup logging
logging.basicConfig(
    filename=os.path.expanduser("~/.team_details_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def is_employee_id(query: str) -> Optional[int]:
    """Check if query is an employee ID and extract it"""
    # Remove common prefixes and clean the query
    cleaned = re.sub(r'^(show|find|get|employee|emp|user|id|uid)\s*', '', query.lower()).strip()
    cleaned = re.sub(r'[^\d]', '', cleaned)  # Keep only digits
    
    if cleaned and cleaned.isdigit():
        return int(cleaned)
    
    # Check for patterns like "employee 123", "emp id 456", etc.
    patterns = [
        r'(?:employee|emp|user|id|uid)\s*[:#-]?\s*(\d+)',
        r'(\d+)\s*(?:employee|emp|user)?',
        r'^(\d+)$'
    ]
    
    for pattern in patterns:
        match = re.search(pattern, query.lower())
        if match:
            return int(match.group(1))
    
    return None

def is_employee_name(query: str) -> Optional[str]:
    """Check if query is an employee name and extract it"""
    # Remove common prefixes
    cleaned = re.sub(r'^(show|find|get|employee|emp|user|name)\s*', '', query, flags=re.IGNORECASE).strip()
    cleaned = re.sub(r'^(named|called|with name)\s*', '', cleaned, flags=re.IGNORECASE).strip()
    
    # Check if it looks like a name (contains letters, may have spaces)
    if re.match(r'^[a-zA-Z\s\.]+$', cleaned) and len(cleaned.strip()) >= 2:
        return cleaned.strip()
    
    return None

def format_single_employee(record: Dict) -> str:
    """Format single employee record with emojis and clean layout"""
    if not record:
        return "No employee found."
    
    response = "👤 **Employee Details**\n\n"
    
    # Priority fields with icons
    priority_fields = [
        ('Uid', '🆔', 'Employee ID'),
        ('EmpName', '👤', 'Name'),
        ('Contact', '📞', 'Contact'),
        ('TcsEmail', '📧', 'TCS Email'),
        ('SbiEmail', '📧', 'SBI Email'),
        ('AdId', '🔑', 'AD ID'),
        ('Position', '💼', 'Position'),
        ('Level', '📊', 'Level'),
        ('Team', '👥', 'Team'),
        ('Project', '📂', 'Project'),
        ('TcsDoj', '📅', 'TCS DOJ'),
        ('SbiDoj', '📅', 'SBI DOJ'),
        ('BACompany', '🏢', 'Company')
    ]
    
    for field, icon, label in priority_fields:
        if field in record and record[field] is not None and str(record[field]).strip():
            response += f"{icon} **{label}**: {record[field]}\n"
    
    return response

def format_multiple_employees(result: List[Dict]) -> str:
    """Format multiple employee records"""
    count = len(result)
    response = f"👥 **Found {count} employees**\n\n"
    
    # Show up to 10 employees in detail
    if count <= 10:
        for i, record in enumerate(result, 1):
            name = record.get('EmpName', 'Unknown')
            uid = record.get('Uid', 'N/A')
            team = record.get('Team', 'N/A')
            contact = record.get('Contact', 'N/A')
            
            response += f"**{i}. {name}**\n"
            response += f"   🆔 ID: {uid} | 👥 Team: {team} | 📞 Contact: {contact}\n\n"
    else:
        # Show first 5 for large results
        response += "**First 5 results:**\n\n"
        for i, record in enumerate(result[:5], 1):
            name = record.get('EmpName', 'Unknown')
            uid = record.get('Uid', 'N/A')
            team = record.get('Team', 'N/A')
            
            response += f"{i}. **{name}** (ID: {uid}) - {team}\n"
        
        response += f"\n... and {count - 5} more employees found."
    
    return response

class FastTeamDetailsAssistant:
    def __init__(self):
        self.db_connection = None
        self.initialized = False

    def initialize(self) -> bool:
        """Quick initialization - just database connection"""
        try:
            db_cfg = TEAM_DB_CONFIG['db_config']
            
            self.db_connection = pymysql.connect(
                host=db_cfg['host'],
                user=db_cfg['user'],
                password=db_cfg['password'],
                database=db_cfg['database'],
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor,
                autocommit=True,
                connect_timeout=10
            )
            
            self.initialized = True
            return True
            
        except Exception as e:
            logger.error(f"Database connection failed: {e}")
            return False

    def query_by_employee_id(self, emp_id: int) -> str:
        """Fast query by employee ID"""
        try:
            sql = f"SELECT * FROM UserMaster WHERE Uid = {emp_id}"
            
            with self.db_connection.cursor() as cursor:
                cursor.execute(sql)
                result = cursor.fetchone()
                
                if result:
                    # Remove sensitive fields
                    for field in SENSITIVE_FIELDS:
                        result.pop(field, None)
                    return format_single_employee(result)
                else:
                    return f"❌ No employee found with ID: {emp_id}"
                    
        except Exception as e:
            logger.error(f"Error querying employee ID {emp_id}: {e}")
            return f"❌ Error retrieving employee {emp_id}: {str(e)}"

    def query_by_employee_name(self, name: str) -> str:
        """Fast query by employee name"""
        try:
            # Try exact match first
            sql = f"SELECT * FROM UserMaster WHERE EmpName LIKE '%{name}%' LIMIT 20"
            
            with self.db_connection.cursor() as cursor:
                cursor.execute(sql)
                results = cursor.fetchall()
                
                if results:
                    # Remove sensitive fields from all results
                    for result in results:
                        for field in SENSITIVE_FIELDS:
                            result.pop(field, None)
                    
                    if len(results) == 1:
                        return format_single_employee(results[0])
                    else:
                        return format_multiple_employees(results)
                else:
                    return f"❌ No employee found with name containing: '{name}'"
                    
        except Exception as e:
            logger.error(f"Error querying employee name '{name}': {e}")
            return f"❌ Error searching for employee '{name}': {str(e)}"

    def handle_complex_query(self, query: str) -> str:
        """Handle more complex queries with simple pattern matching"""
        query_lower = query.lower()
        
        try:
            # Team queries
            if 'team' in query_lower:
                team_match = re.search(r'team\s+([a-zA-Z0-9_\-\s]+)', query, re.IGNORECASE)
                if team_match:
                    team = team_match.group(1).strip()
                    sql = f"SELECT * FROM UserMaster WHERE Team LIKE '%{team}%' LIMIT 50"
                    return self.execute_and_format(sql, f"team '{team}'")
            
            # Project queries
            if 'project' in query_lower:
                project_match = re.search(r'project\s+([a-zA-Z0-9_\-\s]+)', query, re.IGNORECASE)
                if project_match:
                    project = project_match.group(1).strip()
                    sql = f"SELECT * FROM UserMaster WHERE Project LIKE '%{project}%' LIMIT 50"
                    return self.execute_and_format(sql, f"project '{project}'")
            
            # Position queries
            if any(pos in query_lower for pos in ['manager', 'developer', 'analyst', 'lead', 'position']):
                pos_patterns = ['manager', 'developer', 'analyst', 'lead', 'engineer', 'architect']
                for pos in pos_patterns:
                    if pos in query_lower:
                        sql = f"SELECT * FROM UserMaster WHERE Position LIKE '%{pos}%' LIMIT 50"
                        return self.execute_and_format(sql, f"position containing '{pos}'")
            
            # Count queries
            if 'count' in query_lower:
                if 'team' in query_lower:
                    sql = "SELECT Team, COUNT(*) as Count FROM UserMaster GROUP BY Team ORDER BY Count DESC"
                elif 'project' in query_lower:
                    sql = "SELECT Project, COUNT(*) as Count FROM UserMaster GROUP BY Project ORDER BY Count DESC"
                else:
                    sql = "SELECT COUNT(*) as Total FROM UserMaster"
                return self.execute_and_format(sql, "count query")
            
            # Contact queries
            phone_match = re.search(r'(\d{10,})', query)
            if phone_match:
                phone = phone_match.group(1)
                sql = f"SELECT * FROM UserMaster WHERE Contact LIKE '%{phone}%' LIMIT 10"
                return self.execute_and_format(sql, f"phone number '{phone}'")
            
            # Email queries
            email_match = re.search(r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', query)
            if email_match:
                email = email_match.group(1)
                sql = f"SELECT * FROM UserMaster WHERE TcsEmail LIKE '%{email}%' OR SbiEmail LIKE '%{email}%' LIMIT 10"
                return self.execute_and_format(sql, f"email '{email}'")
            
            # Default fallback
            return "❓ I couldn't understand your query. Please try:\n• Employee ID (e.g., '12345')\n• Employee name (e.g., 'John Smith')\n• 'team ABC' or 'project XYZ'\n• 'count employees' or 'count teams'"
            
        except Exception as e:
            logger.error(f"Error in complex query '{query}': {e}")
            return f"❌ Error processing query: {str(e)}"

    def execute_and_format(self, sql: str, description: str) -> str:
        """Execute SQL and format results"""
        try:
            with self.db_connection.cursor() as cursor:
                cursor.execute(sql)
                results = cursor.fetchall()
                
                if not results:
                    return f"❌ No results found for {description}"
                
                # Remove sensitive fields
                for result in results:
                    for field in SENSITIVE_FIELDS:
                        result.pop(field, None)
                
                # Handle count queries
                if len(results) == 1 and 'Count' in results[0]:
                    count_val = list(results[0].values())
                    if len(count_val) == 1:
                        return f"📊 Total: {count_val[0]} records"
                
                # Handle group by results
                if len(results) > 1 and 'Count' in results[0]:
                    response = f"📊 **Results for {description}:**\n\n"
                    for result in results:
                        keys = list(result.keys())
                        group_key = [k for k in keys if k != 'Count'][0]
                        group_val = result[group_key] or 'Unknown'
                        count_val = result['Count']
                        response += f"• **{group_val}**: {count_val}\n"
                    return response
                
                # Handle regular results
                if len(results) == 1:
                    return format_single_employee(results[0])
                else:
                    return format_multiple_employees(results)
                    
        except Exception as e:
            logger.error(f"Error executing SQL '{sql}': {e}")
            return f"❌ Database error: {str(e)}"

    def process_query(self, query: str) -> str:
        """Main query processing - optimized for speed"""
        if not query or not query.strip():
            return "❌ Please provide a query (employee ID, name, team, etc.)"
        
        query = query.strip()
        
        # Initialize if needed
        if not self.initialized:
            if not self.initialize():
                return "❌ Database connection failed"
        
        try:
            # Fast path 1: Check if it's an employee ID
            emp_id = is_employee_id(query)
            if emp_id:
                print(f"DEBUG - Detected employee ID: {emp_id}")
                return self.query_by_employee_id(emp_id)
            
            # Fast path 2: Check if it's an employee name
            emp_name = is_employee_name(query)
            if emp_name:
                print(f"DEBUG - Detected employee name: {emp_name}")
                return self.query_by_employee_name(emp_name)
            
            # Fallback: Handle complex queries
            print(f"DEBUG - Processing complex query: {query}")
            return self.handle_complex_query(query)
            
        except Exception as e:
            logger.error(f"Error processing query '{query}': {e}")
            return f"❌ Error: {str(e)}"

    def cleanup(self):
        """Clean up database connection"""
        try:
            if self.db_connection and self.db_connection.open:
                self.db_connection.close()
        except:
            pass

    def __del__(self):
        self.cleanup()

def Teammain(query: str) -> str:
    """Fast main function for team queries"""
    if not query or not query.strip():
        return "❌ Please provide a query"
    
    assistant = FastTeamDetailsAssistant()
    
    try:
        result = assistant.process_query(query.strip())
        return result
    except Exception as e:
        logger.error(f"Critical error: {e}")
        return f"❌ Critical error: {str(e)}"
    finally:
        assistant.cleanup()

# Quick test function
def test_fast_queries():
    """Test common query patterns"""
    test_queries = [
        # Employee ID tests
        "12345",
        "employee 67890", 
        "show emp 111",
        "find user 222",
        
        # Name tests
        "John Smith",
        "employee Sarah",
        "find Kumar",
        "show Mary Johnson",
        
        # Team tests
        "team Development",
        "show team ABC",
        "list team XYZ",
        
        # Project tests
        "project Alpha",
        "show project Beta",
        
        # Count tests
        "count employees",
        "count teams",
        "count projects",
        
        # Contact tests
        "9876543210",
        "phone 1234567890",
        "john@tcs.com",
        
        # Complex tests
        "managers",
        "developers",
        "lead positions"
    ]
    
    print("🚀 Testing Fast Team Details Assistant...\n")
    
    for i, query in enumerate(test_queries, 1):
        print(f"\n--- Test {i}: '{query}' ---")
        start_time = datetime.now()
        
        try:
            result = Teammain(query)
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()
            
            print(f"⏱️  Response time: {duration:.2f}s")
            print(f"📝 Result: {result[:200]}{'...' if len(result) > 200 else ''}")
        except Exception as e:
            print(f"❌ Error: {e}")

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1:
        # Command line query
        query = " ".join(sys.argv[1:])
        print(f"Query: {query}")
        result = Teammain(query)
        print(f"Result: {result}")
    else:
        # Run performance tests
        test_fast_queries()
