import os
import re
import logging
import pymysql
import traceback
from typing import List, Dict, Any
from datetime import datetime
import json
import sqlparse
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

# --- TEAM DETAILS CONFIGURATION ---
TEAM_DB_CONFIG = {
    "name": "Team Details",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["UserMaster"],
}

# Blocked patterns for security
BLOCKED_PATTERNS = [
    r"\brm\b", r"\bkill\b", r"\breboot\b", r"\bshutdown\b", r"\buserdel\b",
    r"\bpasswd\b", r"\bmkfs\b", r"\bwget\b", r"\bcurl\b", r":\s*(){:|:&};:",
    r"\bsudo\b", r"\bsu\b", r"\bchmod\b", r"\bchown\b", r"\bdd\b",
    r"\bmount\s+/", r"\bumount\b", r"\bfdisk\b", r"\bparted\b", r"\bmkfs\b",
    r"\biptables\b", r"\bufw\b", r"\bfirewall\b", r"\bselinux\b"
]

# Sensitive fields that should never be included in queries or results
SENSITIVE_FIELDS = ["Pwd", "SecQ", "SecA"]

# Field mappings for better query understanding
FIELD_MAPPINGS = {
    "phone": "Contact",
    "mobile": "Contact",
    "contact": "Contact",
    "phone_number": "Contact",
    "employee_id": "Uid",
    "emp_id": "Uid",
    "id": "Uid",
    "name": "EmpName",
    "employee_name": "EmpName",
    "emp_name": "EmpName",
    "email": "TcsEmail",
    "tcs_email": "TcsEmail",
    "sbi_email": "SbiEmail",
    "ad_id": "AdId",
    "position": "Position",
    "level": "Level",
    "team": "Team",
    "project": "Project"
}

# Column metadata for better query generation
COLUMN_INFO = {
    "Uid": "int - Unique employee identifier (use = for exact match)",
    "EmpName": "text - Employee name (use LIKE for search)",
    "Contact": "text - Phone number (use LIKE for search)",
    "TcsEmail": "text - TCS email address (use LIKE for search)",
    "SbiEmail": "text - SBI email address (use LIKE for search)",
    "AdId": "text - Active Directory ID (use LIKE for search)",
    "Position": "text - Job position (use LIKE for search)",
    "Level": "text - Employee level (use LIKE for search)",
    "Team": "text - Team name (use LIKE for search)",
    "Project": "text - Project name (use LIKE for search)"
}

# Setup logging
logging.basicConfig(
    filename=os.path.expanduser("~/.team_details_ai.log"),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def is_dangerous(text: str) -> bool:
    """Check if text contains dangerous patterns"""
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def clean_and_fix_sql(raw_sql: str, question: str) -> str:
    """Clean and fix SQL with proper handling for different column types"""
    logger.debug(f"Raw SQL input: {repr(raw_sql)}")
    
    # Handle case where raw_sql is None or empty
    if not raw_sql:
        logger.warning("Received empty SQL from LLM")
        return ""
    
    # Extract SQL from code block if present
    match = re.search(r"```sql\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
    if match:
        sql = match.group(1).strip()
        logger.debug(f"Extracted from code block: {sql}")
    else:
        sql = raw_sql.strip()
    
    # Remove any markdown formatting
    sql = re.sub(r"```", "", sql)
    
    # Handle case where LLM returns descriptive text with an ID
    if not sql.upper().startswith('SELECT'):
        # Try to extract ID from question or raw_sql
        id_match = re.search(r"\b(\d{4,})\b", question) or re.search(r"\b(\d{4,})\b", raw_sql)
        if id_match:
            uid = id_match.group(1)
            sql = f"SELECT * FROM UserMaster WHERE Uid = {uid}"
            logger.info(f"Constructed UID query from text: {sql}")
            return sql
        
        # Try to extract name from question
        name_match = re.search(r"\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b", question)
        if name_match:
            name = name_match.group(1)
            sql = f"SELECT * FROM UserMaster WHERE EmpName LIKE '%{name}%'"
            logger.info(f"Constructed name query from text: {sql}")
            return sql
    
    # Remove comments and format SQL
    try:
        sql = sqlparse.format(sql, strip_comments=True).strip()
    except Exception as e:
        logger.error(f"Error formatting SQL: {e}")
    
    # Remove sensitive fields from query
    for field in SENSITIVE_FIELDS:
        # Remove field from SELECT list
        sql = re.sub(rf'\b{field}\b\s*,?\s*', '', sql, flags=re.IGNORECASE)
        sql = re.sub(rf',\s*\b{field}\b', '', sql, flags=re.IGNORECASE)
        
        # Remove WHERE conditions involving sensitive fields
        sql = re.sub(rf'\bWHERE\s+\b{field}\b[^A-Z]*?(?=\s+(AND|OR|ORDER|GROUP|LIMIT|$))', 'WHERE ', sql, flags=re.IGNORECASE)
        sql = re.sub(rf'\b(AND|OR)\s+\b{field}\b[^A-Z]*?(?=\s+(AND|OR|ORDER|GROUP|LIMIT|$))', '', sql, flags=re.IGNORECASE)
    
    # Clean up SQL syntax
    sql = re.sub(r',\s*,', ',', sql)
    sql = re.sub(r'SELECT\s*,', 'SELECT *', sql, flags=re.IGNORECASE)
    sql = re.sub(r',\s*FROM', ' FROM', sql, flags=re.IGNORECASE)
    sql = re.sub(r'WHERE\s+(AND|OR)', 'WHERE', sql, flags=re.IGNORECASE)
    sql = re.sub(r'WHERE\s*$', '', sql, flags=re.IGNORECASE)
    
    # Convert exact matches to LIKE for text fields
    text_fields = ['EmpName', 'Contact', 'TcsEmail', 'SbiEmail', 'AdId', 'Position', 'Level', 'Team', 'Project']
    for field in text_fields:
        sql = re.sub(f"({field})\\s*=\\s*'([^']*)'", f"\\1 LIKE '%\\2%'", sql, flags=re.IGNORECASE)
        sql = re.sub(f"({field})\\s*=\\s*\"([^\"]*)\"", f"\\1 LIKE '%\\2%'", sql, flags=re.IGNORECASE)
    
    # Remove trailing semicolons
    sql = sql.strip().rstrip(";")
    
    logger.debug(f"Final cleaned SQL: {sql}")
    return sql

def format_query_results_natural(result: List[Dict], question: str) -> str:
    """Format database results in natural language"""
    if not result:
        return "I couldn't find any employee records matching your criteria."
    
    # Handle single value results (like COUNT)
    if len(result) == 1 and len(result[0]) == 1:
        value = list(result[0].values())[0]
        if "count" in question.lower():
            return f"There are {value} employee records matching your criteria."
        return f"The result is: {value}"
    
    # Handle single record
    if len(result) == 1:
        record = result[0]
        response = "I found the following employee details:\n\n"
        
        # Format key information naturally
        if 'Uid' in record:
            response += f"üÜî Employee ID: {record['Uid']}\n"
        if 'EmpName' in record:
            response += f"üë§ Name: {record['EmpName']}\n"
        if 'Contact' in record:
            response += f"üìû Contact: {record['Contact']}\n"
        if 'TcsEmail' in record:
            response += f"üìß TCS Email: {record['TcsEmail']}\n"
        if 'SbiEmail' in record:
            response += f"üìß SBI Email: {record['SbiEmail']}\n"
        if 'AdId' in record:
            response += f"üîë AD ID: {record['AdId']}\n"
        if 'Position' in record:
            response += f"üíº Position: {record['Position']}\n"
        if 'Level' in record:
            response += f"üìä Level: {record['Level']}\n"
        if 'Team' in record:
            response += f"üë• Team: {record['Team']}\n"
        if 'Project' in record:
            response += f"üìÇ Project: {record['Project']}\n"
        
        return response.strip()
    
    # Handle multiple records
    response = f"I found {len(result)} employee records:\n\n"
    
    # Add summary information
    if 'Team' in result[0]:
        team_counts = {}
        for record in result:
            team = record.get('Team', 'Unknown')
            team_counts[team] = team_counts.get(team, 0) + 1
        
        response += "üìä Team Distribution:\n"
        for team, count in team_counts.items():
            response += f"   ‚Ä¢ {team}: {count} employees\n"
        response += "\n"
    
    # Show tabular format for multiple records
    response += "üìã Employee List:\n"
    response += format_query_results_tabular(result)
    
    return response

def format_query_results_tabular(result: List[Dict]) -> str:
    """Format database results in tabular format"""
    if not result:
        return "No records found."
    
    columns = list(result[0].keys())
    result_tuples = [tuple(row.values()) for row in result]
    
    # Calculate column widths with reasonable limits
    col_widths = []
    for i, col in enumerate(columns):
        max_content_width = max(len(str(row[i])) for row in result_tuples) if result_tuples else 0
        col_width = min(max(len(str(col)), max_content_width), 40)  # Max 40 chars per column
        col_widths.append(col_width)
    
    # Build header
    header = " | ".join(col.ljust(width) for col, width in zip(columns, col_widths))
    separator = "-+-".join("-" * width for width in col_widths)
    
    # Build rows
    rows = []
    for row in result_tuples:
        formatted_row = " | ".join(
            (str(val)[:37] + "..." if len(str(val)) > 40 else str(val)).ljust(width)
            for val, width in zip(row, col_widths)
        )
        rows.append(formatted_row)
    
    return "\n".join([header, separator] + rows + [f"\nTotal records: {len(result)}"])

def is_select_query(sql: str) -> bool:
    """Check if query is a safe SELECT query"""
    if not sql:
        return False
    
    sql_clean = sql.strip().lower()
    
    # Check if it starts with SELECT
    starts_with_select = sql_clean.startswith('select')
    
    # Check for dangerous operations
    has_dangerous_ops = any(
        kw in sql_clean for kw in [
            'insert', 'update', 'delete', 'drop', 
            'alter', 'create', 'truncate', 'grant',
            'revoke', 'exec', 'execute', 'shutdown'
        ]
    )
    
    # Check if it's just descriptive text
    is_descriptive = any(
        phrase in sql_clean for phrase in [
            'this is', 'sql query', 'the query', 
            'here is', 'query is', 'would be'
        ]
    )
    
    return starts_with_select and not has_dangerous_ops and not is_descriptive

class TeamDetailsAssistant:
    def __init__(self):
        self.llm = None
        self.db_handler = None
        self.initialized = False
        self.chat_history = []

    def initialize(self):
        """Initialize the Team Details Assistant"""
        try:
            # Initialize LLM
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.1)
            
            # Set up database connection
            db_cfg = TEAM_DB_CONFIG['db_config']
            uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"
            
            # Connect to database
            db_for_llm = SQLDatabase.from_uri(
                uri,
                include_tables=TEAM_DB_CONFIG.get("include_tables"),
                engine_args={
                    "pool_pre_ping": True,
                    "pool_recycle": 3600,
                    "connect_args": {
                        "connect_timeout": 15,
                        "charset": "utf8mb4"
                    }
                }
            )
            
            # Create query chain with custom prompt
            chain = create_sql_query_chain(self.llm, db_for_llm)
            
            # Create direct connection for executing queries
            db_conn = pymysql.connect(
                host=db_cfg['host'],
                user=db_cfg['user'],
                password=db_cfg['password'],
                database=db_cfg['database'],
                charset='utf8mb4',
                cursorclass=pymysql.cursors.DictCursor,
                autocommit=True
            )
            
            self.db_handler = {
                'chain': chain,
                'connection': db_conn,
                'config': TEAM_DB_CONFIG
            }
            
            self.initialized = True
            logger.info("TeamDetailsAssistant initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"Initialization failed: {e}\n{traceback.format_exc()}")
            return False

    def query_team_details(self, question: str) -> str:
        """Query team details database and return results"""
        if not self.db_handler:
            return "‚ùå Team Details database not available."
        
        try:
            # Preprocess the question to map common terms to database fields
            processed_question = question.lower()
            for term, field in FIELD_MAPPINGS.items():
                pattern = rf'\b{re.escape(term)}\b'
                processed_question = re.sub(pattern, field, processed_question, flags=re.IGNORECASE)
            
            # Enhanced prompt with clear instructions
            enhanced_question = f"""
{processed_question}

Database Schema:
- Table: UserMaster
- Columns: {', '.join(f"{k} ({v})" for k, v in COLUMN_INFO.items())}

Instructions:
1. Only query non-sensitive fields: Uid, EmpName, Contact, TcsEmail, SbiEmail, AdId, Position, Level, Team, Project
2. For names, emails, or text fields, use LIKE with wildcards for partial matching
3. For IDs, use exact matching with =
4. Never include Pwd, SecQ, or SecA fields
5. Return complete results (no LIMIT unless specified in the question)
6. Focus on answering the user's question directly
"""
            
            logger.info(f"Processing question: {question}")
            logger.debug(f"Enhanced question: {enhanced_question}")
            
            # Generate the SQL query
            raw_sql = self.db_handler['chain'].invoke({"question": enhanced_question})
            logger.info(f"Generated SQL: {raw_sql}")
            
            # Clean and fix the SQL
            sql = clean_and_fix_sql(raw_sql, question)
            logger.info(f"Cleaned SQL: {sql}")
            
            # Validate query safety
            if not is_select_query(sql):
                logger.warning(f"Invalid query generated: {sql}")
                return "‚ùå Could not generate a valid query. Please try rephrasing your question."
            
            # Additional security check
            for sensitive_field in SENSITIVE_FIELDS:
                if sensitive_field.lower() in sql.lower():
                    logger.warning(f"Blocked query containing sensitive field: {sensitive_field}")
                    return "üö´ Cannot access sensitive information. Please rephrase your query."
            
            # Execute the query
            with self.db_handler['connection'].cursor() as cursor:
                try:
                    logger.debug(f"Executing SQL: {sql}")
                    cursor.execute(sql)
                    result = cursor.fetchall()
                    logger.info(f"Query returned {len(result)} rows")
                    
                    # Format output
                    if not result:
                        response = "No matching employee records found.\n"
                        response += "üí° Try searching with:\n"
                        response += "- Partial names (e.g., 'John' instead of 'John Smith')\n"
                        response += "- Different identifiers (ID, email, etc.)\n"
                        response += "- Broader team or project names\n"
                        return response
                    
                    return format_query_results_natural(result, question)
                    
                except pymysql.Error as db_error:
                    error_msg = f"‚ùå Database error: {str(db_error)}"
                    logger.error(f"Database error: {db_error}\nSQL: {sql}")
                    return error_msg
                except Exception as e:
                    error_msg = f"‚ùå Error processing results: {str(e)}"
                    logger.error(f"Result processing error: {e}\n{traceback.format_exc()}")
                    return error_msg
                    
        except Exception as e:
            error_msg = f"‚ùå Error processing request: {str(e)}"
            logger.error(f"Query processing error: {e}\n{traceback.format_exc()}")
            return error_msg

    def process_question(self, question: str) -> str:
        """Process questions and return results"""
        if is_dangerous(question):
            return "‚ùå Question blocked for security reasons."
            
        if not self.initialized and not self.initialize():
            return "‚ùå Team Details Assistant initialization failed. Please check database connection."
        
        # Add to chat history
        self.chat_history.append(f"User: {question}")
        
        # Get response
        response = self.query_team_details(question)
        
        # Add response to history
        self.chat_history.append(f"Assistant: {response}")
        
        return response

    def start_interactive_session(self, query):
        """Process single query and return result"""
        try:
            if not self.initialize():
                return "‚ùå Failed to initialize Team Details Assistant."
            
            if query.lower() in ['exit', 'quit', 'q']:
                return "üëã Session ended."
            
            return self.process_question(query)
            
        except KeyboardInterrupt:
            return "üëã Session interrupted."
        except Exception as e:
            error_msg = f"‚ùå Session error: {str(e)}"
            logger.error(f"Session error: {e}\n{traceback.format_exc()}")
            return error_msg
        finally:
            # Clean up database connection
            try:
                if self.db_handler and self.db_handler['connection'] and self.db_handler['connection'].open:
                    self.db_handler['connection'].close()
            except Exception as e:
                logger.error(f"Error closing connection: {e}")

def Teammain(query):
    """Main function to process team queries"""
    logger.info(f"Processing query: {query}")
    assistant = TeamDetailsAssistant()
    result = assistant.start_interactive_session(query)
    logger.info(f"Query result: {result[:200]}...")  # Log first 200 chars of result
    return result

# Test the function
if __name__ == "__main__":
    # Test with sample queries
    test_queries = [
        "Show me employee with ID 12345",
        "Find all employees named John",
        "List employees in Project ABC",
        "Count employees by team",
        "Who is John Smith?",
        "12345",  # Just an ID
        "John",   # Just a name
        "What's the email of employee 12345?"
    ]
    
    for query in test_queries:
        print(f"\n{'='*60}")
        print(f"Testing: {query}")
        print('='*60)
        result = Teammain(query)
        print(result)
